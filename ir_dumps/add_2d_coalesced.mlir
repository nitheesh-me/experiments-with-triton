// -----// IR Dump Before Inliner (inline) ('builtin.module' operation) //----- //
#loc = loc("examples/kernels/binary_ops.py":97:0)
module {
  tt.func public @add_2d_kernel(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg1: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg2: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg3: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg4: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg5: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg6: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg7: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0)) attributes {noinline = false} {
    %0 = tt.get_program_id x : i32 loc(#loc1)
    %1 = tt.get_program_id y : i32 loc(#loc2)
    %c32_i32 = arith.constant 32 : i32 loc(#loc3)
    %c32_i32_0 = arith.constant 32 : i32 loc(#loc3)
    %2 = arith.extsi %0 : i32 to i64 loc(#loc3)
    %3 = arith.extsi %c32_i32_0 : i32 to i64 loc(#loc3)
    %4 = arith.muli %2, %3 : i64 loc(#loc3) // pid_x * BLOCK_SIZE_X
    
    //----- ignore this block, just sanity check
    %c2147483647_i64 = arith.constant 2147483647 : i64 loc(#loc3)
    %c-2147483648_i64 = arith.constant -2147483648 : i64 loc(#loc3)
    %5 = arith.cmpi sle, %4, %c2147483647_i64 : i64 loc(#loc3)
    %6 = arith.cmpi sge, %4, %c-2147483648_i64 : i64 loc(#loc3)
    %7 = arith.andi %5, %6 : i1 loc(#loc3)
    //----

    %8 = arith.muli %0, %c32_i32_0 : i32 loc(#loc3)
    %9 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32> loc(#loc4)
    %10 = tt.splat %8 : i32 -> tensor<32xi32> loc(#loc5)
    %11 = arith.extsi %10 : tensor<32xi32> to tensor<32xi64> loc(#loc5)
    %12 = arith.extsi %9 : tensor<32xi32> to tensor<32xi64> loc(#loc5)
    %13 = arith.addi %11, %12 : tensor<32xi64> loc(#loc5) // offs_m = pid_x * BLOCK_SIZE_X + tl.arange(0,32)

    //----
    %c2147483647_i64_1 = arith.constant 2147483647 : i64 loc(#loc5)
    %c-2147483648_i64_2 = arith.constant -2147483648 : i64 loc(#loc5)
    %cst = arith.constant dense<2147483647> : tensor<32xi64> loc(#loc5)
    %14 = arith.cmpi sle, %13, %cst : tensor<32xi64> loc(#loc5)
    %cst_3 = arith.constant dense<-2147483648> : tensor<32xi64> loc(#loc5)
    %15 = arith.cmpi sge, %13, %cst_3 : tensor<32xi64> loc(#loc5)
    %16 = arith.andi %14, %15 : tensor<32xi1> loc(#loc5)
    //----

    %17 = arith.addi %10, %9 : tensor<32xi32> loc(#loc5) // offs_m:i32 = pid_x * BLOCK_SIZE_X + tl.arange(0,32)
    %18 = tt.splat %arg3 : i32 -> tensor<32xi32> loc(#loc6)
    %19 = arith.remsi %17, %18 : tensor<32xi32> loc(#loc6) // offs_m % M

    //---- similar instructions for pid_y
    %c32_i32_4 = arith.constant 32 : i32 loc(#loc7)
    %c32_i32_5 = arith.constant 32 : i32 loc(#loc7)
    %20 = arith.extsi %1 : i32 to i64 loc(#loc7)
    %21 = arith.extsi %c32_i32_5 : i32 to i64 loc(#loc7)
    %22 = arith.muli %20, %21 : i64 loc(#loc7)
    %c2147483647_i64_6 = arith.constant 2147483647 : i64 loc(#loc7)
    %c-2147483648_i64_7 = arith.constant -2147483648 : i64 loc(#loc7)
    %23 = arith.cmpi sle, %22, %c2147483647_i64_6 : i64 loc(#loc7)
    %24 = arith.cmpi sge, %22, %c-2147483648_i64_7 : i64 loc(#loc7)
    %25 = arith.andi %23, %24 : i1 loc(#loc7)
    %26 = arith.muli %1, %c32_i32_5 : i32 loc(#loc7)
    %27 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32> loc(#loc8)
    %28 = tt.splat %26 : i32 -> tensor<32xi32> loc(#loc9)
    %29 = arith.extsi %28 : tensor<32xi32> to tensor<32xi64> loc(#loc9)
    %30 = arith.extsi %27 : tensor<32xi32> to tensor<32xi64> loc(#loc9)
    %31 = arith.addi %29, %30 : tensor<32xi64> loc(#loc9)
    %c2147483647_i64_8 = arith.constant 2147483647 : i64 loc(#loc9)
    %c-2147483648_i64_9 = arith.constant -2147483648 : i64 loc(#loc9)
    %cst_10 = arith.constant dense<2147483647> : tensor<32xi64> loc(#loc9)
    %32 = arith.cmpi sle, %31, %cst_10 : tensor<32xi64> loc(#loc9)
    %cst_11 = arith.constant dense<-2147483648> : tensor<32xi64> loc(#loc9)
    %33 = arith.cmpi sge, %31, %cst_11 : tensor<32xi64> loc(#loc9)
    %34 = arith.andi %32, %33 : tensor<32xi1> loc(#loc9)
    %35 = arith.addi %28, %27 : tensor<32xi32> loc(#loc9)
    %36 = tt.splat %arg4 : i32 -> tensor<32xi32> loc(#loc10)
    %37 = arith.remsi %35, %36 : tensor<32xi32> loc(#loc10) // offs_n % N
    //----

    //--- offs_m[:, None] * stride_am + offs_n[None, :] * stride_an
    %38 = tt.expand_dims %19 {axis = 1 : i32} : tensor<32xi32> -> tensor<32x1xi32> loc(#loc11)
    %39 = tt.splat %arg5 : i32 -> tensor<32x1xi32> loc(#loc12)
    %40 = arith.extsi %38 : tensor<32x1xi32> to tensor<32x1xi64> loc(#loc12)
    %41 = arith.extsi %39 : tensor<32x1xi32> to tensor<32x1xi64> loc(#loc12)
    %42 = arith.muli %40, %41 : tensor<32x1xi64> loc(#loc12) // offs_m[:, None] * stride_am

    %c2147483647_i64_12 = arith.constant 2147483647 : i64 loc(#loc12)
    %c-2147483648_i64_13 = arith.constant -2147483648 : i64 loc(#loc12)
    %cst_14 = arith.constant dense<2147483647> : tensor<32x1xi64> loc(#loc12)
    %43 = arith.cmpi sle, %42, %cst_14 : tensor<32x1xi64> loc(#loc12)
    %cst_15 = arith.constant dense<-2147483648> : tensor<32x1xi64> loc(#loc12)
    %44 = arith.cmpi sge, %42, %cst_15 : tensor<32x1xi64> loc(#loc12)
    %45 = arith.andi %43, %44 : tensor<32x1xi1> loc(#loc12)
    %46 = arith.muli %38, %39 : tensor<32x1xi32> loc(#loc12) //i32: offs_m[:, None] * stride_am

    %47 = tt.expand_dims %37 {axis = 0 : i32} : tensor<32xi32> -> tensor<1x32xi32> loc(#loc13) // %37=offs_n
    %c1_i32 = arith.constant 1 : i32 loc(#loc14)
    %c1_i32_16 = arith.constant 1 : i32 loc(#loc14)
    %cst_17 = arith.constant dense<1> : tensor<1x32xi32> loc(#loc14)
    %48 = arith.extsi %47 : tensor<1x32xi32> to tensor<1x32xi64> loc(#loc14)
    %49 = arith.extsi %cst_17 : tensor<1x32xi32> to tensor<1x32xi64> loc(#loc14)
    %50 = arith.muli %48, %49 : tensor<1x32xi64> loc(#loc14) // offs_n[None, :] * stride_an

    %c2147483647_i64_18 = arith.constant 2147483647 : i64 loc(#loc14)
    %c-2147483648_i64_19 = arith.constant -2147483648 : i64 loc(#loc14)
    %cst_20 = arith.constant dense<2147483647> : tensor<1x32xi64> loc(#loc14)
    %51 = arith.cmpi sle, %50, %cst_20 : tensor<1x32xi64> loc(#loc14)
    %cst_21 = arith.constant dense<-2147483648> : tensor<1x32xi64> loc(#loc14)
    %52 = arith.cmpi sge, %50, %cst_21 : tensor<1x32xi64> loc(#loc14)
    %53 = arith.andi %51, %52 : tensor<1x32xi1> loc(#loc14)
    %54 = arith.muli %47, %cst_17 : tensor<1x32xi32> loc(#loc14) // offs_n[None, :] * stride_an

    %55 = tt.broadcast %46 : tensor<32x1xi32> -> tensor<32x32xi32> loc(#loc15)
    %56 = tt.broadcast %54 : tensor<1x32xi32> -> tensor<32x32xi32> loc(#loc15)
    %57 = arith.extsi %55 : tensor<32x32xi32> to tensor<32x32xi64> loc(#loc15)
    %58 = arith.extsi %56 : tensor<32x32xi32> to tensor<32x32xi64> loc(#loc15)
    %59 = arith.addi %57, %58 : tensor<32x32xi64> loc(#loc15) // add both offsets: offs_m[:, None] * stride_am + offs_n[None, :] * stride_an
    
    %c2147483647_i64_22 = arith.constant 2147483647 : i64 loc(#loc15)
    %c-2147483648_i64_23 = arith.constant -2147483648 : i64 loc(#loc15)
    %cst_24 = arith.constant dense<2147483647> : tensor<32x32xi64> loc(#loc15)
    %60 = arith.cmpi sle, %59, %cst_24 : tensor<32x32xi64> loc(#loc15)
    %cst_25 = arith.constant dense<-2147483648> : tensor<32x32xi64> loc(#loc15)
    %61 = arith.cmpi sge, %59, %cst_25 : tensor<32x32xi64> loc(#loc15)
    %62 = arith.andi %60, %61 : tensor<32x32xi1> loc(#loc15)
    %63 = arith.addi %55, %56 : tensor<32x32xi32> loc(#loc15) // i32: offs_m[:, None] * stride_am + offs_n[None, :] * stride_an
    
    %64 = tt.splat %arg0 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>> loc(#loc16)
    %65 = tt.addptr %64, %63 : tensor<32x32x!tt.ptr<f32>>, tensor<32x32xi32> loc(#loc16) // a_ptr + offs

    //---- b and c pointers: b_ptrs = b_ptr + offs
    %66 = tt.expand_dims %19 {axis = 1 : i32} : tensor<32xi32> -> tensor<32x1xi32> loc(#loc17)
    %67 = tt.splat %arg6 : i32 -> tensor<32x1xi32> loc(#loc18)
    %68 = arith.extsi %66 : tensor<32x1xi32> to tensor<32x1xi64> loc(#loc18)
    %69 = arith.extsi %67 : tensor<32x1xi32> to tensor<32x1xi64> loc(#loc18)
    %70 = arith.muli %68, %69 : tensor<32x1xi64> loc(#loc18)
    %c2147483647_i64_26 = arith.constant 2147483647 : i64 loc(#loc18)
    %c-2147483648_i64_27 = arith.constant -2147483648 : i64 loc(#loc18)
    %cst_28 = arith.constant dense<2147483647> : tensor<32x1xi64> loc(#loc18)
    %71 = arith.cmpi sle, %70, %cst_28 : tensor<32x1xi64> loc(#loc18)
    %cst_29 = arith.constant dense<-2147483648> : tensor<32x1xi64> loc(#loc18)
    %72 = arith.cmpi sge, %70, %cst_29 : tensor<32x1xi64> loc(#loc18)
    %73 = arith.andi %71, %72 : tensor<32x1xi1> loc(#loc18)
    %74 = arith.muli %66, %67 : tensor<32x1xi32> loc(#loc18)
    %75 = tt.expand_dims %37 {axis = 0 : i32} : tensor<32xi32> -> tensor<1x32xi32> loc(#loc19)
    %c1_i32_30 = arith.constant 1 : i32 loc(#loc20)
    %c1_i32_31 = arith.constant 1 : i32 loc(#loc20)
    %cst_32 = arith.constant dense<1> : tensor<1x32xi32> loc(#loc20)
    %76 = arith.extsi %75 : tensor<1x32xi32> to tensor<1x32xi64> loc(#loc20)
    %77 = arith.extsi %cst_32 : tensor<1x32xi32> to tensor<1x32xi64> loc(#loc20)
    %78 = arith.muli %76, %77 : tensor<1x32xi64> loc(#loc20)
    %c2147483647_i64_33 = arith.constant 2147483647 : i64 loc(#loc20)
    %c-2147483648_i64_34 = arith.constant -2147483648 : i64 loc(#loc20)
    %cst_35 = arith.constant dense<2147483647> : tensor<1x32xi64> loc(#loc20)
    %79 = arith.cmpi sle, %78, %cst_35 : tensor<1x32xi64> loc(#loc20)
    %cst_36 = arith.constant dense<-2147483648> : tensor<1x32xi64> loc(#loc20)
    %80 = arith.cmpi sge, %78, %cst_36 : tensor<1x32xi64> loc(#loc20)
    %81 = arith.andi %79, %80 : tensor<1x32xi1> loc(#loc20)
    %82 = arith.muli %75, %cst_32 : tensor<1x32xi32> loc(#loc20)
    %83 = tt.broadcast %74 : tensor<32x1xi32> -> tensor<32x32xi32> loc(#loc21)
    %84 = tt.broadcast %82 : tensor<1x32xi32> -> tensor<32x32xi32> loc(#loc21)
    %85 = arith.extsi %83 : tensor<32x32xi32> to tensor<32x32xi64> loc(#loc21)
    %86 = arith.extsi %84 : tensor<32x32xi32> to tensor<32x32xi64> loc(#loc21)
    %87 = arith.addi %85, %86 : tensor<32x32xi64> loc(#loc21)
    %c2147483647_i64_37 = arith.constant 2147483647 : i64 loc(#loc21)
    %c-2147483648_i64_38 = arith.constant -2147483648 : i64 loc(#loc21)
    %cst_39 = arith.constant dense<2147483647> : tensor<32x32xi64> loc(#loc21)
    %88 = arith.cmpi sle, %87, %cst_39 : tensor<32x32xi64> loc(#loc21)
    %cst_40 = arith.constant dense<-2147483648> : tensor<32x32xi64> loc(#loc21)
    %89 = arith.cmpi sge, %87, %cst_40 : tensor<32x32xi64> loc(#loc21)
    %90 = arith.andi %88, %89 : tensor<32x32xi1> loc(#loc21)
    %91 = arith.addi %83, %84 : tensor<32x32xi32> loc(#loc21)
    %92 = tt.splat %arg1 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>> loc(#loc22)
    %93 = tt.addptr %92, %91 : tensor<32x32x!tt.ptr<f32>>, tensor<32x32xi32> loc(#loc22)
    %94 = tt.expand_dims %19 {axis = 1 : i32} : tensor<32xi32> -> tensor<32x1xi32> loc(#loc23)
    %95 = tt.splat %arg7 : i32 -> tensor<32x1xi32> loc(#loc24)
    %96 = arith.extsi %94 : tensor<32x1xi32> to tensor<32x1xi64> loc(#loc24)
    %97 = arith.extsi %95 : tensor<32x1xi32> to tensor<32x1xi64> loc(#loc24)
    %98 = arith.muli %96, %97 : tensor<32x1xi64> loc(#loc24)
    %c2147483647_i64_41 = arith.constant 2147483647 : i64 loc(#loc24)
    %c-2147483648_i64_42 = arith.constant -2147483648 : i64 loc(#loc24)
    %cst_43 = arith.constant dense<2147483647> : tensor<32x1xi64> loc(#loc24)
    %99 = arith.cmpi sle, %98, %cst_43 : tensor<32x1xi64> loc(#loc24)
    %cst_44 = arith.constant dense<-2147483648> : tensor<32x1xi64> loc(#loc24)
    %100 = arith.cmpi sge, %98, %cst_44 : tensor<32x1xi64> loc(#loc24)
    %101 = arith.andi %99, %100 : tensor<32x1xi1> loc(#loc24)
    %102 = arith.muli %94, %95 : tensor<32x1xi32> loc(#loc24)
    %103 = tt.expand_dims %37 {axis = 0 : i32} : tensor<32xi32> -> tensor<1x32xi32> loc(#loc25)
    %c1_i32_45 = arith.constant 1 : i32 loc(#loc26)
    %c1_i32_46 = arith.constant 1 : i32 loc(#loc26)
    %cst_47 = arith.constant dense<1> : tensor<1x32xi32> loc(#loc26)
    %104 = arith.extsi %103 : tensor<1x32xi32> to tensor<1x32xi64> loc(#loc26)
    %105 = arith.extsi %cst_47 : tensor<1x32xi32> to tensor<1x32xi64> loc(#loc26)
    %106 = arith.muli %104, %105 : tensor<1x32xi64> loc(#loc26)
    %c2147483647_i64_48 = arith.constant 2147483647 : i64 loc(#loc26)
    %c-2147483648_i64_49 = arith.constant -2147483648 : i64 loc(#loc26)
    %cst_50 = arith.constant dense<2147483647> : tensor<1x32xi64> loc(#loc26)
    %107 = arith.cmpi sle, %106, %cst_50 : tensor<1x32xi64> loc(#loc26)
    %cst_51 = arith.constant dense<-2147483648> : tensor<1x32xi64> loc(#loc26)
    %108 = arith.cmpi sge, %106, %cst_51 : tensor<1x32xi64> loc(#loc26)
    %109 = arith.andi %107, %108 : tensor<1x32xi1> loc(#loc26)
    %110 = arith.muli %103, %cst_47 : tensor<1x32xi32> loc(#loc26)
    %111 = tt.broadcast %102 : tensor<32x1xi32> -> tensor<32x32xi32> loc(#loc27)
    %112 = tt.broadcast %110 : tensor<1x32xi32> -> tensor<32x32xi32> loc(#loc27)
    %113 = arith.extsi %111 : tensor<32x32xi32> to tensor<32x32xi64> loc(#loc27)
    %114 = arith.extsi %112 : tensor<32x32xi32> to tensor<32x32xi64> loc(#loc27)
    %115 = arith.addi %113, %114 : tensor<32x32xi64> loc(#loc27)
    %c2147483647_i64_52 = arith.constant 2147483647 : i64 loc(#loc27)
    %c-2147483648_i64_53 = arith.constant -2147483648 : i64 loc(#loc27)
    %cst_54 = arith.constant dense<2147483647> : tensor<32x32xi64> loc(#loc27)
    %116 = arith.cmpi sle, %115, %cst_54 : tensor<32x32xi64> loc(#loc27)
    %cst_55 = arith.constant dense<-2147483648> : tensor<32x32xi64> loc(#loc27)
    %117 = arith.cmpi sge, %115, %cst_55 : tensor<32x32xi64> loc(#loc27)
    %118 = arith.andi %116, %117 : tensor<32x32xi1> loc(#loc27)
    %119 = arith.addi %111, %112 : tensor<32x32xi32> loc(#loc27)
    %120 = tt.splat %arg2 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>> loc(#loc28)
    %121 = tt.addptr %120, %119 : tensor<32x32x!tt.ptr<f32>>, tensor<32x32xi32> loc(#loc28)
    //----

    %122 = tt.expand_dims %19 {axis = 1 : i32} : tensor<32xi32> -> tensor<32x1xi32> loc(#loc29) // offs_m[:, None]
    %123 = tt.splat %arg3 : i32 -> tensor<32x1xi32> loc(#loc30) // M
    %124 = arith.cmpi slt, %122, %123 : tensor<32x1xi32> loc(#loc30) // offs_m < M
    %125 = tt.expand_dims %37 {axis = 0 : i32} : tensor<32xi32> -> tensor<1x32xi32> loc(#loc31) // offs_n[None, :]
    %126 = tt.splat %arg4 : i32 -> tensor<1x32xi32> loc(#loc32) // N
    %127 = arith.cmpi slt, %125, %126 : tensor<1x32xi32> loc(#loc32) // offs_n < N
    %128 = tt.broadcast %124 : tensor<32x1xi1> -> tensor<32x32xi1> loc(#loc33) 
    %129 = tt.broadcast %127 : tensor<1x32xi1> -> tensor<32x32xi1> loc(#loc33)
    %130 = arith.andi %128, %129 : tensor<32x32xi1> loc(#loc33) // mask = (offs_m[:, None] < M) & (offs_n[None, :] < M)
    %cst_56 = arith.constant 0.000000e+00 : f32 loc(#loc34)
    %cst_57 = arith.constant dense<0.000000e+00> : tensor<32x32xf32> loc(#loc34)
    %131 = tt.load %65, %130, %cst_57 : tensor<32x32x!tt.ptr<f32>> loc(#loc34) // load a = tt.load(a_ptrs, mask, other)
    %cst_58 = arith.constant 0.000000e+00 : f32 loc(#loc35)
    %cst_59 = arith.constant dense<0.000000e+00> : tensor<32x32xf32> loc(#loc35)
    %132 = tt.load %93, %130, %cst_59 : tensor<32x32x!tt.ptr<f32>> loc(#loc35) // load b
    %133 = arith.addf %131, %132 : tensor<32x32xf32> loc(#loc36) // c = a + b
    tt.store %121, %133, %130 : tensor<32x32x!tt.ptr<f32>> loc(#loc37) // store c: tt.store(c_ptrs, c, mask)
    tt.return loc(#loc38)
  } loc(#loc)
} loc(#loc)
#loc1 = loc("examples/kernels/binary_ops.py":106:26)
#loc2 = loc("examples/kernels/binary_ops.py":107:26)
#loc3 = loc("examples/kernels/binary_ops.py":108:22)
#loc4 = loc("examples/kernels/binary_ops.py":108:50)
#loc5 = loc("examples/kernels/binary_ops.py":108:37)
#loc6 = loc("examples/kernels/binary_ops.py":108:67)
#loc7 = loc("examples/kernels/binary_ops.py":109:22)
#loc8 = loc("examples/kernels/binary_ops.py":109:50)
#loc9 = loc("examples/kernels/binary_ops.py":109:37)
#loc10 = loc("examples/kernels/binary_ops.py":109:67)
#loc11 = loc("examples/kernels/binary_ops.py":110:29)
#loc12 = loc("examples/kernels/binary_ops.py":110:40)
#loc13 = loc("examples/kernels/binary_ops.py":110:59)
#loc14 = loc("examples/kernels/binary_ops.py":110:70)
#loc15 = loc("examples/kernels/binary_ops.py":110:52)
#loc16 = loc("examples/kernels/binary_ops.py":110:22)
#loc17 = loc("examples/kernels/binary_ops.py":111:29)
#loc18 = loc("examples/kernels/binary_ops.py":111:40)
#loc19 = loc("examples/kernels/binary_ops.py":111:59)
#loc20 = loc("examples/kernels/binary_ops.py":111:70)
#loc21 = loc("examples/kernels/binary_ops.py":111:52)
#loc22 = loc("examples/kernels/binary_ops.py":111:22)
#loc23 = loc("examples/kernels/binary_ops.py":112:29)
#loc24 = loc("examples/kernels/binary_ops.py":112:40)
#loc25 = loc("examples/kernels/binary_ops.py":112:59)
#loc26 = loc("examples/kernels/binary_ops.py":112:70)
#loc27 = loc("examples/kernels/binary_ops.py":112:52)
#loc28 = loc("examples/kernels/binary_ops.py":112:22)
#loc29 = loc("examples/kernels/binary_ops.py":114:20)
#loc30 = loc("examples/kernels/binary_ops.py":114:31)
#loc31 = loc("examples/kernels/binary_ops.py":114:44)
#loc32 = loc("examples/kernels/binary_ops.py":114:55)
#loc33 = loc("examples/kernels/binary_ops.py":114:37)
#loc34 = loc("examples/kernels/binary_ops.py":116:16)
#loc35 = loc("examples/kernels/binary_ops.py":117:16)
#loc36 = loc("examples/kernels/binary_ops.py":118:12)
#loc37 = loc("examples/kernels/binary_ops.py":119:21)
#loc38 = loc("examples/kernels/binary_ops.py":119:4)


// -----// IR Dump Before Canonicalizer (canonicalize) ('tt.func' operation: @add_2d_kernel) //----- //
#loc = loc("examples/kernels/binary_ops.py":97:0)
module {
  tt.func public @add_2d_kernel(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg1: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg2: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg3: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg4: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg5: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg6: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg7: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0)) attributes {noinline = false} {
    %0 = tt.get_program_id x : i32 loc(#loc1)
    %1 = tt.get_program_id y : i32 loc(#loc2)
    %c32_i32 = arith.constant 32 : i32 loc(#loc3)
    %c32_i32_0 = arith.constant 32 : i32 loc(#loc3)
    %2 = arith.extsi %0 : i32 to i64 loc(#loc3)
    %3 = arith.extsi %c32_i32_0 : i32 to i64 loc(#loc3)
    %4 = arith.muli %2, %3 : i64 loc(#loc3)
    %c2147483647_i64 = arith.constant 2147483647 : i64 loc(#loc3)
    %c-2147483648_i64 = arith.constant -2147483648 : i64 loc(#loc3)
    %5 = arith.cmpi sle, %4, %c2147483647_i64 : i64 loc(#loc3)
    %6 = arith.cmpi sge, %4, %c-2147483648_i64 : i64 loc(#loc3)
    %7 = arith.andi %5, %6 : i1 loc(#loc3)
    %8 = arith.muli %0, %c32_i32_0 : i32 loc(#loc3)
    %9 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32> loc(#loc4)
    %10 = tt.splat %8 : i32 -> tensor<32xi32> loc(#loc5)
    %11 = arith.extsi %10 : tensor<32xi32> to tensor<32xi64> loc(#loc5)
    %12 = arith.extsi %9 : tensor<32xi32> to tensor<32xi64> loc(#loc5)
    %13 = arith.addi %11, %12 : tensor<32xi64> loc(#loc5)
    %c2147483647_i64_1 = arith.constant 2147483647 : i64 loc(#loc5)
    %c-2147483648_i64_2 = arith.constant -2147483648 : i64 loc(#loc5)
    %cst = arith.constant dense<2147483647> : tensor<32xi64> loc(#loc5)
    %14 = arith.cmpi sle, %13, %cst : tensor<32xi64> loc(#loc5)
    %cst_3 = arith.constant dense<-2147483648> : tensor<32xi64> loc(#loc5)
    %15 = arith.cmpi sge, %13, %cst_3 : tensor<32xi64> loc(#loc5)
    %16 = arith.andi %14, %15 : tensor<32xi1> loc(#loc5)
    %17 = arith.addi %10, %9 : tensor<32xi32> loc(#loc5)
    %18 = tt.splat %arg3 : i32 -> tensor<32xi32> loc(#loc6)
    %19 = arith.remsi %17, %18 : tensor<32xi32> loc(#loc6)
    %c32_i32_4 = arith.constant 32 : i32 loc(#loc7)
    %c32_i32_5 = arith.constant 32 : i32 loc(#loc7)
    %20 = arith.extsi %1 : i32 to i64 loc(#loc7)
    %21 = arith.extsi %c32_i32_5 : i32 to i64 loc(#loc7)
    %22 = arith.muli %20, %21 : i64 loc(#loc7)
    %c2147483647_i64_6 = arith.constant 2147483647 : i64 loc(#loc7)
    %c-2147483648_i64_7 = arith.constant -2147483648 : i64 loc(#loc7)
    %23 = arith.cmpi sle, %22, %c2147483647_i64_6 : i64 loc(#loc7)
    %24 = arith.cmpi sge, %22, %c-2147483648_i64_7 : i64 loc(#loc7)
    %25 = arith.andi %23, %24 : i1 loc(#loc7)
    %26 = arith.muli %1, %c32_i32_5 : i32 loc(#loc7)
    %27 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32> loc(#loc8)
    %28 = tt.splat %26 : i32 -> tensor<32xi32> loc(#loc9)
    %29 = arith.extsi %28 : tensor<32xi32> to tensor<32xi64> loc(#loc9)
    %30 = arith.extsi %27 : tensor<32xi32> to tensor<32xi64> loc(#loc9)
    %31 = arith.addi %29, %30 : tensor<32xi64> loc(#loc9)
    %c2147483647_i64_8 = arith.constant 2147483647 : i64 loc(#loc9)
    %c-2147483648_i64_9 = arith.constant -2147483648 : i64 loc(#loc9)
    %cst_10 = arith.constant dense<2147483647> : tensor<32xi64> loc(#loc9)
    %32 = arith.cmpi sle, %31, %cst_10 : tensor<32xi64> loc(#loc9)
    %cst_11 = arith.constant dense<-2147483648> : tensor<32xi64> loc(#loc9)
    %33 = arith.cmpi sge, %31, %cst_11 : tensor<32xi64> loc(#loc9)
    %34 = arith.andi %32, %33 : tensor<32xi1> loc(#loc9)
    %35 = arith.addi %28, %27 : tensor<32xi32> loc(#loc9)
    %36 = tt.splat %arg4 : i32 -> tensor<32xi32> loc(#loc10)
    %37 = arith.remsi %35, %36 : tensor<32xi32> loc(#loc10)
    %38 = tt.expand_dims %19 {axis = 1 : i32} : tensor<32xi32> -> tensor<32x1xi32> loc(#loc11)
    %39 = tt.splat %arg5 : i32 -> tensor<32x1xi32> loc(#loc12)
    %40 = arith.extsi %38 : tensor<32x1xi32> to tensor<32x1xi64> loc(#loc12)
    %41 = arith.extsi %39 : tensor<32x1xi32> to tensor<32x1xi64> loc(#loc12)
    %42 = arith.muli %40, %41 : tensor<32x1xi64> loc(#loc12)
    %c2147483647_i64_12 = arith.constant 2147483647 : i64 loc(#loc12)
    %c-2147483648_i64_13 = arith.constant -2147483648 : i64 loc(#loc12)
    %cst_14 = arith.constant dense<2147483647> : tensor<32x1xi64> loc(#loc12)
    %43 = arith.cmpi sle, %42, %cst_14 : tensor<32x1xi64> loc(#loc12)
    %cst_15 = arith.constant dense<-2147483648> : tensor<32x1xi64> loc(#loc12)
    %44 = arith.cmpi sge, %42, %cst_15 : tensor<32x1xi64> loc(#loc12)
    %45 = arith.andi %43, %44 : tensor<32x1xi1> loc(#loc12)
    %46 = arith.muli %38, %39 : tensor<32x1xi32> loc(#loc12)
    %47 = tt.expand_dims %37 {axis = 0 : i32} : tensor<32xi32> -> tensor<1x32xi32> loc(#loc13)
    %c1_i32 = arith.constant 1 : i32 loc(#loc14)
    %c1_i32_16 = arith.constant 1 : i32 loc(#loc14)
    %cst_17 = arith.constant dense<1> : tensor<1x32xi32> loc(#loc14)
    %48 = arith.extsi %47 : tensor<1x32xi32> to tensor<1x32xi64> loc(#loc14)
    %49 = arith.extsi %cst_17 : tensor<1x32xi32> to tensor<1x32xi64> loc(#loc14)
    %50 = arith.muli %48, %49 : tensor<1x32xi64> loc(#loc14)
    %c2147483647_i64_18 = arith.constant 2147483647 : i64 loc(#loc14)
    %c-2147483648_i64_19 = arith.constant -2147483648 : i64 loc(#loc14)
    %cst_20 = arith.constant dense<2147483647> : tensor<1x32xi64> loc(#loc14)
    %51 = arith.cmpi sle, %50, %cst_20 : tensor<1x32xi64> loc(#loc14)
    %cst_21 = arith.constant dense<-2147483648> : tensor<1x32xi64> loc(#loc14)
    %52 = arith.cmpi sge, %50, %cst_21 : tensor<1x32xi64> loc(#loc14)
    %53 = arith.andi %51, %52 : tensor<1x32xi1> loc(#loc14)
    %54 = arith.muli %47, %cst_17 : tensor<1x32xi32> loc(#loc14)
    %55 = tt.broadcast %46 : tensor<32x1xi32> -> tensor<32x32xi32> loc(#loc15)
    %56 = tt.broadcast %54 : tensor<1x32xi32> -> tensor<32x32xi32> loc(#loc15)
    %57 = arith.extsi %55 : tensor<32x32xi32> to tensor<32x32xi64> loc(#loc15)
    %58 = arith.extsi %56 : tensor<32x32xi32> to tensor<32x32xi64> loc(#loc15)
    %59 = arith.addi %57, %58 : tensor<32x32xi64> loc(#loc15)
    %c2147483647_i64_22 = arith.constant 2147483647 : i64 loc(#loc15)
    %c-2147483648_i64_23 = arith.constant -2147483648 : i64 loc(#loc15)
    %cst_24 = arith.constant dense<2147483647> : tensor<32x32xi64> loc(#loc15)
    %60 = arith.cmpi sle, %59, %cst_24 : tensor<32x32xi64> loc(#loc15)
    %cst_25 = arith.constant dense<-2147483648> : tensor<32x32xi64> loc(#loc15)
    %61 = arith.cmpi sge, %59, %cst_25 : tensor<32x32xi64> loc(#loc15)
    %62 = arith.andi %60, %61 : tensor<32x32xi1> loc(#loc15)
    %63 = arith.addi %55, %56 : tensor<32x32xi32> loc(#loc15)
    %64 = tt.splat %arg0 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>> loc(#loc16)
    %65 = tt.addptr %64, %63 : tensor<32x32x!tt.ptr<f32>>, tensor<32x32xi32> loc(#loc16)
    %66 = tt.expand_dims %19 {axis = 1 : i32} : tensor<32xi32> -> tensor<32x1xi32> loc(#loc17)
    %67 = tt.splat %arg6 : i32 -> tensor<32x1xi32> loc(#loc18)
    %68 = arith.extsi %66 : tensor<32x1xi32> to tensor<32x1xi64> loc(#loc18)
    %69 = arith.extsi %67 : tensor<32x1xi32> to tensor<32x1xi64> loc(#loc18)
    %70 = arith.muli %68, %69 : tensor<32x1xi64> loc(#loc18)
    %c2147483647_i64_26 = arith.constant 2147483647 : i64 loc(#loc18)
    %c-2147483648_i64_27 = arith.constant -2147483648 : i64 loc(#loc18)
    %cst_28 = arith.constant dense<2147483647> : tensor<32x1xi64> loc(#loc18)
    %71 = arith.cmpi sle, %70, %cst_28 : tensor<32x1xi64> loc(#loc18)
    %cst_29 = arith.constant dense<-2147483648> : tensor<32x1xi64> loc(#loc18)
    %72 = arith.cmpi sge, %70, %cst_29 : tensor<32x1xi64> loc(#loc18)
    %73 = arith.andi %71, %72 : tensor<32x1xi1> loc(#loc18)
    %74 = arith.muli %66, %67 : tensor<32x1xi32> loc(#loc18)
    %75 = tt.expand_dims %37 {axis = 0 : i32} : tensor<32xi32> -> tensor<1x32xi32> loc(#loc19)
    %c1_i32_30 = arith.constant 1 : i32 loc(#loc20)
    %c1_i32_31 = arith.constant 1 : i32 loc(#loc20)
    %cst_32 = arith.constant dense<1> : tensor<1x32xi32> loc(#loc20)
    %76 = arith.extsi %75 : tensor<1x32xi32> to tensor<1x32xi64> loc(#loc20)
    %77 = arith.extsi %cst_32 : tensor<1x32xi32> to tensor<1x32xi64> loc(#loc20)
    %78 = arith.muli %76, %77 : tensor<1x32xi64> loc(#loc20)
    %c2147483647_i64_33 = arith.constant 2147483647 : i64 loc(#loc20)
    %c-2147483648_i64_34 = arith.constant -2147483648 : i64 loc(#loc20)
    %cst_35 = arith.constant dense<2147483647> : tensor<1x32xi64> loc(#loc20)
    %79 = arith.cmpi sle, %78, %cst_35 : tensor<1x32xi64> loc(#loc20)
    %cst_36 = arith.constant dense<-2147483648> : tensor<1x32xi64> loc(#loc20)
    %80 = arith.cmpi sge, %78, %cst_36 : tensor<1x32xi64> loc(#loc20)
    %81 = arith.andi %79, %80 : tensor<1x32xi1> loc(#loc20)
    %82 = arith.muli %75, %cst_32 : tensor<1x32xi32> loc(#loc20)
    %83 = tt.broadcast %74 : tensor<32x1xi32> -> tensor<32x32xi32> loc(#loc21)
    %84 = tt.broadcast %82 : tensor<1x32xi32> -> tensor<32x32xi32> loc(#loc21)
    %85 = arith.extsi %83 : tensor<32x32xi32> to tensor<32x32xi64> loc(#loc21)
    %86 = arith.extsi %84 : tensor<32x32xi32> to tensor<32x32xi64> loc(#loc21)
    %87 = arith.addi %85, %86 : tensor<32x32xi64> loc(#loc21)
    %c2147483647_i64_37 = arith.constant 2147483647 : i64 loc(#loc21)
    %c-2147483648_i64_38 = arith.constant -2147483648 : i64 loc(#loc21)
    %cst_39 = arith.constant dense<2147483647> : tensor<32x32xi64> loc(#loc21)
    %88 = arith.cmpi sle, %87, %cst_39 : tensor<32x32xi64> loc(#loc21)
    %cst_40 = arith.constant dense<-2147483648> : tensor<32x32xi64> loc(#loc21)
    %89 = arith.cmpi sge, %87, %cst_40 : tensor<32x32xi64> loc(#loc21)
    %90 = arith.andi %88, %89 : tensor<32x32xi1> loc(#loc21)
    %91 = arith.addi %83, %84 : tensor<32x32xi32> loc(#loc21)
    %92 = tt.splat %arg1 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>> loc(#loc22)
    %93 = tt.addptr %92, %91 : tensor<32x32x!tt.ptr<f32>>, tensor<32x32xi32> loc(#loc22)
    %94 = tt.expand_dims %19 {axis = 1 : i32} : tensor<32xi32> -> tensor<32x1xi32> loc(#loc23)
    %95 = tt.splat %arg7 : i32 -> tensor<32x1xi32> loc(#loc24)
    %96 = arith.extsi %94 : tensor<32x1xi32> to tensor<32x1xi64> loc(#loc24)
    %97 = arith.extsi %95 : tensor<32x1xi32> to tensor<32x1xi64> loc(#loc24)
    %98 = arith.muli %96, %97 : tensor<32x1xi64> loc(#loc24)
    %c2147483647_i64_41 = arith.constant 2147483647 : i64 loc(#loc24)
    %c-2147483648_i64_42 = arith.constant -2147483648 : i64 loc(#loc24)
    %cst_43 = arith.constant dense<2147483647> : tensor<32x1xi64> loc(#loc24)
    %99 = arith.cmpi sle, %98, %cst_43 : tensor<32x1xi64> loc(#loc24)
    %cst_44 = arith.constant dense<-2147483648> : tensor<32x1xi64> loc(#loc24)
    %100 = arith.cmpi sge, %98, %cst_44 : tensor<32x1xi64> loc(#loc24)
    %101 = arith.andi %99, %100 : tensor<32x1xi1> loc(#loc24)
    %102 = arith.muli %94, %95 : tensor<32x1xi32> loc(#loc24)
    %103 = tt.expand_dims %37 {axis = 0 : i32} : tensor<32xi32> -> tensor<1x32xi32> loc(#loc25)
    %c1_i32_45 = arith.constant 1 : i32 loc(#loc26)
    %c1_i32_46 = arith.constant 1 : i32 loc(#loc26)
    %cst_47 = arith.constant dense<1> : tensor<1x32xi32> loc(#loc26)
    %104 = arith.extsi %103 : tensor<1x32xi32> to tensor<1x32xi64> loc(#loc26)
    %105 = arith.extsi %cst_47 : tensor<1x32xi32> to tensor<1x32xi64> loc(#loc26)
    %106 = arith.muli %104, %105 : tensor<1x32xi64> loc(#loc26)
    %c2147483647_i64_48 = arith.constant 2147483647 : i64 loc(#loc26)
    %c-2147483648_i64_49 = arith.constant -2147483648 : i64 loc(#loc26)
    %cst_50 = arith.constant dense<2147483647> : tensor<1x32xi64> loc(#loc26)
    %107 = arith.cmpi sle, %106, %cst_50 : tensor<1x32xi64> loc(#loc26)
    %cst_51 = arith.constant dense<-2147483648> : tensor<1x32xi64> loc(#loc26)
    %108 = arith.cmpi sge, %106, %cst_51 : tensor<1x32xi64> loc(#loc26)
    %109 = arith.andi %107, %108 : tensor<1x32xi1> loc(#loc26)
    %110 = arith.muli %103, %cst_47 : tensor<1x32xi32> loc(#loc26)
    %111 = tt.broadcast %102 : tensor<32x1xi32> -> tensor<32x32xi32> loc(#loc27)
    %112 = tt.broadcast %110 : tensor<1x32xi32> -> tensor<32x32xi32> loc(#loc27)
    %113 = arith.extsi %111 : tensor<32x32xi32> to tensor<32x32xi64> loc(#loc27)
    %114 = arith.extsi %112 : tensor<32x32xi32> to tensor<32x32xi64> loc(#loc27)
    %115 = arith.addi %113, %114 : tensor<32x32xi64> loc(#loc27)
    %c2147483647_i64_52 = arith.constant 2147483647 : i64 loc(#loc27)
    %c-2147483648_i64_53 = arith.constant -2147483648 : i64 loc(#loc27)
    %cst_54 = arith.constant dense<2147483647> : tensor<32x32xi64> loc(#loc27)
    %116 = arith.cmpi sle, %115, %cst_54 : tensor<32x32xi64> loc(#loc27)
    %cst_55 = arith.constant dense<-2147483648> : tensor<32x32xi64> loc(#loc27)
    %117 = arith.cmpi sge, %115, %cst_55 : tensor<32x32xi64> loc(#loc27)
    %118 = arith.andi %116, %117 : tensor<32x32xi1> loc(#loc27)
    %119 = arith.addi %111, %112 : tensor<32x32xi32> loc(#loc27)
    %120 = tt.splat %arg2 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>> loc(#loc28)
    %121 = tt.addptr %120, %119 : tensor<32x32x!tt.ptr<f32>>, tensor<32x32xi32> loc(#loc28)
    %122 = tt.expand_dims %19 {axis = 1 : i32} : tensor<32xi32> -> tensor<32x1xi32> loc(#loc29)
    %123 = tt.splat %arg3 : i32 -> tensor<32x1xi32> loc(#loc30)
    %124 = arith.cmpi slt, %122, %123 : tensor<32x1xi32> loc(#loc30)
    %125 = tt.expand_dims %37 {axis = 0 : i32} : tensor<32xi32> -> tensor<1x32xi32> loc(#loc31)
    %126 = tt.splat %arg4 : i32 -> tensor<1x32xi32> loc(#loc32)
    %127 = arith.cmpi slt, %125, %126 : tensor<1x32xi32> loc(#loc32)
    %128 = tt.broadcast %124 : tensor<32x1xi1> -> tensor<32x32xi1> loc(#loc33)
    %129 = tt.broadcast %127 : tensor<1x32xi1> -> tensor<32x32xi1> loc(#loc33)
    %130 = arith.andi %128, %129 : tensor<32x32xi1> loc(#loc33)
    %cst_56 = arith.constant 0.000000e+00 : f32 loc(#loc34)
    %cst_57 = arith.constant dense<0.000000e+00> : tensor<32x32xf32> loc(#loc34)
    %131 = tt.load %65, %130, %cst_57 : tensor<32x32x!tt.ptr<f32>> loc(#loc34)
    %cst_58 = arith.constant 0.000000e+00 : f32 loc(#loc35)
    %cst_59 = arith.constant dense<0.000000e+00> : tensor<32x32xf32> loc(#loc35)
    %132 = tt.load %93, %130, %cst_59 : tensor<32x32x!tt.ptr<f32>> loc(#loc35)
    %133 = arith.addf %131, %132 : tensor<32x32xf32> loc(#loc36)
    tt.store %121, %133, %130 : tensor<32x32x!tt.ptr<f32>> loc(#loc37)
    tt.return loc(#loc38)
  } loc(#loc)
} loc(#loc)
#loc1 = loc("examples/kernels/binary_ops.py":106:26)
#loc2 = loc("examples/kernels/binary_ops.py":107:26)
#loc3 = loc("examples/kernels/binary_ops.py":108:22)
#loc4 = loc("examples/kernels/binary_ops.py":108:50)
#loc5 = loc("examples/kernels/binary_ops.py":108:37)
#loc6 = loc("examples/kernels/binary_ops.py":108:67)
#loc7 = loc("examples/kernels/binary_ops.py":109:22)
#loc8 = loc("examples/kernels/binary_ops.py":109:50)
#loc9 = loc("examples/kernels/binary_ops.py":109:37)
#loc10 = loc("examples/kernels/binary_ops.py":109:67)
#loc11 = loc("examples/kernels/binary_ops.py":110:29)
#loc12 = loc("examples/kernels/binary_ops.py":110:40)
#loc13 = loc("examples/kernels/binary_ops.py":110:59)
#loc14 = loc("examples/kernels/binary_ops.py":110:70)
#loc15 = loc("examples/kernels/binary_ops.py":110:52)
#loc16 = loc("examples/kernels/binary_ops.py":110:22)
#loc17 = loc("examples/kernels/binary_ops.py":111:29)
#loc18 = loc("examples/kernels/binary_ops.py":111:40)
#loc19 = loc("examples/kernels/binary_ops.py":111:59)
#loc20 = loc("examples/kernels/binary_ops.py":111:70)
#loc21 = loc("examples/kernels/binary_ops.py":111:52)
#loc22 = loc("examples/kernels/binary_ops.py":111:22)
#loc23 = loc("examples/kernels/binary_ops.py":112:29)
#loc24 = loc("examples/kernels/binary_ops.py":112:40)
#loc25 = loc("examples/kernels/binary_ops.py":112:59)
#loc26 = loc("examples/kernels/binary_ops.py":112:70)
#loc27 = loc("examples/kernels/binary_ops.py":112:52)
#loc28 = loc("examples/kernels/binary_ops.py":112:22)
#loc29 = loc("examples/kernels/binary_ops.py":114:20)
#loc30 = loc("examples/kernels/binary_ops.py":114:31)
#loc31 = loc("examples/kernels/binary_ops.py":114:44)
#loc32 = loc("examples/kernels/binary_ops.py":114:55)
#loc33 = loc("examples/kernels/binary_ops.py":114:37)
#loc34 = loc("examples/kernels/binary_ops.py":116:16)
#loc35 = loc("examples/kernels/binary_ops.py":117:16)
#loc36 = loc("examples/kernels/binary_ops.py":118:12)
#loc37 = loc("examples/kernels/binary_ops.py":119:21)
#loc38 = loc("examples/kernels/binary_ops.py":119:4)


// -----// IR Dump Before TritonRewriteTensorPointer (triton-rewrite-tensor-pointer) ('builtin.module' operation) //----- //
#loc = loc("examples/kernels/binary_ops.py":97:0)
module {
  tt.func public @add_2d_kernel(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg1: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg2: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg3: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg4: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg5: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg6: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg7: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0)) attributes {noinline = false} {
    %cst = arith.constant dense<0.000000e+00> : tensor<32x32xf32> loc(#loc1)
    %c32_i32 = arith.constant 32 : i32 loc(#loc1)
    %0 = tt.get_program_id x : i32 loc(#loc2)
    %1 = tt.get_program_id y : i32 loc(#loc3)
    %2 = arith.muli %0, %c32_i32 : i32 loc(#loc4)
    %3 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32> loc(#loc5)
    %4 = tt.splat %2 : i32 -> tensor<32xi32> loc(#loc6)
    %5 = arith.addi %4, %3 : tensor<32xi32> loc(#loc6)
    %6 = tt.splat %arg3 : i32 -> tensor<32xi32> loc(#loc7)
    %7 = arith.remsi %5, %6 : tensor<32xi32> loc(#loc7)
    %8 = arith.muli %1, %c32_i32 : i32 loc(#loc8)
    %9 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32> loc(#loc9)
    %10 = tt.splat %8 : i32 -> tensor<32xi32> loc(#loc10)
    %11 = arith.addi %10, %9 : tensor<32xi32> loc(#loc10)
    %12 = tt.splat %arg4 : i32 -> tensor<32xi32> loc(#loc11)
    %13 = arith.remsi %11, %12 : tensor<32xi32> loc(#loc11)
    %14 = tt.expand_dims %7 {axis = 1 : i32} : tensor<32xi32> -> tensor<32x1xi32> loc(#loc12)
    %15 = tt.splat %arg5 : i32 -> tensor<32x1xi32> loc(#loc13)
    %16 = arith.muli %14, %15 : tensor<32x1xi32> loc(#loc13)
    %17 = tt.expand_dims %13 {axis = 0 : i32} : tensor<32xi32> -> tensor<1x32xi32> loc(#loc14)
    %18 = tt.broadcast %16 : tensor<32x1xi32> -> tensor<32x32xi32> loc(#loc15)
    %19 = tt.broadcast %17 : tensor<1x32xi32> -> tensor<32x32xi32> loc(#loc15)
    %20 = arith.addi %18, %19 : tensor<32x32xi32> loc(#loc15)
    %21 = tt.splat %arg0 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>> loc(#loc16)
    %22 = tt.addptr %21, %20 : tensor<32x32x!tt.ptr<f32>>, tensor<32x32xi32> loc(#loc16)
    %23 = tt.expand_dims %7 {axis = 1 : i32} : tensor<32xi32> -> tensor<32x1xi32> loc(#loc17)
    %24 = tt.splat %arg6 : i32 -> tensor<32x1xi32> loc(#loc18)
    %25 = arith.muli %23, %24 : tensor<32x1xi32> loc(#loc18)
    %26 = tt.expand_dims %13 {axis = 0 : i32} : tensor<32xi32> -> tensor<1x32xi32> loc(#loc19)
    %27 = tt.broadcast %25 : tensor<32x1xi32> -> tensor<32x32xi32> loc(#loc20)
    %28 = tt.broadcast %26 : tensor<1x32xi32> -> tensor<32x32xi32> loc(#loc20)
    %29 = arith.addi %27, %28 : tensor<32x32xi32> loc(#loc20)
    %30 = tt.splat %arg1 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>> loc(#loc21)
    %31 = tt.addptr %30, %29 : tensor<32x32x!tt.ptr<f32>>, tensor<32x32xi32> loc(#loc21)
    %32 = tt.expand_dims %7 {axis = 1 : i32} : tensor<32xi32> -> tensor<32x1xi32> loc(#loc22)
    %33 = tt.splat %arg7 : i32 -> tensor<32x1xi32> loc(#loc23)
    %34 = arith.muli %32, %33 : tensor<32x1xi32> loc(#loc23)
    %35 = tt.expand_dims %13 {axis = 0 : i32} : tensor<32xi32> -> tensor<1x32xi32> loc(#loc24)
    %36 = tt.broadcast %34 : tensor<32x1xi32> -> tensor<32x32xi32> loc(#loc25)
    %37 = tt.broadcast %35 : tensor<1x32xi32> -> tensor<32x32xi32> loc(#loc25)
    %38 = arith.addi %36, %37 : tensor<32x32xi32> loc(#loc25)
    %39 = tt.splat %arg2 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>> loc(#loc26)
    %40 = tt.addptr %39, %38 : tensor<32x32x!tt.ptr<f32>>, tensor<32x32xi32> loc(#loc26)
    %41 = tt.expand_dims %7 {axis = 1 : i32} : tensor<32xi32> -> tensor<32x1xi32> loc(#loc27)
    %42 = tt.splat %arg3 : i32 -> tensor<32x1xi32> loc(#loc28)
    %43 = arith.cmpi slt, %41, %42 : tensor<32x1xi32> loc(#loc28)
    %44 = tt.expand_dims %13 {axis = 0 : i32} : tensor<32xi32> -> tensor<1x32xi32> loc(#loc29)
    %45 = tt.splat %arg4 : i32 -> tensor<1x32xi32> loc(#loc30)
    %46 = arith.cmpi slt, %44, %45 : tensor<1x32xi32> loc(#loc30)
    %47 = tt.broadcast %43 : tensor<32x1xi1> -> tensor<32x32xi1> loc(#loc31)
    %48 = tt.broadcast %46 : tensor<1x32xi1> -> tensor<32x32xi1> loc(#loc31)
    %49 = arith.andi %47, %48 : tensor<32x32xi1> loc(#loc31)
    %50 = tt.load %22, %49, %cst : tensor<32x32x!tt.ptr<f32>> loc(#loc32)
    %51 = tt.load %31, %49, %cst : tensor<32x32x!tt.ptr<f32>> loc(#loc33)
    %52 = arith.addf %50, %51 : tensor<32x32xf32> loc(#loc34)
    tt.store %40, %52, %49 : tensor<32x32x!tt.ptr<f32>> loc(#loc35)
    tt.return loc(#loc36)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("examples/kernels/binary_ops.py":106:26)
#loc3 = loc("examples/kernels/binary_ops.py":107:26)
#loc4 = loc("examples/kernels/binary_ops.py":108:22)
#loc5 = loc("examples/kernels/binary_ops.py":108:50)
#loc6 = loc("examples/kernels/binary_ops.py":108:37)
#loc7 = loc("examples/kernels/binary_ops.py":108:67)
#loc8 = loc("examples/kernels/binary_ops.py":109:22)
#loc9 = loc("examples/kernels/binary_ops.py":109:50)
#loc10 = loc("examples/kernels/binary_ops.py":109:37)
#loc11 = loc("examples/kernels/binary_ops.py":109:67)
#loc12 = loc("examples/kernels/binary_ops.py":110:29)
#loc13 = loc("examples/kernels/binary_ops.py":110:40)
#loc14 = loc("examples/kernels/binary_ops.py":110:59)
#loc15 = loc("examples/kernels/binary_ops.py":110:52)
#loc16 = loc("examples/kernels/binary_ops.py":110:22)
#loc17 = loc("examples/kernels/binary_ops.py":111:29)
#loc18 = loc("examples/kernels/binary_ops.py":111:40)
#loc19 = loc("examples/kernels/binary_ops.py":111:59)
#loc20 = loc("examples/kernels/binary_ops.py":111:52)
#loc21 = loc("examples/kernels/binary_ops.py":111:22)
#loc22 = loc("examples/kernels/binary_ops.py":112:29)
#loc23 = loc("examples/kernels/binary_ops.py":112:40)
#loc24 = loc("examples/kernels/binary_ops.py":112:59)
#loc25 = loc("examples/kernels/binary_ops.py":112:52)
#loc26 = loc("examples/kernels/binary_ops.py":112:22)
#loc27 = loc("examples/kernels/binary_ops.py":114:20)
#loc28 = loc("examples/kernels/binary_ops.py":114:31)
#loc29 = loc("examples/kernels/binary_ops.py":114:44)
#loc30 = loc("examples/kernels/binary_ops.py":114:55)
#loc31 = loc("examples/kernels/binary_ops.py":114:37)
#loc32 = loc("examples/kernels/binary_ops.py":116:16)
#loc33 = loc("examples/kernels/binary_ops.py":117:16)
#loc34 = loc("examples/kernels/binary_ops.py":118:12)
#loc35 = loc("examples/kernels/binary_ops.py":119:21)
#loc36 = loc("examples/kernels/binary_ops.py":119:4)


// -----// IR Dump Before Canonicalizer (canonicalize) ('builtin.module' operation) //----- //
#loc = loc("examples/kernels/binary_ops.py":97:0)
module {
  tt.func public @add_2d_kernel(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg1: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg2: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg3: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg4: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg5: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg6: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg7: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0)) attributes {noinline = false} {
    %cst = arith.constant dense<0.000000e+00> : tensor<32x32xf32> loc(#loc1)
    %c32_i32 = arith.constant 32 : i32 loc(#loc1)
    %0 = tt.get_program_id x : i32 loc(#loc2)
    %1 = tt.get_program_id y : i32 loc(#loc3)
    %2 = arith.muli %0, %c32_i32 : i32 loc(#loc4)
    %3 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32> loc(#loc5)
    %4 = tt.splat %2 : i32 -> tensor<32xi32> loc(#loc6)
    %5 = arith.addi %4, %3 : tensor<32xi32> loc(#loc6)
    %6 = tt.splat %arg3 : i32 -> tensor<32xi32> loc(#loc7)
    %7 = arith.remsi %5, %6 : tensor<32xi32> loc(#loc7)
    %8 = arith.muli %1, %c32_i32 : i32 loc(#loc8)
    %9 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32> loc(#loc9)
    %10 = tt.splat %8 : i32 -> tensor<32xi32> loc(#loc10)
    %11 = arith.addi %10, %9 : tensor<32xi32> loc(#loc10)
    %12 = tt.splat %arg4 : i32 -> tensor<32xi32> loc(#loc11)
    %13 = arith.remsi %11, %12 : tensor<32xi32> loc(#loc11)
    %14 = tt.expand_dims %7 {axis = 1 : i32} : tensor<32xi32> -> tensor<32x1xi32> loc(#loc12)
    %15 = tt.splat %arg5 : i32 -> tensor<32x1xi32> loc(#loc13)
    %16 = arith.muli %14, %15 : tensor<32x1xi32> loc(#loc13)
    %17 = tt.expand_dims %13 {axis = 0 : i32} : tensor<32xi32> -> tensor<1x32xi32> loc(#loc14)
    %18 = tt.broadcast %16 : tensor<32x1xi32> -> tensor<32x32xi32> loc(#loc15)
    %19 = tt.broadcast %17 : tensor<1x32xi32> -> tensor<32x32xi32> loc(#loc15)
    %20 = arith.addi %18, %19 : tensor<32x32xi32> loc(#loc15)
    %21 = tt.splat %arg0 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>> loc(#loc16)
    %22 = tt.addptr %21, %20 : tensor<32x32x!tt.ptr<f32>>, tensor<32x32xi32> loc(#loc16)
    %23 = tt.expand_dims %7 {axis = 1 : i32} : tensor<32xi32> -> tensor<32x1xi32> loc(#loc17)
    %24 = tt.splat %arg6 : i32 -> tensor<32x1xi32> loc(#loc18)
    %25 = arith.muli %23, %24 : tensor<32x1xi32> loc(#loc18)
    %26 = tt.expand_dims %13 {axis = 0 : i32} : tensor<32xi32> -> tensor<1x32xi32> loc(#loc19)
    %27 = tt.broadcast %25 : tensor<32x1xi32> -> tensor<32x32xi32> loc(#loc20)
    %28 = tt.broadcast %26 : tensor<1x32xi32> -> tensor<32x32xi32> loc(#loc20)
    %29 = arith.addi %27, %28 : tensor<32x32xi32> loc(#loc20)
    %30 = tt.splat %arg1 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>> loc(#loc21)
    %31 = tt.addptr %30, %29 : tensor<32x32x!tt.ptr<f32>>, tensor<32x32xi32> loc(#loc21)
    %32 = tt.expand_dims %7 {axis = 1 : i32} : tensor<32xi32> -> tensor<32x1xi32> loc(#loc22)
    %33 = tt.splat %arg7 : i32 -> tensor<32x1xi32> loc(#loc23)
    %34 = arith.muli %32, %33 : tensor<32x1xi32> loc(#loc23)
    %35 = tt.expand_dims %13 {axis = 0 : i32} : tensor<32xi32> -> tensor<1x32xi32> loc(#loc24)
    %36 = tt.broadcast %34 : tensor<32x1xi32> -> tensor<32x32xi32> loc(#loc25)
    %37 = tt.broadcast %35 : tensor<1x32xi32> -> tensor<32x32xi32> loc(#loc25)
    %38 = arith.addi %36, %37 : tensor<32x32xi32> loc(#loc25)
    %39 = tt.splat %arg2 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>> loc(#loc26)
    %40 = tt.addptr %39, %38 : tensor<32x32x!tt.ptr<f32>>, tensor<32x32xi32> loc(#loc26)
    %41 = tt.expand_dims %7 {axis = 1 : i32} : tensor<32xi32> -> tensor<32x1xi32> loc(#loc27)
    %42 = tt.splat %arg3 : i32 -> tensor<32x1xi32> loc(#loc28)
    %43 = arith.cmpi slt, %41, %42 : tensor<32x1xi32> loc(#loc28)
    %44 = tt.expand_dims %13 {axis = 0 : i32} : tensor<32xi32> -> tensor<1x32xi32> loc(#loc29)
    %45 = tt.splat %arg4 : i32 -> tensor<1x32xi32> loc(#loc30)
    %46 = arith.cmpi slt, %44, %45 : tensor<1x32xi32> loc(#loc30)
    %47 = tt.broadcast %43 : tensor<32x1xi1> -> tensor<32x32xi1> loc(#loc31)
    %48 = tt.broadcast %46 : tensor<1x32xi1> -> tensor<32x32xi1> loc(#loc31)
    %49 = arith.andi %47, %48 : tensor<32x32xi1> loc(#loc31)
    %50 = tt.load %22, %49, %cst : tensor<32x32x!tt.ptr<f32>> loc(#loc32)
    %51 = tt.load %31, %49, %cst : tensor<32x32x!tt.ptr<f32>> loc(#loc33)
    %52 = arith.addf %50, %51 : tensor<32x32xf32> loc(#loc34)
    tt.store %40, %52, %49 : tensor<32x32x!tt.ptr<f32>> loc(#loc35)
    tt.return loc(#loc36)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("examples/kernels/binary_ops.py":106:26)
#loc3 = loc("examples/kernels/binary_ops.py":107:26)
#loc4 = loc("examples/kernels/binary_ops.py":108:22)
#loc5 = loc("examples/kernels/binary_ops.py":108:50)
#loc6 = loc("examples/kernels/binary_ops.py":108:37)
#loc7 = loc("examples/kernels/binary_ops.py":108:67)
#loc8 = loc("examples/kernels/binary_ops.py":109:22)
#loc9 = loc("examples/kernels/binary_ops.py":109:50)
#loc10 = loc("examples/kernels/binary_ops.py":109:37)
#loc11 = loc("examples/kernels/binary_ops.py":109:67)
#loc12 = loc("examples/kernels/binary_ops.py":110:29)
#loc13 = loc("examples/kernels/binary_ops.py":110:40)
#loc14 = loc("examples/kernels/binary_ops.py":110:59)
#loc15 = loc("examples/kernels/binary_ops.py":110:52)
#loc16 = loc("examples/kernels/binary_ops.py":110:22)
#loc17 = loc("examples/kernels/binary_ops.py":111:29)
#loc18 = loc("examples/kernels/binary_ops.py":111:40)
#loc19 = loc("examples/kernels/binary_ops.py":111:59)
#loc20 = loc("examples/kernels/binary_ops.py":111:52)
#loc21 = loc("examples/kernels/binary_ops.py":111:22)
#loc22 = loc("examples/kernels/binary_ops.py":112:29)
#loc23 = loc("examples/kernels/binary_ops.py":112:40)
#loc24 = loc("examples/kernels/binary_ops.py":112:59)
#loc25 = loc("examples/kernels/binary_ops.py":112:52)
#loc26 = loc("examples/kernels/binary_ops.py":112:22)
#loc27 = loc("examples/kernels/binary_ops.py":114:20)
#loc28 = loc("examples/kernels/binary_ops.py":114:31)
#loc29 = loc("examples/kernels/binary_ops.py":114:44)
#loc30 = loc("examples/kernels/binary_ops.py":114:55)
#loc31 = loc("examples/kernels/binary_ops.py":114:37)
#loc32 = loc("examples/kernels/binary_ops.py":116:16)
#loc33 = loc("examples/kernels/binary_ops.py":117:16)
#loc34 = loc("examples/kernels/binary_ops.py":118:12)
#loc35 = loc("examples/kernels/binary_ops.py":119:21)
#loc36 = loc("examples/kernels/binary_ops.py":119:4)


// -----// IR Dump Before TritonCombineOps (triton-combine) ('builtin.module' operation) //----- //
#loc = loc("examples/kernels/binary_ops.py":97:0)
module {
  tt.func public @add_2d_kernel(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg1: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg2: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg3: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg4: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg5: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg6: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg7: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0)) attributes {noinline = false} {
    %cst = arith.constant dense<0.000000e+00> : tensor<32x32xf32> loc(#loc1)
    %c32_i32 = arith.constant 32 : i32 loc(#loc1)
    %0 = tt.get_program_id x : i32 loc(#loc2)
    %1 = tt.get_program_id y : i32 loc(#loc3)
    %2 = arith.muli %0, %c32_i32 : i32 loc(#loc4)
    %3 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32> loc(#loc5)
    %4 = tt.splat %2 : i32 -> tensor<32xi32> loc(#loc6)
    %5 = arith.addi %4, %3 : tensor<32xi32> loc(#loc6)
    %6 = tt.splat %arg3 : i32 -> tensor<32xi32> loc(#loc7)
    %7 = arith.remsi %5, %6 : tensor<32xi32> loc(#loc7)
    %8 = arith.muli %1, %c32_i32 : i32 loc(#loc8)
    %9 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32> loc(#loc9)
    %10 = tt.splat %8 : i32 -> tensor<32xi32> loc(#loc10)
    %11 = arith.addi %10, %9 : tensor<32xi32> loc(#loc10)
    %12 = tt.splat %arg4 : i32 -> tensor<32xi32> loc(#loc11)
    %13 = arith.remsi %11, %12 : tensor<32xi32> loc(#loc11)
    %14 = tt.expand_dims %7 {axis = 1 : i32} : tensor<32xi32> -> tensor<32x1xi32> loc(#loc12)
    %15 = tt.splat %arg5 : i32 -> tensor<32x1xi32> loc(#loc13)
    %16 = arith.muli %14, %15 : tensor<32x1xi32> loc(#loc13)
    %17 = tt.expand_dims %13 {axis = 0 : i32} : tensor<32xi32> -> tensor<1x32xi32> loc(#loc14)
    %18 = tt.broadcast %16 : tensor<32x1xi32> -> tensor<32x32xi32> loc(#loc15)
    %19 = tt.broadcast %17 : tensor<1x32xi32> -> tensor<32x32xi32> loc(#loc15)
    %20 = arith.addi %18, %19 : tensor<32x32xi32> loc(#loc15)
    %21 = tt.splat %arg0 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>> loc(#loc16)
    %22 = tt.addptr %21, %20 : tensor<32x32x!tt.ptr<f32>>, tensor<32x32xi32> loc(#loc16)
    %23 = tt.expand_dims %7 {axis = 1 : i32} : tensor<32xi32> -> tensor<32x1xi32> loc(#loc17)
    %24 = tt.splat %arg6 : i32 -> tensor<32x1xi32> loc(#loc18)
    %25 = arith.muli %23, %24 : tensor<32x1xi32> loc(#loc18)
    %26 = tt.expand_dims %13 {axis = 0 : i32} : tensor<32xi32> -> tensor<1x32xi32> loc(#loc19)
    %27 = tt.broadcast %25 : tensor<32x1xi32> -> tensor<32x32xi32> loc(#loc20)
    %28 = tt.broadcast %26 : tensor<1x32xi32> -> tensor<32x32xi32> loc(#loc20)
    %29 = arith.addi %27, %28 : tensor<32x32xi32> loc(#loc20)
    %30 = tt.splat %arg1 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>> loc(#loc21)
    %31 = tt.addptr %30, %29 : tensor<32x32x!tt.ptr<f32>>, tensor<32x32xi32> loc(#loc21)
    %32 = tt.expand_dims %7 {axis = 1 : i32} : tensor<32xi32> -> tensor<32x1xi32> loc(#loc22)
    %33 = tt.splat %arg7 : i32 -> tensor<32x1xi32> loc(#loc23)
    %34 = arith.muli %32, %33 : tensor<32x1xi32> loc(#loc23)
    %35 = tt.expand_dims %13 {axis = 0 : i32} : tensor<32xi32> -> tensor<1x32xi32> loc(#loc24)
    %36 = tt.broadcast %34 : tensor<32x1xi32> -> tensor<32x32xi32> loc(#loc25)
    %37 = tt.broadcast %35 : tensor<1x32xi32> -> tensor<32x32xi32> loc(#loc25)
    %38 = arith.addi %36, %37 : tensor<32x32xi32> loc(#loc25)
    %39 = tt.splat %arg2 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>> loc(#loc26)
    %40 = tt.addptr %39, %38 : tensor<32x32x!tt.ptr<f32>>, tensor<32x32xi32> loc(#loc26)
    %41 = tt.expand_dims %7 {axis = 1 : i32} : tensor<32xi32> -> tensor<32x1xi32> loc(#loc27)
    %42 = tt.splat %arg3 : i32 -> tensor<32x1xi32> loc(#loc28)
    %43 = arith.cmpi slt, %41, %42 : tensor<32x1xi32> loc(#loc28)
    %44 = tt.expand_dims %13 {axis = 0 : i32} : tensor<32xi32> -> tensor<1x32xi32> loc(#loc29)
    %45 = tt.splat %arg4 : i32 -> tensor<1x32xi32> loc(#loc30)
    %46 = arith.cmpi slt, %44, %45 : tensor<1x32xi32> loc(#loc30)
    %47 = tt.broadcast %43 : tensor<32x1xi1> -> tensor<32x32xi1> loc(#loc31)
    %48 = tt.broadcast %46 : tensor<1x32xi1> -> tensor<32x32xi1> loc(#loc31)
    %49 = arith.andi %47, %48 : tensor<32x32xi1> loc(#loc31)
    %50 = tt.load %22, %49, %cst : tensor<32x32x!tt.ptr<f32>> loc(#loc32)
    %51 = tt.load %31, %49, %cst : tensor<32x32x!tt.ptr<f32>> loc(#loc33)
    %52 = arith.addf %50, %51 : tensor<32x32xf32> loc(#loc34)
    tt.store %40, %52, %49 : tensor<32x32x!tt.ptr<f32>> loc(#loc35)
    tt.return loc(#loc36)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("examples/kernels/binary_ops.py":106:26)
#loc3 = loc("examples/kernels/binary_ops.py":107:26)
#loc4 = loc("examples/kernels/binary_ops.py":108:22)
#loc5 = loc("examples/kernels/binary_ops.py":108:50)
#loc6 = loc("examples/kernels/binary_ops.py":108:37)
#loc7 = loc("examples/kernels/binary_ops.py":108:67)
#loc8 = loc("examples/kernels/binary_ops.py":109:22)
#loc9 = loc("examples/kernels/binary_ops.py":109:50)
#loc10 = loc("examples/kernels/binary_ops.py":109:37)
#loc11 = loc("examples/kernels/binary_ops.py":109:67)
#loc12 = loc("examples/kernels/binary_ops.py":110:29)
#loc13 = loc("examples/kernels/binary_ops.py":110:40)
#loc14 = loc("examples/kernels/binary_ops.py":110:59)
#loc15 = loc("examples/kernels/binary_ops.py":110:52)
#loc16 = loc("examples/kernels/binary_ops.py":110:22)
#loc17 = loc("examples/kernels/binary_ops.py":111:29)
#loc18 = loc("examples/kernels/binary_ops.py":111:40)
#loc19 = loc("examples/kernels/binary_ops.py":111:59)
#loc20 = loc("examples/kernels/binary_ops.py":111:52)
#loc21 = loc("examples/kernels/binary_ops.py":111:22)
#loc22 = loc("examples/kernels/binary_ops.py":112:29)
#loc23 = loc("examples/kernels/binary_ops.py":112:40)
#loc24 = loc("examples/kernels/binary_ops.py":112:59)
#loc25 = loc("examples/kernels/binary_ops.py":112:52)
#loc26 = loc("examples/kernels/binary_ops.py":112:22)
#loc27 = loc("examples/kernels/binary_ops.py":114:20)
#loc28 = loc("examples/kernels/binary_ops.py":114:31)
#loc29 = loc("examples/kernels/binary_ops.py":114:44)
#loc30 = loc("examples/kernels/binary_ops.py":114:55)
#loc31 = loc("examples/kernels/binary_ops.py":114:37)
#loc32 = loc("examples/kernels/binary_ops.py":116:16)
#loc33 = loc("examples/kernels/binary_ops.py":117:16)
#loc34 = loc("examples/kernels/binary_ops.py":118:12)
#loc35 = loc("examples/kernels/binary_ops.py":119:21)
#loc36 = loc("examples/kernels/binary_ops.py":119:4)


// -----// IR Dump Before TritonReorderBroadcast (triton-reorder-broadcast) ('builtin.module' operation) //----- //
#loc = loc("examples/kernels/binary_ops.py":97:0)
module {
  tt.func public @add_2d_kernel(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg1: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg2: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg3: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg4: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg5: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg6: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg7: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0)) attributes {noinline = false} {
    %cst = arith.constant dense<0.000000e+00> : tensor<32x32xf32> loc(#loc1)
    %c32_i32 = arith.constant 32 : i32 loc(#loc1)
    %0 = tt.get_program_id x : i32 loc(#loc2)
    %1 = tt.get_program_id y : i32 loc(#loc3)
    %2 = arith.muli %0, %c32_i32 : i32 loc(#loc4)
    %3 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32> loc(#loc5)
    %4 = tt.splat %2 : i32 -> tensor<32xi32> loc(#loc6)
    %5 = arith.addi %4, %3 : tensor<32xi32> loc(#loc6)
    %6 = tt.splat %arg3 : i32 -> tensor<32xi32> loc(#loc7)
    %7 = arith.remsi %5, %6 : tensor<32xi32> loc(#loc7)
    %8 = arith.muli %1, %c32_i32 : i32 loc(#loc8)
    %9 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32> loc(#loc9)
    %10 = tt.splat %8 : i32 -> tensor<32xi32> loc(#loc10)
    %11 = arith.addi %10, %9 : tensor<32xi32> loc(#loc10)
    %12 = tt.splat %arg4 : i32 -> tensor<32xi32> loc(#loc11)
    %13 = arith.remsi %11, %12 : tensor<32xi32> loc(#loc11)
    %14 = tt.expand_dims %7 {axis = 1 : i32} : tensor<32xi32> -> tensor<32x1xi32> loc(#loc12)
    %15 = tt.splat %arg5 : i32 -> tensor<32x1xi32> loc(#loc13)
    %16 = arith.muli %14, %15 : tensor<32x1xi32> loc(#loc13)
    %17 = tt.expand_dims %13 {axis = 0 : i32} : tensor<32xi32> -> tensor<1x32xi32> loc(#loc14)
    %18 = tt.broadcast %16 : tensor<32x1xi32> -> tensor<32x32xi32> loc(#loc15)
    %19 = tt.broadcast %17 : tensor<1x32xi32> -> tensor<32x32xi32> loc(#loc15)
    %20 = arith.addi %18, %19 : tensor<32x32xi32> loc(#loc15)
    %21 = tt.splat %arg0 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>> loc(#loc16)
    %22 = tt.addptr %21, %20 : tensor<32x32x!tt.ptr<f32>>, tensor<32x32xi32> loc(#loc16)
    %23 = tt.expand_dims %7 {axis = 1 : i32} : tensor<32xi32> -> tensor<32x1xi32> loc(#loc17)
    %24 = tt.splat %arg6 : i32 -> tensor<32x1xi32> loc(#loc18)
    %25 = arith.muli %23, %24 : tensor<32x1xi32> loc(#loc18)
    %26 = tt.expand_dims %13 {axis = 0 : i32} : tensor<32xi32> -> tensor<1x32xi32> loc(#loc19)
    %27 = tt.broadcast %25 : tensor<32x1xi32> -> tensor<32x32xi32> loc(#loc20)
    %28 = tt.broadcast %26 : tensor<1x32xi32> -> tensor<32x32xi32> loc(#loc20)
    %29 = arith.addi %27, %28 : tensor<32x32xi32> loc(#loc20)
    %30 = tt.splat %arg1 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>> loc(#loc21)
    %31 = tt.addptr %30, %29 : tensor<32x32x!tt.ptr<f32>>, tensor<32x32xi32> loc(#loc21)
    %32 = tt.expand_dims %7 {axis = 1 : i32} : tensor<32xi32> -> tensor<32x1xi32> loc(#loc22)
    %33 = tt.splat %arg7 : i32 -> tensor<32x1xi32> loc(#loc23)
    %34 = arith.muli %32, %33 : tensor<32x1xi32> loc(#loc23)
    %35 = tt.expand_dims %13 {axis = 0 : i32} : tensor<32xi32> -> tensor<1x32xi32> loc(#loc24)
    %36 = tt.broadcast %34 : tensor<32x1xi32> -> tensor<32x32xi32> loc(#loc25)
    %37 = tt.broadcast %35 : tensor<1x32xi32> -> tensor<32x32xi32> loc(#loc25)
    %38 = arith.addi %36, %37 : tensor<32x32xi32> loc(#loc25)
    %39 = tt.splat %arg2 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>> loc(#loc26)
    %40 = tt.addptr %39, %38 : tensor<32x32x!tt.ptr<f32>>, tensor<32x32xi32> loc(#loc26)
    %41 = tt.expand_dims %7 {axis = 1 : i32} : tensor<32xi32> -> tensor<32x1xi32> loc(#loc27)
    %42 = tt.splat %arg3 : i32 -> tensor<32x1xi32> loc(#loc28)
    %43 = arith.cmpi slt, %41, %42 : tensor<32x1xi32> loc(#loc28)
    %44 = tt.expand_dims %13 {axis = 0 : i32} : tensor<32xi32> -> tensor<1x32xi32> loc(#loc29)
    %45 = tt.splat %arg4 : i32 -> tensor<1x32xi32> loc(#loc30)
    %46 = arith.cmpi slt, %44, %45 : tensor<1x32xi32> loc(#loc30)
    %47 = tt.broadcast %43 : tensor<32x1xi1> -> tensor<32x32xi1> loc(#loc31)
    %48 = tt.broadcast %46 : tensor<1x32xi1> -> tensor<32x32xi1> loc(#loc31)
    %49 = arith.andi %47, %48 : tensor<32x32xi1> loc(#loc31)
    %50 = tt.load %22, %49, %cst : tensor<32x32x!tt.ptr<f32>> loc(#loc32)
    %51 = tt.load %31, %49, %cst : tensor<32x32x!tt.ptr<f32>> loc(#loc33)
    %52 = arith.addf %50, %51 : tensor<32x32xf32> loc(#loc34)
    tt.store %40, %52, %49 : tensor<32x32x!tt.ptr<f32>> loc(#loc35)
    tt.return loc(#loc36)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("examples/kernels/binary_ops.py":106:26)
#loc3 = loc("examples/kernels/binary_ops.py":107:26)
#loc4 = loc("examples/kernels/binary_ops.py":108:22)
#loc5 = loc("examples/kernels/binary_ops.py":108:50)
#loc6 = loc("examples/kernels/binary_ops.py":108:37)
#loc7 = loc("examples/kernels/binary_ops.py":108:67)
#loc8 = loc("examples/kernels/binary_ops.py":109:22)
#loc9 = loc("examples/kernels/binary_ops.py":109:50)
#loc10 = loc("examples/kernels/binary_ops.py":109:37)
#loc11 = loc("examples/kernels/binary_ops.py":109:67)
#loc12 = loc("examples/kernels/binary_ops.py":110:29)
#loc13 = loc("examples/kernels/binary_ops.py":110:40)
#loc14 = loc("examples/kernels/binary_ops.py":110:59)
#loc15 = loc("examples/kernels/binary_ops.py":110:52)
#loc16 = loc("examples/kernels/binary_ops.py":110:22)
#loc17 = loc("examples/kernels/binary_ops.py":111:29)
#loc18 = loc("examples/kernels/binary_ops.py":111:40)
#loc19 = loc("examples/kernels/binary_ops.py":111:59)
#loc20 = loc("examples/kernels/binary_ops.py":111:52)
#loc21 = loc("examples/kernels/binary_ops.py":111:22)
#loc22 = loc("examples/kernels/binary_ops.py":112:29)
#loc23 = loc("examples/kernels/binary_ops.py":112:40)
#loc24 = loc("examples/kernels/binary_ops.py":112:59)
#loc25 = loc("examples/kernels/binary_ops.py":112:52)
#loc26 = loc("examples/kernels/binary_ops.py":112:22)
#loc27 = loc("examples/kernels/binary_ops.py":114:20)
#loc28 = loc("examples/kernels/binary_ops.py":114:31)
#loc29 = loc("examples/kernels/binary_ops.py":114:44)
#loc30 = loc("examples/kernels/binary_ops.py":114:55)
#loc31 = loc("examples/kernels/binary_ops.py":114:37)
#loc32 = loc("examples/kernels/binary_ops.py":116:16)
#loc33 = loc("examples/kernels/binary_ops.py":117:16)
#loc34 = loc("examples/kernels/binary_ops.py":118:12)
#loc35 = loc("examples/kernels/binary_ops.py":119:21)
#loc36 = loc("examples/kernels/binary_ops.py":119:4)


// -----// IR Dump Before CSE (cse) ('builtin.module' operation) //----- //
#loc = loc("examples/kernels/binary_ops.py":97:0)
module {
  tt.func public @add_2d_kernel(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg1: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg2: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg3: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg4: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg5: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg6: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg7: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0)) attributes {noinline = false} {
    %cst = arith.constant dense<0.000000e+00> : tensor<32x32xf32> loc(#loc1)
    %c32_i32 = arith.constant 32 : i32 loc(#loc1)
    %0 = tt.get_program_id x : i32 loc(#loc2)
    %1 = tt.get_program_id y : i32 loc(#loc3)
    %2 = arith.muli %0, %c32_i32 : i32 loc(#loc4)
    %3 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32> loc(#loc5)
    %4 = tt.splat %2 : i32 -> tensor<32xi32> loc(#loc6)
    %5 = arith.addi %4, %3 : tensor<32xi32> loc(#loc6)
    %6 = tt.splat %arg3 : i32 -> tensor<32xi32> loc(#loc7)
    %7 = arith.remsi %5, %6 : tensor<32xi32> loc(#loc7)
    %8 = arith.muli %1, %c32_i32 : i32 loc(#loc8)
    %9 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32> loc(#loc9)
    %10 = tt.splat %8 : i32 -> tensor<32xi32> loc(#loc10)
    %11 = arith.addi %10, %9 : tensor<32xi32> loc(#loc10)
    %12 = tt.splat %arg4 : i32 -> tensor<32xi32> loc(#loc11)
    %13 = arith.remsi %11, %12 : tensor<32xi32> loc(#loc11)
    %14 = tt.expand_dims %7 {axis = 1 : i32} : tensor<32xi32> -> tensor<32x1xi32> loc(#loc12)
    %15 = tt.splat %arg5 : i32 -> tensor<32x1xi32> loc(#loc13)
    %16 = arith.muli %14, %15 : tensor<32x1xi32> loc(#loc13)
    %17 = tt.expand_dims %13 {axis = 0 : i32} : tensor<32xi32> -> tensor<1x32xi32> loc(#loc14)
    %18 = tt.broadcast %16 : tensor<32x1xi32> -> tensor<32x32xi32> loc(#loc15)
    %19 = tt.broadcast %17 : tensor<1x32xi32> -> tensor<32x32xi32> loc(#loc15)
    %20 = arith.addi %18, %19 : tensor<32x32xi32> loc(#loc15)
    %21 = tt.splat %arg0 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>> loc(#loc16)
    %22 = tt.addptr %21, %20 : tensor<32x32x!tt.ptr<f32>>, tensor<32x32xi32> loc(#loc16)
    %23 = tt.expand_dims %7 {axis = 1 : i32} : tensor<32xi32> -> tensor<32x1xi32> loc(#loc17)
    %24 = tt.splat %arg6 : i32 -> tensor<32x1xi32> loc(#loc18)
    %25 = arith.muli %23, %24 : tensor<32x1xi32> loc(#loc18)
    %26 = tt.expand_dims %13 {axis = 0 : i32} : tensor<32xi32> -> tensor<1x32xi32> loc(#loc19)
    %27 = tt.broadcast %25 : tensor<32x1xi32> -> tensor<32x32xi32> loc(#loc20)
    %28 = tt.broadcast %26 : tensor<1x32xi32> -> tensor<32x32xi32> loc(#loc20)
    %29 = arith.addi %27, %28 : tensor<32x32xi32> loc(#loc20)
    %30 = tt.splat %arg1 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>> loc(#loc21)
    %31 = tt.addptr %30, %29 : tensor<32x32x!tt.ptr<f32>>, tensor<32x32xi32> loc(#loc21)
    %32 = tt.expand_dims %7 {axis = 1 : i32} : tensor<32xi32> -> tensor<32x1xi32> loc(#loc22)
    %33 = tt.splat %arg7 : i32 -> tensor<32x1xi32> loc(#loc23)
    %34 = arith.muli %32, %33 : tensor<32x1xi32> loc(#loc23)
    %35 = tt.expand_dims %13 {axis = 0 : i32} : tensor<32xi32> -> tensor<1x32xi32> loc(#loc24)
    %36 = tt.broadcast %34 : tensor<32x1xi32> -> tensor<32x32xi32> loc(#loc25)
    %37 = tt.broadcast %35 : tensor<1x32xi32> -> tensor<32x32xi32> loc(#loc25)
    %38 = arith.addi %36, %37 : tensor<32x32xi32> loc(#loc25)
    %39 = tt.splat %arg2 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>> loc(#loc26)
    %40 = tt.addptr %39, %38 : tensor<32x32x!tt.ptr<f32>>, tensor<32x32xi32> loc(#loc26)
    %41 = tt.expand_dims %7 {axis = 1 : i32} : tensor<32xi32> -> tensor<32x1xi32> loc(#loc27)
    %42 = tt.splat %arg3 : i32 -> tensor<32x1xi32> loc(#loc28)
    %43 = arith.cmpi slt, %41, %42 : tensor<32x1xi32> loc(#loc28)
    %44 = tt.expand_dims %13 {axis = 0 : i32} : tensor<32xi32> -> tensor<1x32xi32> loc(#loc29)
    %45 = tt.splat %arg4 : i32 -> tensor<1x32xi32> loc(#loc30)
    %46 = arith.cmpi slt, %44, %45 : tensor<1x32xi32> loc(#loc30)
    %47 = tt.broadcast %43 : tensor<32x1xi1> -> tensor<32x32xi1> loc(#loc31)
    %48 = tt.broadcast %46 : tensor<1x32xi1> -> tensor<32x32xi1> loc(#loc31)
    %49 = arith.andi %47, %48 : tensor<32x32xi1> loc(#loc31)
    %50 = tt.load %22, %49, %cst : tensor<32x32x!tt.ptr<f32>> loc(#loc32)
    %51 = tt.load %31, %49, %cst : tensor<32x32x!tt.ptr<f32>> loc(#loc33)
    %52 = arith.addf %50, %51 : tensor<32x32xf32> loc(#loc34)
    tt.store %40, %52, %49 : tensor<32x32x!tt.ptr<f32>> loc(#loc35)
    tt.return loc(#loc36)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("examples/kernels/binary_ops.py":106:26)
#loc3 = loc("examples/kernels/binary_ops.py":107:26)
#loc4 = loc("examples/kernels/binary_ops.py":108:22)
#loc5 = loc("examples/kernels/binary_ops.py":108:50)
#loc6 = loc("examples/kernels/binary_ops.py":108:37)
#loc7 = loc("examples/kernels/binary_ops.py":108:67)
#loc8 = loc("examples/kernels/binary_ops.py":109:22)
#loc9 = loc("examples/kernels/binary_ops.py":109:50)
#loc10 = loc("examples/kernels/binary_ops.py":109:37)
#loc11 = loc("examples/kernels/binary_ops.py":109:67)
#loc12 = loc("examples/kernels/binary_ops.py":110:29)
#loc13 = loc("examples/kernels/binary_ops.py":110:40)
#loc14 = loc("examples/kernels/binary_ops.py":110:59)
#loc15 = loc("examples/kernels/binary_ops.py":110:52)
#loc16 = loc("examples/kernels/binary_ops.py":110:22)
#loc17 = loc("examples/kernels/binary_ops.py":111:29)
#loc18 = loc("examples/kernels/binary_ops.py":111:40)
#loc19 = loc("examples/kernels/binary_ops.py":111:59)
#loc20 = loc("examples/kernels/binary_ops.py":111:52)
#loc21 = loc("examples/kernels/binary_ops.py":111:22)
#loc22 = loc("examples/kernels/binary_ops.py":112:29)
#loc23 = loc("examples/kernels/binary_ops.py":112:40)
#loc24 = loc("examples/kernels/binary_ops.py":112:59)
#loc25 = loc("examples/kernels/binary_ops.py":112:52)
#loc26 = loc("examples/kernels/binary_ops.py":112:22)
#loc27 = loc("examples/kernels/binary_ops.py":114:20)
#loc28 = loc("examples/kernels/binary_ops.py":114:31)
#loc29 = loc("examples/kernels/binary_ops.py":114:44)
#loc30 = loc("examples/kernels/binary_ops.py":114:55)
#loc31 = loc("examples/kernels/binary_ops.py":114:37)
#loc32 = loc("examples/kernels/binary_ops.py":116:16)
#loc33 = loc("examples/kernels/binary_ops.py":117:16)
#loc34 = loc("examples/kernels/binary_ops.py":118:12)
#loc35 = loc("examples/kernels/binary_ops.py":119:21)
#loc36 = loc("examples/kernels/binary_ops.py":119:4)


// -----// IR Dump Before SymbolDCE (symbol-dce) ('builtin.module' operation) //----- //
#loc = loc("examples/kernels/binary_ops.py":97:0)
module {
  tt.func public @add_2d_kernel(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg1: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg2: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg3: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg4: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg5: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg6: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg7: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0)) attributes {noinline = false} {
    %cst = arith.constant dense<0.000000e+00> : tensor<32x32xf32> loc(#loc1)
    %c32_i32 = arith.constant 32 : i32 loc(#loc1)
    %0 = tt.get_program_id x : i32 loc(#loc2)
    %1 = tt.get_program_id y : i32 loc(#loc3)
    %2 = arith.muli %0, %c32_i32 : i32 loc(#loc4)
    %3 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32> loc(#loc5)
    %4 = tt.splat %2 : i32 -> tensor<32xi32> loc(#loc6)
    %5 = arith.addi %4, %3 : tensor<32xi32> loc(#loc6)
    %6 = tt.splat %arg3 : i32 -> tensor<32xi32> loc(#loc7)
    %7 = arith.remsi %5, %6 : tensor<32xi32> loc(#loc7)
    %8 = arith.muli %1, %c32_i32 : i32 loc(#loc8)
    %9 = tt.splat %8 : i32 -> tensor<32xi32> loc(#loc9)
    %10 = arith.addi %9, %3 : tensor<32xi32> loc(#loc9)
    %11 = tt.splat %arg4 : i32 -> tensor<32xi32> loc(#loc10)
    %12 = arith.remsi %10, %11 : tensor<32xi32> loc(#loc10)
    %13 = tt.expand_dims %7 {axis = 1 : i32} : tensor<32xi32> -> tensor<32x1xi32> loc(#loc11)
    %14 = tt.splat %arg5 : i32 -> tensor<32x1xi32> loc(#loc12)
    %15 = arith.muli %13, %14 : tensor<32x1xi32> loc(#loc12)
    %16 = tt.expand_dims %12 {axis = 0 : i32} : tensor<32xi32> -> tensor<1x32xi32> loc(#loc13)
    %17 = tt.broadcast %15 : tensor<32x1xi32> -> tensor<32x32xi32> loc(#loc14)
    %18 = tt.broadcast %16 : tensor<1x32xi32> -> tensor<32x32xi32> loc(#loc14)
    %19 = arith.addi %17, %18 : tensor<32x32xi32> loc(#loc14)
    %20 = tt.splat %arg0 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>> loc(#loc15)
    %21 = tt.addptr %20, %19 : tensor<32x32x!tt.ptr<f32>>, tensor<32x32xi32> loc(#loc15)
    %22 = tt.splat %arg6 : i32 -> tensor<32x1xi32> loc(#loc16)
    %23 = arith.muli %13, %22 : tensor<32x1xi32> loc(#loc16)
    %24 = tt.broadcast %23 : tensor<32x1xi32> -> tensor<32x32xi32> loc(#loc17)
    %25 = arith.addi %24, %18 : tensor<32x32xi32> loc(#loc17)
    %26 = tt.splat %arg1 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>> loc(#loc18)
    %27 = tt.addptr %26, %25 : tensor<32x32x!tt.ptr<f32>>, tensor<32x32xi32> loc(#loc18)
    %28 = tt.splat %arg7 : i32 -> tensor<32x1xi32> loc(#loc19)
    %29 = arith.muli %13, %28 : tensor<32x1xi32> loc(#loc19)
    %30 = tt.broadcast %29 : tensor<32x1xi32> -> tensor<32x32xi32> loc(#loc20)
    %31 = arith.addi %30, %18 : tensor<32x32xi32> loc(#loc20)
    %32 = tt.splat %arg2 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>> loc(#loc21)
    %33 = tt.addptr %32, %31 : tensor<32x32x!tt.ptr<f32>>, tensor<32x32xi32> loc(#loc21)
    %34 = tt.splat %arg3 : i32 -> tensor<32x1xi32> loc(#loc22)
    %35 = arith.cmpi slt, %13, %34 : tensor<32x1xi32> loc(#loc22)
    %36 = tt.splat %arg4 : i32 -> tensor<1x32xi32> loc(#loc23)
    %37 = arith.cmpi slt, %16, %36 : tensor<1x32xi32> loc(#loc23)
    %38 = tt.broadcast %35 : tensor<32x1xi1> -> tensor<32x32xi1> loc(#loc24)
    %39 = tt.broadcast %37 : tensor<1x32xi1> -> tensor<32x32xi1> loc(#loc24)
    %40 = arith.andi %38, %39 : tensor<32x32xi1> loc(#loc24)
    %41 = tt.load %21, %40, %cst : tensor<32x32x!tt.ptr<f32>> loc(#loc25)
    %42 = tt.load %27, %40, %cst : tensor<32x32x!tt.ptr<f32>> loc(#loc26)
    %43 = arith.addf %41, %42 : tensor<32x32xf32> loc(#loc27)
    tt.store %33, %43, %40 : tensor<32x32x!tt.ptr<f32>> loc(#loc28)
    tt.return loc(#loc29)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("examples/kernels/binary_ops.py":106:26)
#loc3 = loc("examples/kernels/binary_ops.py":107:26)
#loc4 = loc("examples/kernels/binary_ops.py":108:22)
#loc5 = loc("examples/kernels/binary_ops.py":108:50)
#loc6 = loc("examples/kernels/binary_ops.py":108:37)
#loc7 = loc("examples/kernels/binary_ops.py":108:67)
#loc8 = loc("examples/kernels/binary_ops.py":109:22)
#loc9 = loc("examples/kernels/binary_ops.py":109:37)
#loc10 = loc("examples/kernels/binary_ops.py":109:67)
#loc11 = loc("examples/kernels/binary_ops.py":110:29)
#loc12 = loc("examples/kernels/binary_ops.py":110:40)
#loc13 = loc("examples/kernels/binary_ops.py":110:59)
#loc14 = loc("examples/kernels/binary_ops.py":110:52)
#loc15 = loc("examples/kernels/binary_ops.py":110:22)
#loc16 = loc("examples/kernels/binary_ops.py":111:40)
#loc17 = loc("examples/kernels/binary_ops.py":111:52)
#loc18 = loc("examples/kernels/binary_ops.py":111:22)
#loc19 = loc("examples/kernels/binary_ops.py":112:40)
#loc20 = loc("examples/kernels/binary_ops.py":112:52)
#loc21 = loc("examples/kernels/binary_ops.py":112:22)
#loc22 = loc("examples/kernels/binary_ops.py":114:31)
#loc23 = loc("examples/kernels/binary_ops.py":114:55)
#loc24 = loc("examples/kernels/binary_ops.py":114:37)
#loc25 = loc("examples/kernels/binary_ops.py":116:16)
#loc26 = loc("examples/kernels/binary_ops.py":117:16)
#loc27 = loc("examples/kernels/binary_ops.py":118:12)
#loc28 = loc("examples/kernels/binary_ops.py":119:21)
#loc29 = loc("examples/kernels/binary_ops.py":119:4)


// -----// IR Dump Before TritonLoopUnroll (triton-loop-unroll) ('builtin.module' operation) //----- //
#loc = loc("examples/kernels/binary_ops.py":97:0)
module {
  tt.func public @add_2d_kernel(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg1: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg2: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg3: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg4: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg5: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg6: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg7: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0)) attributes {noinline = false} {
    %cst = arith.constant dense<0.000000e+00> : tensor<32x32xf32> loc(#loc1)
    %c32_i32 = arith.constant 32 : i32 loc(#loc1)
    %0 = tt.get_program_id x : i32 loc(#loc2)
    %1 = tt.get_program_id y : i32 loc(#loc3)
    %2 = arith.muli %0, %c32_i32 : i32 loc(#loc4)
    %3 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32> loc(#loc5)
    %4 = tt.splat %2 : i32 -> tensor<32xi32> loc(#loc6)
    %5 = arith.addi %4, %3 : tensor<32xi32> loc(#loc6)
    %6 = tt.splat %arg3 : i32 -> tensor<32xi32> loc(#loc7)
    %7 = arith.remsi %5, %6 : tensor<32xi32> loc(#loc7)
    %8 = arith.muli %1, %c32_i32 : i32 loc(#loc8)
    %9 = tt.splat %8 : i32 -> tensor<32xi32> loc(#loc9)
    %10 = arith.addi %9, %3 : tensor<32xi32> loc(#loc9)
    %11 = tt.splat %arg4 : i32 -> tensor<32xi32> loc(#loc10)
    %12 = arith.remsi %10, %11 : tensor<32xi32> loc(#loc10)
    %13 = tt.expand_dims %7 {axis = 1 : i32} : tensor<32xi32> -> tensor<32x1xi32> loc(#loc11)
    %14 = tt.splat %arg5 : i32 -> tensor<32x1xi32> loc(#loc12)
    %15 = arith.muli %13, %14 : tensor<32x1xi32> loc(#loc12)
    %16 = tt.expand_dims %12 {axis = 0 : i32} : tensor<32xi32> -> tensor<1x32xi32> loc(#loc13)
    %17 = tt.broadcast %15 : tensor<32x1xi32> -> tensor<32x32xi32> loc(#loc14)
    %18 = tt.broadcast %16 : tensor<1x32xi32> -> tensor<32x32xi32> loc(#loc14)
    %19 = arith.addi %17, %18 : tensor<32x32xi32> loc(#loc14)
    %20 = tt.splat %arg0 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>> loc(#loc15)
    %21 = tt.addptr %20, %19 : tensor<32x32x!tt.ptr<f32>>, tensor<32x32xi32> loc(#loc15)
    %22 = tt.splat %arg6 : i32 -> tensor<32x1xi32> loc(#loc16)
    %23 = arith.muli %13, %22 : tensor<32x1xi32> loc(#loc16)
    %24 = tt.broadcast %23 : tensor<32x1xi32> -> tensor<32x32xi32> loc(#loc17)
    %25 = arith.addi %24, %18 : tensor<32x32xi32> loc(#loc17)
    %26 = tt.splat %arg1 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>> loc(#loc18)
    %27 = tt.addptr %26, %25 : tensor<32x32x!tt.ptr<f32>>, tensor<32x32xi32> loc(#loc18)
    %28 = tt.splat %arg7 : i32 -> tensor<32x1xi32> loc(#loc19)
    %29 = arith.muli %13, %28 : tensor<32x1xi32> loc(#loc19)
    %30 = tt.broadcast %29 : tensor<32x1xi32> -> tensor<32x32xi32> loc(#loc20)
    %31 = arith.addi %30, %18 : tensor<32x32xi32> loc(#loc20)
    %32 = tt.splat %arg2 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>> loc(#loc21)
    %33 = tt.addptr %32, %31 : tensor<32x32x!tt.ptr<f32>>, tensor<32x32xi32> loc(#loc21)
    %34 = tt.splat %arg3 : i32 -> tensor<32x1xi32> loc(#loc22)
    %35 = arith.cmpi slt, %13, %34 : tensor<32x1xi32> loc(#loc22)
    %36 = tt.splat %arg4 : i32 -> tensor<1x32xi32> loc(#loc23)
    %37 = arith.cmpi slt, %16, %36 : tensor<1x32xi32> loc(#loc23)
    %38 = tt.broadcast %35 : tensor<32x1xi1> -> tensor<32x32xi1> loc(#loc24)
    %39 = tt.broadcast %37 : tensor<1x32xi1> -> tensor<32x32xi1> loc(#loc24)
    %40 = arith.andi %38, %39 : tensor<32x32xi1> loc(#loc24)
    %41 = tt.load %21, %40, %cst : tensor<32x32x!tt.ptr<f32>> loc(#loc25)
    %42 = tt.load %27, %40, %cst : tensor<32x32x!tt.ptr<f32>> loc(#loc26)
    %43 = arith.addf %41, %42 : tensor<32x32xf32> loc(#loc27)
    tt.store %33, %43, %40 : tensor<32x32x!tt.ptr<f32>> loc(#loc28)
    tt.return loc(#loc29)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("examples/kernels/binary_ops.py":106:26)
#loc3 = loc("examples/kernels/binary_ops.py":107:26)
#loc4 = loc("examples/kernels/binary_ops.py":108:22)
#loc5 = loc("examples/kernels/binary_ops.py":108:50)
#loc6 = loc("examples/kernels/binary_ops.py":108:37)
#loc7 = loc("examples/kernels/binary_ops.py":108:67)
#loc8 = loc("examples/kernels/binary_ops.py":109:22)
#loc9 = loc("examples/kernels/binary_ops.py":109:37)
#loc10 = loc("examples/kernels/binary_ops.py":109:67)
#loc11 = loc("examples/kernels/binary_ops.py":110:29)
#loc12 = loc("examples/kernels/binary_ops.py":110:40)
#loc13 = loc("examples/kernels/binary_ops.py":110:59)
#loc14 = loc("examples/kernels/binary_ops.py":110:52)
#loc15 = loc("examples/kernels/binary_ops.py":110:22)
#loc16 = loc("examples/kernels/binary_ops.py":111:40)
#loc17 = loc("examples/kernels/binary_ops.py":111:52)
#loc18 = loc("examples/kernels/binary_ops.py":111:22)
#loc19 = loc("examples/kernels/binary_ops.py":112:40)
#loc20 = loc("examples/kernels/binary_ops.py":112:52)
#loc21 = loc("examples/kernels/binary_ops.py":112:22)
#loc22 = loc("examples/kernels/binary_ops.py":114:31)
#loc23 = loc("examples/kernels/binary_ops.py":114:55)
#loc24 = loc("examples/kernels/binary_ops.py":114:37)
#loc25 = loc("examples/kernels/binary_ops.py":116:16)
#loc26 = loc("examples/kernels/binary_ops.py":117:16)
#loc27 = loc("examples/kernels/binary_ops.py":118:12)
#loc28 = loc("examples/kernels/binary_ops.py":119:21)
#loc29 = loc("examples/kernels/binary_ops.py":119:4)


// -----// IR Dump Before ConvertTritonToTritonGPU (convert-triton-to-tritongpu) ('builtin.module' operation) //----- //
#loc = loc("examples/kernels/binary_ops.py":97:0)
module {
  tt.func public @add_2d_kernel(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg1: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg2: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg3: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg4: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg5: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg6: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg7: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0)) attributes {noinline = false} {
    %cst = arith.constant dense<0.000000e+00> : tensor<32x32xf32> loc(#loc1)
    %c32_i32 = arith.constant 32 : i32 loc(#loc1)
    %0 = tt.get_program_id x : i32 loc(#loc2)
    %1 = tt.get_program_id y : i32 loc(#loc3)
    %2 = arith.muli %0, %c32_i32 : i32 loc(#loc4)
    %3 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32> loc(#loc5)
    %4 = tt.splat %2 : i32 -> tensor<32xi32> loc(#loc6)
    %5 = arith.addi %4, %3 : tensor<32xi32> loc(#loc6)
    %6 = tt.splat %arg3 : i32 -> tensor<32xi32> loc(#loc7)
    %7 = arith.remsi %5, %6 : tensor<32xi32> loc(#loc7)
    %8 = arith.muli %1, %c32_i32 : i32 loc(#loc8)
    %9 = tt.splat %8 : i32 -> tensor<32xi32> loc(#loc9)
    %10 = arith.addi %9, %3 : tensor<32xi32> loc(#loc9)
    %11 = tt.splat %arg4 : i32 -> tensor<32xi32> loc(#loc10)
    %12 = arith.remsi %10, %11 : tensor<32xi32> loc(#loc10)
    %13 = tt.expand_dims %7 {axis = 1 : i32} : tensor<32xi32> -> tensor<32x1xi32> loc(#loc11)
    %14 = tt.splat %arg5 : i32 -> tensor<32x1xi32> loc(#loc12)
    %15 = arith.muli %13, %14 : tensor<32x1xi32> loc(#loc12)
    %16 = tt.expand_dims %12 {axis = 0 : i32} : tensor<32xi32> -> tensor<1x32xi32> loc(#loc13)
    %17 = tt.broadcast %15 : tensor<32x1xi32> -> tensor<32x32xi32> loc(#loc14)
    %18 = tt.broadcast %16 : tensor<1x32xi32> -> tensor<32x32xi32> loc(#loc14)
    %19 = arith.addi %17, %18 : tensor<32x32xi32> loc(#loc14)
    %20 = tt.splat %arg0 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>> loc(#loc15)
    %21 = tt.addptr %20, %19 : tensor<32x32x!tt.ptr<f32>>, tensor<32x32xi32> loc(#loc15)
    %22 = tt.splat %arg6 : i32 -> tensor<32x1xi32> loc(#loc16)
    %23 = arith.muli %13, %22 : tensor<32x1xi32> loc(#loc16)
    %24 = tt.broadcast %23 : tensor<32x1xi32> -> tensor<32x32xi32> loc(#loc17)
    %25 = arith.addi %24, %18 : tensor<32x32xi32> loc(#loc17)
    %26 = tt.splat %arg1 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>> loc(#loc18)
    %27 = tt.addptr %26, %25 : tensor<32x32x!tt.ptr<f32>>, tensor<32x32xi32> loc(#loc18)
    %28 = tt.splat %arg7 : i32 -> tensor<32x1xi32> loc(#loc19)
    %29 = arith.muli %13, %28 : tensor<32x1xi32> loc(#loc19)
    %30 = tt.broadcast %29 : tensor<32x1xi32> -> tensor<32x32xi32> loc(#loc20)
    %31 = arith.addi %30, %18 : tensor<32x32xi32> loc(#loc20)
    %32 = tt.splat %arg2 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>> loc(#loc21)
    %33 = tt.addptr %32, %31 : tensor<32x32x!tt.ptr<f32>>, tensor<32x32xi32> loc(#loc21)
    %34 = tt.splat %arg3 : i32 -> tensor<32x1xi32> loc(#loc22)
    %35 = arith.cmpi slt, %13, %34 : tensor<32x1xi32> loc(#loc22)
    %36 = tt.splat %arg4 : i32 -> tensor<1x32xi32> loc(#loc23)
    %37 = arith.cmpi slt, %16, %36 : tensor<1x32xi32> loc(#loc23)
    %38 = tt.broadcast %35 : tensor<32x1xi1> -> tensor<32x32xi1> loc(#loc24)
    %39 = tt.broadcast %37 : tensor<1x32xi1> -> tensor<32x32xi1> loc(#loc24)
    %40 = arith.andi %38, %39 : tensor<32x32xi1> loc(#loc24)
    %41 = tt.load %21, %40, %cst : tensor<32x32x!tt.ptr<f32>> loc(#loc25)
    %42 = tt.load %27, %40, %cst : tensor<32x32x!tt.ptr<f32>> loc(#loc26)
    %43 = arith.addf %41, %42 : tensor<32x32xf32> loc(#loc27)
    tt.store %33, %43, %40 : tensor<32x32x!tt.ptr<f32>> loc(#loc28)
    tt.return loc(#loc29)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("examples/kernels/binary_ops.py":106:26)
#loc3 = loc("examples/kernels/binary_ops.py":107:26)
#loc4 = loc("examples/kernels/binary_ops.py":108:22)
#loc5 = loc("examples/kernels/binary_ops.py":108:50)
#loc6 = loc("examples/kernels/binary_ops.py":108:37)
#loc7 = loc("examples/kernels/binary_ops.py":108:67)
#loc8 = loc("examples/kernels/binary_ops.py":109:22)
#loc9 = loc("examples/kernels/binary_ops.py":109:37)
#loc10 = loc("examples/kernels/binary_ops.py":109:67)
#loc11 = loc("examples/kernels/binary_ops.py":110:29)
#loc12 = loc("examples/kernels/binary_ops.py":110:40)
#loc13 = loc("examples/kernels/binary_ops.py":110:59)
#loc14 = loc("examples/kernels/binary_ops.py":110:52)
#loc15 = loc("examples/kernels/binary_ops.py":110:22)
#loc16 = loc("examples/kernels/binary_ops.py":111:40)
#loc17 = loc("examples/kernels/binary_ops.py":111:52)
#loc18 = loc("examples/kernels/binary_ops.py":111:22)
#loc19 = loc("examples/kernels/binary_ops.py":112:40)
#loc20 = loc("examples/kernels/binary_ops.py":112:52)
#loc21 = loc("examples/kernels/binary_ops.py":112:22)
#loc22 = loc("examples/kernels/binary_ops.py":114:31)
#loc23 = loc("examples/kernels/binary_ops.py":114:55)
#loc24 = loc("examples/kernels/binary_ops.py":114:37)
#loc25 = loc("examples/kernels/binary_ops.py":116:16)
#loc26 = loc("examples/kernels/binary_ops.py":117:16)
#loc27 = loc("examples/kernels/binary_ops.py":118:12)
#loc28 = loc("examples/kernels/binary_ops.py":119:21)
#loc29 = loc("examples/kernels/binary_ops.py":119:4)


// -----// IR Dump Before TritonGPUCoalesce (tritongpu-coalesce) ('builtin.module' operation) //----- //
#blocked = #ttg.blocked<{sizePerThread = [1, 1], threadsPerWarp = [1, 32], warpsPerCTA = [4, 1], order = [1, 0]}>
#blocked1 = #ttg.blocked<{sizePerThread = [1], threadsPerWarp = [32], warpsPerCTA = [4], order = [0]}>
#blocked2 = #ttg.blocked<{sizePerThread = [1, 1], threadsPerWarp = [32, 1], warpsPerCTA = [4, 1], order = [0, 1]}>
#blocked3 = #ttg.blocked<{sizePerThread = [1, 1], threadsPerWarp = [32, 1], warpsPerCTA = [4, 1], order = [1, 0]}>
#blocked4 = #ttg.blocked<{sizePerThread = [1, 1], threadsPerWarp = [1, 32], warpsPerCTA = [1, 4], order = [0, 1]}>
#loc = loc("examples/kernels/binary_ops.py":97:0)
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.target = "cuda:89", "ttg.threads-per-warp" = 32 : i32} {
  tt.func public @add_2d_kernel(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg1: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg2: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg3: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg4: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg5: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg6: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg7: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0)) attributes {noinline = false} {
    %cst = arith.constant dense<0.000000e+00> : tensor<32x32xf32, #blocked> loc(#loc1)
    %c32_i32 = arith.constant 32 : i32 loc(#loc1)
    %0 = tt.get_program_id x : i32 loc(#loc2)
    %1 = tt.get_program_id y : i32 loc(#loc3)
    %2 = arith.muli %0, %c32_i32 : i32 loc(#loc4)
    %3 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #blocked1> loc(#loc5)
    %4 = tt.splat %2 : i32 -> tensor<32xi32, #blocked1> loc(#loc6)
    %5 = arith.addi %4, %3 : tensor<32xi32, #blocked1> loc(#loc6)
    %6 = tt.splat %arg3 : i32 -> tensor<32xi32, #blocked1> loc(#loc7)
    %7 = arith.remsi %5, %6 : tensor<32xi32, #blocked1> loc(#loc7)
    %8 = arith.muli %1, %c32_i32 : i32 loc(#loc8)
    %9 = tt.splat %8 : i32 -> tensor<32xi32, #blocked1> loc(#loc9)
    %10 = arith.addi %9, %3 : tensor<32xi32, #blocked1> loc(#loc9)
    %11 = tt.splat %arg4 : i32 -> tensor<32xi32, #blocked1> loc(#loc10)
    %12 = arith.remsi %10, %11 : tensor<32xi32, #blocked1> loc(#loc10)
    %13 = ttg.convert_layout %7 : tensor<32xi32, #blocked1> -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked2}>> loc(#loc11)
    %14 = tt.expand_dims %13 {axis = 1 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked2}>> -> tensor<32x1xi32, #blocked2> loc(#loc11)
    %15 = ttg.convert_layout %14 : tensor<32x1xi32, #blocked2> -> tensor<32x1xi32, #blocked3> loc(#loc12)
    %16 = tt.splat %arg5 : i32 -> tensor<32x1xi32, #blocked3> loc(#loc12)
    %17 = arith.muli %15, %16 : tensor<32x1xi32, #blocked3> loc(#loc12)
    %18 = ttg.convert_layout %12 : tensor<32xi32, #blocked1> -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked4}>> loc(#loc13)
    %19 = tt.expand_dims %18 {axis = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked4}>> -> tensor<1x32xi32, #blocked4> loc(#loc13)
    %20 = ttg.convert_layout %19 : tensor<1x32xi32, #blocked4> -> tensor<1x32xi32, #blocked> loc(#loc14)
    %21 = tt.broadcast %17 : tensor<32x1xi32, #blocked3> -> tensor<32x32xi32, #blocked3> loc(#loc14)
    %22 = ttg.convert_layout %21 : tensor<32x32xi32, #blocked3> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %23 = tt.broadcast %20 : tensor<1x32xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %24 = arith.addi %22, %23 : tensor<32x32xi32, #blocked> loc(#loc14)
    %25 = tt.splat %arg0 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc15)
    %26 = tt.addptr %25, %24 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc15)
    %27 = tt.splat %arg6 : i32 -> tensor<32x1xi32, #blocked3> loc(#loc16)
    %28 = arith.muli %15, %27 : tensor<32x1xi32, #blocked3> loc(#loc16)
    %29 = tt.broadcast %28 : tensor<32x1xi32, #blocked3> -> tensor<32x32xi32, #blocked3> loc(#loc17)
    %30 = ttg.convert_layout %29 : tensor<32x32xi32, #blocked3> -> tensor<32x32xi32, #blocked> loc(#loc17)
    %31 = arith.addi %30, %23 : tensor<32x32xi32, #blocked> loc(#loc17)
    %32 = tt.splat %arg1 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc18)
    %33 = tt.addptr %32, %31 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc18)
    %34 = tt.splat %arg7 : i32 -> tensor<32x1xi32, #blocked3> loc(#loc19)
    %35 = arith.muli %15, %34 : tensor<32x1xi32, #blocked3> loc(#loc19)
    %36 = tt.broadcast %35 : tensor<32x1xi32, #blocked3> -> tensor<32x32xi32, #blocked3> loc(#loc20)
    %37 = ttg.convert_layout %36 : tensor<32x32xi32, #blocked3> -> tensor<32x32xi32, #blocked> loc(#loc20)
    %38 = arith.addi %37, %23 : tensor<32x32xi32, #blocked> loc(#loc20)
    %39 = tt.splat %arg2 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc21)
    %40 = tt.addptr %39, %38 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc21)
    %41 = tt.splat %arg3 : i32 -> tensor<32x1xi32, #blocked3> loc(#loc22)
    %42 = arith.cmpi slt, %15, %41 : tensor<32x1xi32, #blocked3> loc(#loc22)
    %43 = tt.splat %arg4 : i32 -> tensor<1x32xi32, #blocked> loc(#loc23)
    %44 = arith.cmpi slt, %20, %43 : tensor<1x32xi32, #blocked> loc(#loc23)
    %45 = tt.broadcast %42 : tensor<32x1xi1, #blocked3> -> tensor<32x32xi1, #blocked3> loc(#loc24)
    %46 = ttg.convert_layout %45 : tensor<32x32xi1, #blocked3> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %47 = tt.broadcast %44 : tensor<1x32xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %48 = arith.andi %46, %47 : tensor<32x32xi1, #blocked> loc(#loc24)
    %49 = tt.load %26, %48, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc25)
    %50 = tt.load %33, %48, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc26)
    %51 = arith.addf %49, %50 : tensor<32x32xf32, #blocked> loc(#loc27)
    tt.store %40, %51, %48 : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc28)
    tt.return loc(#loc29)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("examples/kernels/binary_ops.py":106:26)
#loc3 = loc("examples/kernels/binary_ops.py":107:26)
#loc4 = loc("examples/kernels/binary_ops.py":108:22)
#loc5 = loc("examples/kernels/binary_ops.py":108:50)
#loc6 = loc("examples/kernels/binary_ops.py":108:37)
#loc7 = loc("examples/kernels/binary_ops.py":108:67)
#loc8 = loc("examples/kernels/binary_ops.py":109:22)
#loc9 = loc("examples/kernels/binary_ops.py":109:37)
#loc10 = loc("examples/kernels/binary_ops.py":109:67)
#loc11 = loc("examples/kernels/binary_ops.py":110:29)
#loc12 = loc("examples/kernels/binary_ops.py":110:40)
#loc13 = loc("examples/kernels/binary_ops.py":110:59)
#loc14 = loc("examples/kernels/binary_ops.py":110:52)
#loc15 = loc("examples/kernels/binary_ops.py":110:22)
#loc16 = loc("examples/kernels/binary_ops.py":111:40)
#loc17 = loc("examples/kernels/binary_ops.py":111:52)
#loc18 = loc("examples/kernels/binary_ops.py":111:22)
#loc19 = loc("examples/kernels/binary_ops.py":112:40)
#loc20 = loc("examples/kernels/binary_ops.py":112:52)
#loc21 = loc("examples/kernels/binary_ops.py":112:22)
#loc22 = loc("examples/kernels/binary_ops.py":114:31)
#loc23 = loc("examples/kernels/binary_ops.py":114:55)
#loc24 = loc("examples/kernels/binary_ops.py":114:37)
#loc25 = loc("examples/kernels/binary_ops.py":116:16)
#loc26 = loc("examples/kernels/binary_ops.py":117:16)
#loc27 = loc("examples/kernels/binary_ops.py":118:12)
#loc28 = loc("examples/kernels/binary_ops.py":119:21)
#loc29 = loc("examples/kernels/binary_ops.py":119:4)


// -----// IR Dump Before TritonGPUF32DotTC (tritongpu-F32DotTC) ('builtin.module' operation) //----- //
#blocked = #ttg.blocked<{sizePerThread = [1, 1], threadsPerWarp = [1, 32], warpsPerCTA = [4, 1], order = [1, 0]}>
#blocked1 = #ttg.blocked<{sizePerThread = [1], threadsPerWarp = [32], warpsPerCTA = [4], order = [0]}>
#blocked2 = #ttg.blocked<{sizePerThread = [1, 1], threadsPerWarp = [32, 1], warpsPerCTA = [4, 1], order = [0, 1]}>
#blocked3 = #ttg.blocked<{sizePerThread = [1, 1], threadsPerWarp = [32, 1], warpsPerCTA = [4, 1], order = [1, 0]}>
#blocked4 = #ttg.blocked<{sizePerThread = [1, 1], threadsPerWarp = [1, 32], warpsPerCTA = [1, 4], order = [0, 1]}>
#blocked5 = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>
#loc = loc("examples/kernels/binary_ops.py":97:0)
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.target = "cuda:89", "ttg.threads-per-warp" = 32 : i32} {
  tt.func public @add_2d_kernel(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg1: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg2: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg3: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg4: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg5: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg6: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg7: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0)) attributes {noinline = false} {
    %cst = arith.constant dense<0.000000e+00> : tensor<32x32xf32, #blocked> loc(#loc1)
    %c32_i32 = arith.constant 32 : i32 loc(#loc1)
    %0 = tt.get_program_id x : i32 loc(#loc2)
    %1 = tt.get_program_id y : i32 loc(#loc3)
    %2 = arith.muli %0, %c32_i32 : i32 loc(#loc4)
    %3 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #blocked1> loc(#loc5)
    %4 = tt.splat %2 : i32 -> tensor<32xi32, #blocked1> loc(#loc6)
    %5 = arith.addi %4, %3 : tensor<32xi32, #blocked1> loc(#loc6)
    %6 = tt.splat %arg3 : i32 -> tensor<32xi32, #blocked1> loc(#loc7)
    %7 = arith.remsi %5, %6 : tensor<32xi32, #blocked1> loc(#loc7)
    %8 = arith.muli %1, %c32_i32 : i32 loc(#loc8)
    %9 = tt.splat %8 : i32 -> tensor<32xi32, #blocked1> loc(#loc9)
    %10 = arith.addi %9, %3 : tensor<32xi32, #blocked1> loc(#loc9)
    %11 = tt.splat %arg4 : i32 -> tensor<32xi32, #blocked1> loc(#loc10)
    %12 = arith.remsi %10, %11 : tensor<32xi32, #blocked1> loc(#loc10)
    %13 = ttg.convert_layout %7 : tensor<32xi32, #blocked1> -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked2}>> loc(#loc11)
    %14 = tt.expand_dims %13 {axis = 1 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked2}>> -> tensor<32x1xi32, #blocked2> loc(#loc11)
    %15 = ttg.convert_layout %14 : tensor<32x1xi32, #blocked2> -> tensor<32x1xi32, #blocked3> loc(#loc12)
    %16 = tt.splat %arg5 : i32 -> tensor<32x1xi32, #blocked3> loc(#loc12)
    %17 = arith.muli %15, %16 : tensor<32x1xi32, #blocked3> loc(#loc12)
    %18 = ttg.convert_layout %12 : tensor<32xi32, #blocked1> -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked4}>> loc(#loc13)
    %19 = tt.expand_dims %18 {axis = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked4}>> -> tensor<1x32xi32, #blocked4> loc(#loc13)
    %20 = ttg.convert_layout %19 : tensor<1x32xi32, #blocked4> -> tensor<1x32xi32, #blocked> loc(#loc14)
    %21 = tt.broadcast %17 : tensor<32x1xi32, #blocked3> -> tensor<32x32xi32, #blocked3> loc(#loc14)
    %22 = ttg.convert_layout %21 : tensor<32x32xi32, #blocked3> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %23 = tt.broadcast %20 : tensor<1x32xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %24 = arith.addi %22, %23 : tensor<32x32xi32, #blocked> loc(#loc14)
    %25 = tt.splat %arg0 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc15)
    %26 = tt.addptr %25, %24 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc15)
    %27 = tt.splat %arg6 : i32 -> tensor<32x1xi32, #blocked3> loc(#loc16)
    %28 = arith.muli %15, %27 : tensor<32x1xi32, #blocked3> loc(#loc16)
    %29 = tt.broadcast %28 : tensor<32x1xi32, #blocked3> -> tensor<32x32xi32, #blocked3> loc(#loc17)
    %30 = ttg.convert_layout %29 : tensor<32x32xi32, #blocked3> -> tensor<32x32xi32, #blocked> loc(#loc17)
    %31 = arith.addi %30, %23 : tensor<32x32xi32, #blocked> loc(#loc17)
    %32 = tt.splat %arg1 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc18)
    %33 = tt.addptr %32, %31 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc18)
    %34 = tt.splat %arg7 : i32 -> tensor<32x1xi32, #blocked3> loc(#loc19)
    %35 = arith.muli %15, %34 : tensor<32x1xi32, #blocked3> loc(#loc19)
    %36 = tt.broadcast %35 : tensor<32x1xi32, #blocked3> -> tensor<32x32xi32, #blocked3> loc(#loc20)
    %37 = ttg.convert_layout %36 : tensor<32x32xi32, #blocked3> -> tensor<32x32xi32, #blocked> loc(#loc20)
    %38 = arith.addi %37, %23 : tensor<32x32xi32, #blocked> loc(#loc20)
    %39 = tt.splat %arg2 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc21)
    %40 = tt.addptr %39, %38 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc21)
    %41 = tt.splat %arg3 : i32 -> tensor<32x1xi32, #blocked3> loc(#loc22)
    %42 = arith.cmpi slt, %15, %41 : tensor<32x1xi32, #blocked3> loc(#loc22)
    %43 = tt.splat %arg4 : i32 -> tensor<1x32xi32, #blocked> loc(#loc23)
    %44 = arith.cmpi slt, %20, %43 : tensor<1x32xi32, #blocked> loc(#loc23)
    %45 = tt.broadcast %42 : tensor<32x1xi1, #blocked3> -> tensor<32x32xi1, #blocked3> loc(#loc24)
    %46 = ttg.convert_layout %45 : tensor<32x32xi1, #blocked3> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %47 = tt.broadcast %44 : tensor<1x32xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %48 = arith.andi %46, %47 : tensor<32x32xi1, #blocked> loc(#loc24)
    %49 = ttg.convert_layout %26 : tensor<32x32x!tt.ptr<f32>, #blocked> -> tensor<32x32x!tt.ptr<f32>, #blocked5> loc(#loc25)
    %50 = ttg.convert_layout %48 : tensor<32x32xi1, #blocked> -> tensor<32x32xi1, #blocked5> loc(#loc25)
    %51 = ttg.convert_layout %cst : tensor<32x32xf32, #blocked> -> tensor<32x32xf32, #blocked5> loc(#loc25)
    %52 = tt.load %49, %50, %51 : tensor<32x32x!tt.ptr<f32>, #blocked5> loc(#loc25)
    %53 = ttg.convert_layout %52 : tensor<32x32xf32, #blocked5> -> tensor<32x32xf32, #blocked> loc(#loc25)
    %54 = ttg.convert_layout %33 : tensor<32x32x!tt.ptr<f32>, #blocked> -> tensor<32x32x!tt.ptr<f32>, #blocked5> loc(#loc26)
    %55 = ttg.convert_layout %48 : tensor<32x32xi1, #blocked> -> tensor<32x32xi1, #blocked5> loc(#loc26)
    %56 = ttg.convert_layout %cst : tensor<32x32xf32, #blocked> -> tensor<32x32xf32, #blocked5> loc(#loc26)
    %57 = tt.load %54, %55, %56 : tensor<32x32x!tt.ptr<f32>, #blocked5> loc(#loc26)
    %58 = ttg.convert_layout %57 : tensor<32x32xf32, #blocked5> -> tensor<32x32xf32, #blocked> loc(#loc26)
    %59 = arith.addf %53, %58 : tensor<32x32xf32, #blocked> loc(#loc27)
    %60 = ttg.convert_layout %40 : tensor<32x32x!tt.ptr<f32>, #blocked> -> tensor<32x32x!tt.ptr<f32>, #blocked5> loc(#loc28)
    %61 = ttg.convert_layout %59 : tensor<32x32xf32, #blocked> -> tensor<32x32xf32, #blocked5> loc(#loc28)
    %62 = ttg.convert_layout %48 : tensor<32x32xi1, #blocked> -> tensor<32x32xi1, #blocked5> loc(#loc28)
    tt.store %60, %61, %62 : tensor<32x32x!tt.ptr<f32>, #blocked5> loc(#loc28)
    tt.return loc(#loc29)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("examples/kernels/binary_ops.py":106:26)
#loc3 = loc("examples/kernels/binary_ops.py":107:26)
#loc4 = loc("examples/kernels/binary_ops.py":108:22)
#loc5 = loc("examples/kernels/binary_ops.py":108:50)
#loc6 = loc("examples/kernels/binary_ops.py":108:37)
#loc7 = loc("examples/kernels/binary_ops.py":108:67)
#loc8 = loc("examples/kernels/binary_ops.py":109:22)
#loc9 = loc("examples/kernels/binary_ops.py":109:37)
#loc10 = loc("examples/kernels/binary_ops.py":109:67)
#loc11 = loc("examples/kernels/binary_ops.py":110:29)
#loc12 = loc("examples/kernels/binary_ops.py":110:40)
#loc13 = loc("examples/kernels/binary_ops.py":110:59)
#loc14 = loc("examples/kernels/binary_ops.py":110:52)
#loc15 = loc("examples/kernels/binary_ops.py":110:22)
#loc16 = loc("examples/kernels/binary_ops.py":111:40)
#loc17 = loc("examples/kernels/binary_ops.py":111:52)
#loc18 = loc("examples/kernels/binary_ops.py":111:22)
#loc19 = loc("examples/kernels/binary_ops.py":112:40)
#loc20 = loc("examples/kernels/binary_ops.py":112:52)
#loc21 = loc("examples/kernels/binary_ops.py":112:22)
#loc22 = loc("examples/kernels/binary_ops.py":114:31)
#loc23 = loc("examples/kernels/binary_ops.py":114:55)
#loc24 = loc("examples/kernels/binary_ops.py":114:37)
#loc25 = loc("examples/kernels/binary_ops.py":116:16)
#loc26 = loc("examples/kernels/binary_ops.py":117:16)
#loc27 = loc("examples/kernels/binary_ops.py":118:12)
#loc28 = loc("examples/kernels/binary_ops.py":119:21)
#loc29 = loc("examples/kernels/binary_ops.py":119:4)


// -----// IR Dump Before TritonGPUPlanCTAPass (triton-nvidia-gpu-plan-cta) ('builtin.module' operation) //----- //
#blocked = #ttg.blocked<{sizePerThread = [1, 1], threadsPerWarp = [1, 32], warpsPerCTA = [4, 1], order = [1, 0]}>
#blocked1 = #ttg.blocked<{sizePerThread = [1], threadsPerWarp = [32], warpsPerCTA = [4], order = [0]}>
#blocked2 = #ttg.blocked<{sizePerThread = [1, 1], threadsPerWarp = [32, 1], warpsPerCTA = [4, 1], order = [0, 1]}>
#blocked3 = #ttg.blocked<{sizePerThread = [1, 1], threadsPerWarp = [32, 1], warpsPerCTA = [4, 1], order = [1, 0]}>
#blocked4 = #ttg.blocked<{sizePerThread = [1, 1], threadsPerWarp = [1, 32], warpsPerCTA = [1, 4], order = [0, 1]}>
#blocked5 = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>
#loc = loc("examples/kernels/binary_ops.py":97:0)
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.target = "cuda:89", "ttg.threads-per-warp" = 32 : i32} {
  tt.func public @add_2d_kernel(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg1: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg2: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg3: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg4: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg5: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg6: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg7: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0)) attributes {noinline = false} {
    %cst = arith.constant dense<0.000000e+00> : tensor<32x32xf32, #blocked> loc(#loc1)
    %c32_i32 = arith.constant 32 : i32 loc(#loc1)
    %0 = tt.get_program_id x : i32 loc(#loc2)
    %1 = tt.get_program_id y : i32 loc(#loc3)
    %2 = arith.muli %0, %c32_i32 : i32 loc(#loc4)
    %3 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #blocked1> loc(#loc5)
    %4 = tt.splat %2 : i32 -> tensor<32xi32, #blocked1> loc(#loc6)
    %5 = arith.addi %4, %3 : tensor<32xi32, #blocked1> loc(#loc6)
    %6 = tt.splat %arg3 : i32 -> tensor<32xi32, #blocked1> loc(#loc7)
    %7 = arith.remsi %5, %6 : tensor<32xi32, #blocked1> loc(#loc7)
    %8 = arith.muli %1, %c32_i32 : i32 loc(#loc8)
    %9 = tt.splat %8 : i32 -> tensor<32xi32, #blocked1> loc(#loc9)
    %10 = arith.addi %9, %3 : tensor<32xi32, #blocked1> loc(#loc9)
    %11 = tt.splat %arg4 : i32 -> tensor<32xi32, #blocked1> loc(#loc10)
    %12 = arith.remsi %10, %11 : tensor<32xi32, #blocked1> loc(#loc10)
    %13 = ttg.convert_layout %7 : tensor<32xi32, #blocked1> -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked2}>> loc(#loc11)
    %14 = tt.expand_dims %13 {axis = 1 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked2}>> -> tensor<32x1xi32, #blocked2> loc(#loc11)
    %15 = ttg.convert_layout %14 : tensor<32x1xi32, #blocked2> -> tensor<32x1xi32, #blocked3> loc(#loc12)
    %16 = tt.splat %arg5 : i32 -> tensor<32x1xi32, #blocked3> loc(#loc12)
    %17 = arith.muli %15, %16 : tensor<32x1xi32, #blocked3> loc(#loc12)
    %18 = ttg.convert_layout %12 : tensor<32xi32, #blocked1> -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked4}>> loc(#loc13)
    %19 = tt.expand_dims %18 {axis = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked4}>> -> tensor<1x32xi32, #blocked4> loc(#loc13)
    %20 = ttg.convert_layout %19 : tensor<1x32xi32, #blocked4> -> tensor<1x32xi32, #blocked> loc(#loc14)
    %21 = tt.broadcast %17 : tensor<32x1xi32, #blocked3> -> tensor<32x32xi32, #blocked3> loc(#loc14)
    %22 = ttg.convert_layout %21 : tensor<32x32xi32, #blocked3> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %23 = tt.broadcast %20 : tensor<1x32xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %24 = arith.addi %22, %23 : tensor<32x32xi32, #blocked> loc(#loc14)
    %25 = tt.splat %arg0 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc15)
    %26 = tt.addptr %25, %24 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc15)
    %27 = tt.splat %arg6 : i32 -> tensor<32x1xi32, #blocked3> loc(#loc16)
    %28 = arith.muli %15, %27 : tensor<32x1xi32, #blocked3> loc(#loc16)
    %29 = tt.broadcast %28 : tensor<32x1xi32, #blocked3> -> tensor<32x32xi32, #blocked3> loc(#loc17)
    %30 = ttg.convert_layout %29 : tensor<32x32xi32, #blocked3> -> tensor<32x32xi32, #blocked> loc(#loc17)
    %31 = arith.addi %30, %23 : tensor<32x32xi32, #blocked> loc(#loc17)
    %32 = tt.splat %arg1 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc18)
    %33 = tt.addptr %32, %31 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc18)
    %34 = tt.splat %arg7 : i32 -> tensor<32x1xi32, #blocked3> loc(#loc19)
    %35 = arith.muli %15, %34 : tensor<32x1xi32, #blocked3> loc(#loc19)
    %36 = tt.broadcast %35 : tensor<32x1xi32, #blocked3> -> tensor<32x32xi32, #blocked3> loc(#loc20)
    %37 = ttg.convert_layout %36 : tensor<32x32xi32, #blocked3> -> tensor<32x32xi32, #blocked> loc(#loc20)
    %38 = arith.addi %37, %23 : tensor<32x32xi32, #blocked> loc(#loc20)
    %39 = tt.splat %arg2 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc21)
    %40 = tt.addptr %39, %38 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc21)
    %41 = tt.splat %arg3 : i32 -> tensor<32x1xi32, #blocked3> loc(#loc22)
    %42 = arith.cmpi slt, %15, %41 : tensor<32x1xi32, #blocked3> loc(#loc22)
    %43 = tt.splat %arg4 : i32 -> tensor<1x32xi32, #blocked> loc(#loc23)
    %44 = arith.cmpi slt, %20, %43 : tensor<1x32xi32, #blocked> loc(#loc23)
    %45 = tt.broadcast %42 : tensor<32x1xi1, #blocked3> -> tensor<32x32xi1, #blocked3> loc(#loc24)
    %46 = ttg.convert_layout %45 : tensor<32x32xi1, #blocked3> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %47 = tt.broadcast %44 : tensor<1x32xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %48 = arith.andi %46, %47 : tensor<32x32xi1, #blocked> loc(#loc24)
    %49 = ttg.convert_layout %26 : tensor<32x32x!tt.ptr<f32>, #blocked> -> tensor<32x32x!tt.ptr<f32>, #blocked5> loc(#loc25)
    %50 = ttg.convert_layout %48 : tensor<32x32xi1, #blocked> -> tensor<32x32xi1, #blocked5> loc(#loc25)
    %51 = ttg.convert_layout %cst : tensor<32x32xf32, #blocked> -> tensor<32x32xf32, #blocked5> loc(#loc25)
    %52 = tt.load %49, %50, %51 : tensor<32x32x!tt.ptr<f32>, #blocked5> loc(#loc25)
    %53 = ttg.convert_layout %52 : tensor<32x32xf32, #blocked5> -> tensor<32x32xf32, #blocked> loc(#loc25)
    %54 = ttg.convert_layout %33 : tensor<32x32x!tt.ptr<f32>, #blocked> -> tensor<32x32x!tt.ptr<f32>, #blocked5> loc(#loc26)
    %55 = ttg.convert_layout %48 : tensor<32x32xi1, #blocked> -> tensor<32x32xi1, #blocked5> loc(#loc26)
    %56 = ttg.convert_layout %cst : tensor<32x32xf32, #blocked> -> tensor<32x32xf32, #blocked5> loc(#loc26)
    %57 = tt.load %54, %55, %56 : tensor<32x32x!tt.ptr<f32>, #blocked5> loc(#loc26)
    %58 = ttg.convert_layout %57 : tensor<32x32xf32, #blocked5> -> tensor<32x32xf32, #blocked> loc(#loc26)
    %59 = arith.addf %53, %58 : tensor<32x32xf32, #blocked> loc(#loc27)
    %60 = ttg.convert_layout %40 : tensor<32x32x!tt.ptr<f32>, #blocked> -> tensor<32x32x!tt.ptr<f32>, #blocked5> loc(#loc28)
    %61 = ttg.convert_layout %59 : tensor<32x32xf32, #blocked> -> tensor<32x32xf32, #blocked5> loc(#loc28)
    %62 = ttg.convert_layout %48 : tensor<32x32xi1, #blocked> -> tensor<32x32xi1, #blocked5> loc(#loc28)
    tt.store %60, %61, %62 : tensor<32x32x!tt.ptr<f32>, #blocked5> loc(#loc28)
    tt.return loc(#loc29)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("examples/kernels/binary_ops.py":106:26)
#loc3 = loc("examples/kernels/binary_ops.py":107:26)
#loc4 = loc("examples/kernels/binary_ops.py":108:22)
#loc5 = loc("examples/kernels/binary_ops.py":108:50)
#loc6 = loc("examples/kernels/binary_ops.py":108:37)
#loc7 = loc("examples/kernels/binary_ops.py":108:67)
#loc8 = loc("examples/kernels/binary_ops.py":109:22)
#loc9 = loc("examples/kernels/binary_ops.py":109:37)
#loc10 = loc("examples/kernels/binary_ops.py":109:67)
#loc11 = loc("examples/kernels/binary_ops.py":110:29)
#loc12 = loc("examples/kernels/binary_ops.py":110:40)
#loc13 = loc("examples/kernels/binary_ops.py":110:59)
#loc14 = loc("examples/kernels/binary_ops.py":110:52)
#loc15 = loc("examples/kernels/binary_ops.py":110:22)
#loc16 = loc("examples/kernels/binary_ops.py":111:40)
#loc17 = loc("examples/kernels/binary_ops.py":111:52)
#loc18 = loc("examples/kernels/binary_ops.py":111:22)
#loc19 = loc("examples/kernels/binary_ops.py":112:40)
#loc20 = loc("examples/kernels/binary_ops.py":112:52)
#loc21 = loc("examples/kernels/binary_ops.py":112:22)
#loc22 = loc("examples/kernels/binary_ops.py":114:31)
#loc23 = loc("examples/kernels/binary_ops.py":114:55)
#loc24 = loc("examples/kernels/binary_ops.py":114:37)
#loc25 = loc("examples/kernels/binary_ops.py":116:16)
#loc26 = loc("examples/kernels/binary_ops.py":117:16)
#loc27 = loc("examples/kernels/binary_ops.py":118:12)
#loc28 = loc("examples/kernels/binary_ops.py":119:21)
#loc29 = loc("examples/kernels/binary_ops.py":119:4)


// -----// IR Dump Before TritonGPURemoveLayoutConversions (tritongpu-remove-layout-conversions) ('builtin.module' operation) //----- //
#blocked = #ttg.blocked<{sizePerThread = [1, 1], threadsPerWarp = [1, 32], warpsPerCTA = [4, 1], order = [1, 0]}>
#blocked1 = #ttg.blocked<{sizePerThread = [1], threadsPerWarp = [32], warpsPerCTA = [4], order = [0]}>
#blocked2 = #ttg.blocked<{sizePerThread = [1, 1], threadsPerWarp = [32, 1], warpsPerCTA = [4, 1], order = [0, 1]}>
#blocked3 = #ttg.blocked<{sizePerThread = [1, 1], threadsPerWarp = [32, 1], warpsPerCTA = [4, 1], order = [1, 0]}>
#blocked4 = #ttg.blocked<{sizePerThread = [1, 1], threadsPerWarp = [1, 32], warpsPerCTA = [1, 4], order = [0, 1]}>
#blocked5 = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>
#loc = loc("examples/kernels/binary_ops.py":97:0)
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.target = "cuda:89", "ttg.threads-per-warp" = 32 : i32} {
  tt.func public @add_2d_kernel(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg1: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg2: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg3: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg4: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg5: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg6: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg7: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0)) attributes {noinline = false} {
    %cst = arith.constant dense<0.000000e+00> : tensor<32x32xf32, #blocked> loc(#loc1)
    %c32_i32 = arith.constant 32 : i32 loc(#loc1)
    %0 = tt.get_program_id x : i32 loc(#loc2)
    %1 = tt.get_program_id y : i32 loc(#loc3)
    %2 = arith.muli %0, %c32_i32 : i32 loc(#loc4)
    %3 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #blocked1> loc(#loc5)
    %4 = tt.splat %2 : i32 -> tensor<32xi32, #blocked1> loc(#loc6)
    %5 = arith.addi %4, %3 : tensor<32xi32, #blocked1> loc(#loc6)
    %6 = tt.splat %arg3 : i32 -> tensor<32xi32, #blocked1> loc(#loc7)
    %7 = arith.remsi %5, %6 : tensor<32xi32, #blocked1> loc(#loc7)
    %8 = arith.muli %1, %c32_i32 : i32 loc(#loc8)
    %9 = tt.splat %8 : i32 -> tensor<32xi32, #blocked1> loc(#loc9)
    %10 = arith.addi %9, %3 : tensor<32xi32, #blocked1> loc(#loc9)
    %11 = tt.splat %arg4 : i32 -> tensor<32xi32, #blocked1> loc(#loc10)
    %12 = arith.remsi %10, %11 : tensor<32xi32, #blocked1> loc(#loc10)
    %13 = ttg.convert_layout %7 : tensor<32xi32, #blocked1> -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked2}>> loc(#loc11)
    %14 = tt.expand_dims %13 {axis = 1 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked2}>> -> tensor<32x1xi32, #blocked2> loc(#loc11)
    %15 = ttg.convert_layout %14 : tensor<32x1xi32, #blocked2> -> tensor<32x1xi32, #blocked3> loc(#loc12)
    %16 = tt.splat %arg5 : i32 -> tensor<32x1xi32, #blocked3> loc(#loc12)
    %17 = arith.muli %15, %16 : tensor<32x1xi32, #blocked3> loc(#loc12)
    %18 = ttg.convert_layout %12 : tensor<32xi32, #blocked1> -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked4}>> loc(#loc13)
    %19 = tt.expand_dims %18 {axis = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked4}>> -> tensor<1x32xi32, #blocked4> loc(#loc13)
    %20 = ttg.convert_layout %19 : tensor<1x32xi32, #blocked4> -> tensor<1x32xi32, #blocked> loc(#loc14)
    %21 = tt.broadcast %17 : tensor<32x1xi32, #blocked3> -> tensor<32x32xi32, #blocked3> loc(#loc14)
    %22 = ttg.convert_layout %21 : tensor<32x32xi32, #blocked3> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %23 = tt.broadcast %20 : tensor<1x32xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %24 = arith.addi %22, %23 : tensor<32x32xi32, #blocked> loc(#loc14)
    %25 = tt.splat %arg0 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc15)
    %26 = tt.addptr %25, %24 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc15)
    %27 = tt.splat %arg6 : i32 -> tensor<32x1xi32, #blocked3> loc(#loc16)
    %28 = arith.muli %15, %27 : tensor<32x1xi32, #blocked3> loc(#loc16)
    %29 = tt.broadcast %28 : tensor<32x1xi32, #blocked3> -> tensor<32x32xi32, #blocked3> loc(#loc17)
    %30 = ttg.convert_layout %29 : tensor<32x32xi32, #blocked3> -> tensor<32x32xi32, #blocked> loc(#loc17)
    %31 = arith.addi %30, %23 : tensor<32x32xi32, #blocked> loc(#loc17)
    %32 = tt.splat %arg1 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc18)
    %33 = tt.addptr %32, %31 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc18)
    %34 = tt.splat %arg7 : i32 -> tensor<32x1xi32, #blocked3> loc(#loc19)
    %35 = arith.muli %15, %34 : tensor<32x1xi32, #blocked3> loc(#loc19)
    %36 = tt.broadcast %35 : tensor<32x1xi32, #blocked3> -> tensor<32x32xi32, #blocked3> loc(#loc20)
    %37 = ttg.convert_layout %36 : tensor<32x32xi32, #blocked3> -> tensor<32x32xi32, #blocked> loc(#loc20)
    %38 = arith.addi %37, %23 : tensor<32x32xi32, #blocked> loc(#loc20)
    %39 = tt.splat %arg2 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc21)
    %40 = tt.addptr %39, %38 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc21)
    %41 = tt.splat %arg3 : i32 -> tensor<32x1xi32, #blocked3> loc(#loc22)
    %42 = arith.cmpi slt, %15, %41 : tensor<32x1xi32, #blocked3> loc(#loc22)
    %43 = tt.splat %arg4 : i32 -> tensor<1x32xi32, #blocked> loc(#loc23)
    %44 = arith.cmpi slt, %20, %43 : tensor<1x32xi32, #blocked> loc(#loc23)
    %45 = tt.broadcast %42 : tensor<32x1xi1, #blocked3> -> tensor<32x32xi1, #blocked3> loc(#loc24)
    %46 = ttg.convert_layout %45 : tensor<32x32xi1, #blocked3> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %47 = tt.broadcast %44 : tensor<1x32xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %48 = arith.andi %46, %47 : tensor<32x32xi1, #blocked> loc(#loc24)
    %49 = ttg.convert_layout %26 : tensor<32x32x!tt.ptr<f32>, #blocked> -> tensor<32x32x!tt.ptr<f32>, #blocked5> loc(#loc25)
    %50 = ttg.convert_layout %48 : tensor<32x32xi1, #blocked> -> tensor<32x32xi1, #blocked5> loc(#loc25)
    %51 = ttg.convert_layout %cst : tensor<32x32xf32, #blocked> -> tensor<32x32xf32, #blocked5> loc(#loc25)
    %52 = tt.load %49, %50, %51 : tensor<32x32x!tt.ptr<f32>, #blocked5> loc(#loc25)
    %53 = ttg.convert_layout %52 : tensor<32x32xf32, #blocked5> -> tensor<32x32xf32, #blocked> loc(#loc25)
    %54 = ttg.convert_layout %33 : tensor<32x32x!tt.ptr<f32>, #blocked> -> tensor<32x32x!tt.ptr<f32>, #blocked5> loc(#loc26)
    %55 = ttg.convert_layout %48 : tensor<32x32xi1, #blocked> -> tensor<32x32xi1, #blocked5> loc(#loc26)
    %56 = ttg.convert_layout %cst : tensor<32x32xf32, #blocked> -> tensor<32x32xf32, #blocked5> loc(#loc26)
    %57 = tt.load %54, %55, %56 : tensor<32x32x!tt.ptr<f32>, #blocked5> loc(#loc26)
    %58 = ttg.convert_layout %57 : tensor<32x32xf32, #blocked5> -> tensor<32x32xf32, #blocked> loc(#loc26)
    %59 = arith.addf %53, %58 : tensor<32x32xf32, #blocked> loc(#loc27)
    %60 = ttg.convert_layout %40 : tensor<32x32x!tt.ptr<f32>, #blocked> -> tensor<32x32x!tt.ptr<f32>, #blocked5> loc(#loc28)
    %61 = ttg.convert_layout %59 : tensor<32x32xf32, #blocked> -> tensor<32x32xf32, #blocked5> loc(#loc28)
    %62 = ttg.convert_layout %48 : tensor<32x32xi1, #blocked> -> tensor<32x32xi1, #blocked5> loc(#loc28)
    tt.store %60, %61, %62 : tensor<32x32x!tt.ptr<f32>, #blocked5> loc(#loc28)
    tt.return loc(#loc29)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("examples/kernels/binary_ops.py":106:26)
#loc3 = loc("examples/kernels/binary_ops.py":107:26)
#loc4 = loc("examples/kernels/binary_ops.py":108:22)
#loc5 = loc("examples/kernels/binary_ops.py":108:50)
#loc6 = loc("examples/kernels/binary_ops.py":108:37)
#loc7 = loc("examples/kernels/binary_ops.py":108:67)
#loc8 = loc("examples/kernels/binary_ops.py":109:22)
#loc9 = loc("examples/kernels/binary_ops.py":109:37)
#loc10 = loc("examples/kernels/binary_ops.py":109:67)
#loc11 = loc("examples/kernels/binary_ops.py":110:29)
#loc12 = loc("examples/kernels/binary_ops.py":110:40)
#loc13 = loc("examples/kernels/binary_ops.py":110:59)
#loc14 = loc("examples/kernels/binary_ops.py":110:52)
#loc15 = loc("examples/kernels/binary_ops.py":110:22)
#loc16 = loc("examples/kernels/binary_ops.py":111:40)
#loc17 = loc("examples/kernels/binary_ops.py":111:52)
#loc18 = loc("examples/kernels/binary_ops.py":111:22)
#loc19 = loc("examples/kernels/binary_ops.py":112:40)
#loc20 = loc("examples/kernels/binary_ops.py":112:52)
#loc21 = loc("examples/kernels/binary_ops.py":112:22)
#loc22 = loc("examples/kernels/binary_ops.py":114:31)
#loc23 = loc("examples/kernels/binary_ops.py":114:55)
#loc24 = loc("examples/kernels/binary_ops.py":114:37)
#loc25 = loc("examples/kernels/binary_ops.py":116:16)
#loc26 = loc("examples/kernels/binary_ops.py":117:16)
#loc27 = loc("examples/kernels/binary_ops.py":118:12)
#loc28 = loc("examples/kernels/binary_ops.py":119:21)
#loc29 = loc("examples/kernels/binary_ops.py":119:4)


// -----// IR Dump Before TritonGPUOptimizeThreadLocality (tritongpu-optimize-thread-locality) ('builtin.module' operation) //----- //
#blocked = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>
#loc = loc("examples/kernels/binary_ops.py":97:0)
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.target = "cuda:89", "ttg.threads-per-warp" = 32 : i32} {
  tt.func public @add_2d_kernel(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg1: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg2: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg3: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg4: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg5: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg6: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg7: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0)) attributes {noinline = false} {
    %cst = arith.constant dense<0.000000e+00> : tensor<32x32xf32, #blocked> loc(#loc1)
    %c32_i32 = arith.constant 32 : i32 loc(#loc1)
    %0 = tt.get_program_id x : i32 loc(#loc2)
    %1 = tt.get_program_id y : i32 loc(#loc3)
    %2 = arith.muli %0, %c32_i32 : i32 loc(#loc4)
    %3 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc5)
    %4 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc5)
    %5 = tt.splat %2 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc6)
    %6 = arith.addi %5, %3 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc6)
    %7 = tt.splat %arg3 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc7)
    %8 = arith.remsi %6, %7 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc7)
    %9 = arith.muli %1, %c32_i32 : i32 loc(#loc8)
    %10 = tt.splat %9 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc9)
    %11 = arith.addi %10, %4 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc9)
    %12 = tt.splat %arg4 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc10)
    %13 = arith.remsi %11, %12 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc10)
    %14 = tt.expand_dims %8 {axis = 1 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> -> tensor<32x1xi32, #blocked> loc(#loc11)
    %15 = tt.splat %arg5 : i32 -> tensor<32x1xi32, #blocked> loc(#loc12)
    %16 = arith.muli %14, %15 : tensor<32x1xi32, #blocked> loc(#loc12)
    %17 = tt.expand_dims %13 {axis = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> -> tensor<1x32xi32, #blocked> loc(#loc13)
    %18 = tt.broadcast %16 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %19 = tt.broadcast %17 : tensor<1x32xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %20 = arith.addi %18, %19 : tensor<32x32xi32, #blocked> loc(#loc14)
    %21 = tt.splat %arg0 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc15)
    %22 = tt.addptr %21, %20 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc15)
    %23 = tt.splat %arg6 : i32 -> tensor<32x1xi32, #blocked> loc(#loc16)
    %24 = arith.muli %14, %23 : tensor<32x1xi32, #blocked> loc(#loc16)
    %25 = tt.broadcast %24 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc17)
    %26 = arith.addi %25, %19 : tensor<32x32xi32, #blocked> loc(#loc17)
    %27 = tt.splat %arg1 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc18)
    %28 = tt.addptr %27, %26 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc18)
    %29 = tt.splat %arg7 : i32 -> tensor<32x1xi32, #blocked> loc(#loc19)
    %30 = arith.muli %14, %29 : tensor<32x1xi32, #blocked> loc(#loc19)
    %31 = tt.broadcast %30 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc20)
    %32 = arith.addi %31, %19 : tensor<32x32xi32, #blocked> loc(#loc20)
    %33 = tt.splat %arg2 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc21)
    %34 = tt.addptr %33, %32 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc21)
    %35 = tt.splat %arg3 : i32 -> tensor<32x1xi32, #blocked> loc(#loc22)
    %36 = arith.cmpi slt, %14, %35 : tensor<32x1xi32, #blocked> loc(#loc22)
    %37 = tt.splat %arg4 : i32 -> tensor<1x32xi32, #blocked> loc(#loc23)
    %38 = arith.cmpi slt, %17, %37 : tensor<1x32xi32, #blocked> loc(#loc23)
    %39 = tt.broadcast %36 : tensor<32x1xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %40 = tt.broadcast %38 : tensor<1x32xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %41 = arith.andi %39, %40 : tensor<32x32xi1, #blocked> loc(#loc24)
    %42 = tt.load %22, %41, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc25)
    %43 = tt.load %28, %41, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc26)
    %44 = arith.addf %42, %43 : tensor<32x32xf32, #blocked> loc(#loc27)
    tt.store %34, %44, %41 : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc28)
    tt.return loc(#loc29)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("examples/kernels/binary_ops.py":106:26)
#loc3 = loc("examples/kernels/binary_ops.py":107:26)
#loc4 = loc("examples/kernels/binary_ops.py":108:22)
#loc5 = loc("examples/kernels/binary_ops.py":108:50)
#loc6 = loc("examples/kernels/binary_ops.py":108:37)
#loc7 = loc("examples/kernels/binary_ops.py":108:67)
#loc8 = loc("examples/kernels/binary_ops.py":109:22)
#loc9 = loc("examples/kernels/binary_ops.py":109:37)
#loc10 = loc("examples/kernels/binary_ops.py":109:67)
#loc11 = loc("examples/kernels/binary_ops.py":110:29)
#loc12 = loc("examples/kernels/binary_ops.py":110:40)
#loc13 = loc("examples/kernels/binary_ops.py":110:59)
#loc14 = loc("examples/kernels/binary_ops.py":110:52)
#loc15 = loc("examples/kernels/binary_ops.py":110:22)
#loc16 = loc("examples/kernels/binary_ops.py":111:40)
#loc17 = loc("examples/kernels/binary_ops.py":111:52)
#loc18 = loc("examples/kernels/binary_ops.py":111:22)
#loc19 = loc("examples/kernels/binary_ops.py":112:40)
#loc20 = loc("examples/kernels/binary_ops.py":112:52)
#loc21 = loc("examples/kernels/binary_ops.py":112:22)
#loc22 = loc("examples/kernels/binary_ops.py":114:31)
#loc23 = loc("examples/kernels/binary_ops.py":114:55)
#loc24 = loc("examples/kernels/binary_ops.py":114:37)
#loc25 = loc("examples/kernels/binary_ops.py":116:16)
#loc26 = loc("examples/kernels/binary_ops.py":117:16)
#loc27 = loc("examples/kernels/binary_ops.py":118:12)
#loc28 = loc("examples/kernels/binary_ops.py":119:21)
#loc29 = loc("examples/kernels/binary_ops.py":119:4)


// -----// IR Dump Before TritonGPUAccelerateMatmul (tritongpu-accelerate-matmul) ('builtin.module' operation) //----- //
#blocked = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>
#loc = loc("examples/kernels/binary_ops.py":97:0)
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.target = "cuda:89", "ttg.threads-per-warp" = 32 : i32} {
  tt.func public @add_2d_kernel(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg1: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg2: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg3: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg4: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg5: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg6: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg7: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0)) attributes {noinline = false} {
    %cst = arith.constant dense<0.000000e+00> : tensor<32x32xf32, #blocked> loc(#loc1)
    %c32_i32 = arith.constant 32 : i32 loc(#loc1)
    %0 = tt.get_program_id x : i32 loc(#loc2)
    %1 = tt.get_program_id y : i32 loc(#loc3)
    %2 = arith.muli %0, %c32_i32 : i32 loc(#loc4)
    %3 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc5)
    %4 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc5)
    %5 = tt.splat %2 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc6)
    %6 = arith.addi %5, %3 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc6)
    %7 = tt.splat %arg3 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc7)
    %8 = arith.remsi %6, %7 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc7)
    %9 = arith.muli %1, %c32_i32 : i32 loc(#loc8)
    %10 = tt.splat %9 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc9)
    %11 = arith.addi %10, %4 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc9)
    %12 = tt.splat %arg4 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc10)
    %13 = arith.remsi %11, %12 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc10)
    %14 = tt.expand_dims %8 {axis = 1 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> -> tensor<32x1xi32, #blocked> loc(#loc11)
    %15 = tt.splat %arg5 : i32 -> tensor<32x1xi32, #blocked> loc(#loc12)
    %16 = arith.muli %14, %15 : tensor<32x1xi32, #blocked> loc(#loc12)
    %17 = tt.expand_dims %13 {axis = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> -> tensor<1x32xi32, #blocked> loc(#loc13)
    %18 = tt.broadcast %16 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %19 = tt.broadcast %17 : tensor<1x32xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %20 = arith.addi %18, %19 : tensor<32x32xi32, #blocked> loc(#loc14)
    %21 = tt.splat %arg0 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc15)
    %22 = tt.addptr %21, %20 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc15)
    %23 = tt.splat %arg6 : i32 -> tensor<32x1xi32, #blocked> loc(#loc16)
    %24 = arith.muli %14, %23 : tensor<32x1xi32, #blocked> loc(#loc16)
    %25 = tt.broadcast %24 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc17)
    %26 = arith.addi %25, %19 : tensor<32x32xi32, #blocked> loc(#loc17)
    %27 = tt.splat %arg1 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc18)
    %28 = tt.addptr %27, %26 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc18)
    %29 = tt.splat %arg7 : i32 -> tensor<32x1xi32, #blocked> loc(#loc19)
    %30 = arith.muli %14, %29 : tensor<32x1xi32, #blocked> loc(#loc19)
    %31 = tt.broadcast %30 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc20)
    %32 = arith.addi %31, %19 : tensor<32x32xi32, #blocked> loc(#loc20)
    %33 = tt.splat %arg2 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc21)
    %34 = tt.addptr %33, %32 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc21)
    %35 = tt.splat %arg3 : i32 -> tensor<32x1xi32, #blocked> loc(#loc22)
    %36 = arith.cmpi slt, %14, %35 : tensor<32x1xi32, #blocked> loc(#loc22)
    %37 = tt.splat %arg4 : i32 -> tensor<1x32xi32, #blocked> loc(#loc23)
    %38 = arith.cmpi slt, %17, %37 : tensor<1x32xi32, #blocked> loc(#loc23)
    %39 = tt.broadcast %36 : tensor<32x1xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %40 = tt.broadcast %38 : tensor<1x32xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %41 = arith.andi %39, %40 : tensor<32x32xi1, #blocked> loc(#loc24)
    %42 = tt.load %22, %41, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc25)
    %43 = tt.load %28, %41, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc26)
    %44 = arith.addf %42, %43 : tensor<32x32xf32, #blocked> loc(#loc27)
    tt.store %34, %44, %41 : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc28)
    tt.return loc(#loc29)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("examples/kernels/binary_ops.py":106:26)
#loc3 = loc("examples/kernels/binary_ops.py":107:26)
#loc4 = loc("examples/kernels/binary_ops.py":108:22)
#loc5 = loc("examples/kernels/binary_ops.py":108:50)
#loc6 = loc("examples/kernels/binary_ops.py":108:37)
#loc7 = loc("examples/kernels/binary_ops.py":108:67)
#loc8 = loc("examples/kernels/binary_ops.py":109:22)
#loc9 = loc("examples/kernels/binary_ops.py":109:37)
#loc10 = loc("examples/kernels/binary_ops.py":109:67)
#loc11 = loc("examples/kernels/binary_ops.py":110:29)
#loc12 = loc("examples/kernels/binary_ops.py":110:40)
#loc13 = loc("examples/kernels/binary_ops.py":110:59)
#loc14 = loc("examples/kernels/binary_ops.py":110:52)
#loc15 = loc("examples/kernels/binary_ops.py":110:22)
#loc16 = loc("examples/kernels/binary_ops.py":111:40)
#loc17 = loc("examples/kernels/binary_ops.py":111:52)
#loc18 = loc("examples/kernels/binary_ops.py":111:22)
#loc19 = loc("examples/kernels/binary_ops.py":112:40)
#loc20 = loc("examples/kernels/binary_ops.py":112:52)
#loc21 = loc("examples/kernels/binary_ops.py":112:22)
#loc22 = loc("examples/kernels/binary_ops.py":114:31)
#loc23 = loc("examples/kernels/binary_ops.py":114:55)
#loc24 = loc("examples/kernels/binary_ops.py":114:37)
#loc25 = loc("examples/kernels/binary_ops.py":116:16)
#loc26 = loc("examples/kernels/binary_ops.py":117:16)
#loc27 = loc("examples/kernels/binary_ops.py":118:12)
#loc28 = loc("examples/kernels/binary_ops.py":119:21)
#loc29 = loc("examples/kernels/binary_ops.py":119:4)


// -----// IR Dump Before TritonGPURemoveLayoutConversions (tritongpu-remove-layout-conversions) ('builtin.module' operation) //----- //
#blocked = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>
#loc = loc("examples/kernels/binary_ops.py":97:0)
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.target = "cuda:89", "ttg.threads-per-warp" = 32 : i32} {
  tt.func public @add_2d_kernel(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg1: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg2: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg3: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg4: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg5: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg6: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg7: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0)) attributes {noinline = false} {
    %cst = arith.constant dense<0.000000e+00> : tensor<32x32xf32, #blocked> loc(#loc1)
    %c32_i32 = arith.constant 32 : i32 loc(#loc1)
    %0 = tt.get_program_id x : i32 loc(#loc2)
    %1 = tt.get_program_id y : i32 loc(#loc3)
    %2 = arith.muli %0, %c32_i32 : i32 loc(#loc4)
    %3 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc5)
    %4 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc5)
    %5 = tt.splat %2 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc6)
    %6 = arith.addi %5, %3 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc6)
    %7 = tt.splat %arg3 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc7)
    %8 = arith.remsi %6, %7 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc7)
    %9 = arith.muli %1, %c32_i32 : i32 loc(#loc8)
    %10 = tt.splat %9 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc9)
    %11 = arith.addi %10, %4 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc9)
    %12 = tt.splat %arg4 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc10)
    %13 = arith.remsi %11, %12 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc10)
    %14 = tt.expand_dims %8 {axis = 1 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> -> tensor<32x1xi32, #blocked> loc(#loc11)
    %15 = tt.splat %arg5 : i32 -> tensor<32x1xi32, #blocked> loc(#loc12)
    %16 = arith.muli %14, %15 : tensor<32x1xi32, #blocked> loc(#loc12)
    %17 = tt.expand_dims %13 {axis = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> -> tensor<1x32xi32, #blocked> loc(#loc13)
    %18 = tt.broadcast %16 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %19 = tt.broadcast %17 : tensor<1x32xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %20 = arith.addi %18, %19 : tensor<32x32xi32, #blocked> loc(#loc14)
    %21 = tt.splat %arg0 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc15)
    %22 = tt.addptr %21, %20 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc15)
    %23 = tt.splat %arg6 : i32 -> tensor<32x1xi32, #blocked> loc(#loc16)
    %24 = arith.muli %14, %23 : tensor<32x1xi32, #blocked> loc(#loc16)
    %25 = tt.broadcast %24 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc17)
    %26 = arith.addi %25, %19 : tensor<32x32xi32, #blocked> loc(#loc17)
    %27 = tt.splat %arg1 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc18)
    %28 = tt.addptr %27, %26 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc18)
    %29 = tt.splat %arg7 : i32 -> tensor<32x1xi32, #blocked> loc(#loc19)
    %30 = arith.muli %14, %29 : tensor<32x1xi32, #blocked> loc(#loc19)
    %31 = tt.broadcast %30 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc20)
    %32 = arith.addi %31, %19 : tensor<32x32xi32, #blocked> loc(#loc20)
    %33 = tt.splat %arg2 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc21)
    %34 = tt.addptr %33, %32 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc21)
    %35 = tt.splat %arg3 : i32 -> tensor<32x1xi32, #blocked> loc(#loc22)
    %36 = arith.cmpi slt, %14, %35 : tensor<32x1xi32, #blocked> loc(#loc22)
    %37 = tt.splat %arg4 : i32 -> tensor<1x32xi32, #blocked> loc(#loc23)
    %38 = arith.cmpi slt, %17, %37 : tensor<1x32xi32, #blocked> loc(#loc23)
    %39 = tt.broadcast %36 : tensor<32x1xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %40 = tt.broadcast %38 : tensor<1x32xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %41 = arith.andi %39, %40 : tensor<32x32xi1, #blocked> loc(#loc24)
    %42 = tt.load %22, %41, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc25)
    %43 = tt.load %28, %41, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc26)
    %44 = arith.addf %42, %43 : tensor<32x32xf32, #blocked> loc(#loc27)
    tt.store %34, %44, %41 : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc28)
    tt.return loc(#loc29)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("examples/kernels/binary_ops.py":106:26)
#loc3 = loc("examples/kernels/binary_ops.py":107:26)
#loc4 = loc("examples/kernels/binary_ops.py":108:22)
#loc5 = loc("examples/kernels/binary_ops.py":108:50)
#loc6 = loc("examples/kernels/binary_ops.py":108:37)
#loc7 = loc("examples/kernels/binary_ops.py":108:67)
#loc8 = loc("examples/kernels/binary_ops.py":109:22)
#loc9 = loc("examples/kernels/binary_ops.py":109:37)
#loc10 = loc("examples/kernels/binary_ops.py":109:67)
#loc11 = loc("examples/kernels/binary_ops.py":110:29)
#loc12 = loc("examples/kernels/binary_ops.py":110:40)
#loc13 = loc("examples/kernels/binary_ops.py":110:59)
#loc14 = loc("examples/kernels/binary_ops.py":110:52)
#loc15 = loc("examples/kernels/binary_ops.py":110:22)
#loc16 = loc("examples/kernels/binary_ops.py":111:40)
#loc17 = loc("examples/kernels/binary_ops.py":111:52)
#loc18 = loc("examples/kernels/binary_ops.py":111:22)
#loc19 = loc("examples/kernels/binary_ops.py":112:40)
#loc20 = loc("examples/kernels/binary_ops.py":112:52)
#loc21 = loc("examples/kernels/binary_ops.py":112:22)
#loc22 = loc("examples/kernels/binary_ops.py":114:31)
#loc23 = loc("examples/kernels/binary_ops.py":114:55)
#loc24 = loc("examples/kernels/binary_ops.py":114:37)
#loc25 = loc("examples/kernels/binary_ops.py":116:16)
#loc26 = loc("examples/kernels/binary_ops.py":117:16)
#loc27 = loc("examples/kernels/binary_ops.py":118:12)
#loc28 = loc("examples/kernels/binary_ops.py":119:21)
#loc29 = loc("examples/kernels/binary_ops.py":119:4)


// -----// IR Dump Before TritonGPUOptimizeDotOperands (tritongpu-optimize-dot-operands) ('builtin.module' operation) //----- //
#blocked = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>
#loc = loc("examples/kernels/binary_ops.py":97:0)
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.target = "cuda:89", "ttg.threads-per-warp" = 32 : i32} {
  tt.func public @add_2d_kernel(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg1: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg2: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg3: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg4: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg5: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg6: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg7: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0)) attributes {noinline = false} {
    %cst = arith.constant dense<0.000000e+00> : tensor<32x32xf32, #blocked> loc(#loc1)
    %c32_i32 = arith.constant 32 : i32 loc(#loc1)
    %0 = tt.get_program_id x : i32 loc(#loc2)
    %1 = tt.get_program_id y : i32 loc(#loc3)
    %2 = arith.muli %0, %c32_i32 : i32 loc(#loc4)
    %3 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc5)
    %4 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc5)
    %5 = tt.splat %2 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc6)
    %6 = arith.addi %5, %3 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc6)
    %7 = tt.splat %arg3 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc7)
    %8 = arith.remsi %6, %7 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc7)
    %9 = arith.muli %1, %c32_i32 : i32 loc(#loc8)
    %10 = tt.splat %9 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc9)
    %11 = arith.addi %10, %4 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc9)
    %12 = tt.splat %arg4 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc10)
    %13 = arith.remsi %11, %12 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc10)
    %14 = tt.expand_dims %8 {axis = 1 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> -> tensor<32x1xi32, #blocked> loc(#loc11)
    %15 = tt.splat %arg5 : i32 -> tensor<32x1xi32, #blocked> loc(#loc12)
    %16 = arith.muli %14, %15 : tensor<32x1xi32, #blocked> loc(#loc12)
    %17 = tt.expand_dims %13 {axis = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> -> tensor<1x32xi32, #blocked> loc(#loc13)
    %18 = tt.broadcast %16 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %19 = tt.broadcast %17 : tensor<1x32xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %20 = arith.addi %18, %19 : tensor<32x32xi32, #blocked> loc(#loc14)
    %21 = tt.splat %arg0 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc15)
    %22 = tt.addptr %21, %20 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc15)
    %23 = tt.splat %arg6 : i32 -> tensor<32x1xi32, #blocked> loc(#loc16)
    %24 = arith.muli %14, %23 : tensor<32x1xi32, #blocked> loc(#loc16)
    %25 = tt.broadcast %24 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc17)
    %26 = arith.addi %25, %19 : tensor<32x32xi32, #blocked> loc(#loc17)
    %27 = tt.splat %arg1 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc18)
    %28 = tt.addptr %27, %26 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc18)
    %29 = tt.splat %arg7 : i32 -> tensor<32x1xi32, #blocked> loc(#loc19)
    %30 = arith.muli %14, %29 : tensor<32x1xi32, #blocked> loc(#loc19)
    %31 = tt.broadcast %30 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc20)
    %32 = arith.addi %31, %19 : tensor<32x32xi32, #blocked> loc(#loc20)
    %33 = tt.splat %arg2 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc21)
    %34 = tt.addptr %33, %32 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc21)
    %35 = tt.splat %arg3 : i32 -> tensor<32x1xi32, #blocked> loc(#loc22)
    %36 = arith.cmpi slt, %14, %35 : tensor<32x1xi32, #blocked> loc(#loc22)
    %37 = tt.splat %arg4 : i32 -> tensor<1x32xi32, #blocked> loc(#loc23)
    %38 = arith.cmpi slt, %17, %37 : tensor<1x32xi32, #blocked> loc(#loc23)
    %39 = tt.broadcast %36 : tensor<32x1xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %40 = tt.broadcast %38 : tensor<1x32xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %41 = arith.andi %39, %40 : tensor<32x32xi1, #blocked> loc(#loc24)
    %42 = tt.load %22, %41, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc25)
    %43 = tt.load %28, %41, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc26)
    %44 = arith.addf %42, %43 : tensor<32x32xf32, #blocked> loc(#loc27)
    tt.store %34, %44, %41 : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc28)
    tt.return loc(#loc29)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("examples/kernels/binary_ops.py":106:26)
#loc3 = loc("examples/kernels/binary_ops.py":107:26)
#loc4 = loc("examples/kernels/binary_ops.py":108:22)
#loc5 = loc("examples/kernels/binary_ops.py":108:50)
#loc6 = loc("examples/kernels/binary_ops.py":108:37)
#loc7 = loc("examples/kernels/binary_ops.py":108:67)
#loc8 = loc("examples/kernels/binary_ops.py":109:22)
#loc9 = loc("examples/kernels/binary_ops.py":109:37)
#loc10 = loc("examples/kernels/binary_ops.py":109:67)
#loc11 = loc("examples/kernels/binary_ops.py":110:29)
#loc12 = loc("examples/kernels/binary_ops.py":110:40)
#loc13 = loc("examples/kernels/binary_ops.py":110:59)
#loc14 = loc("examples/kernels/binary_ops.py":110:52)
#loc15 = loc("examples/kernels/binary_ops.py":110:22)
#loc16 = loc("examples/kernels/binary_ops.py":111:40)
#loc17 = loc("examples/kernels/binary_ops.py":111:52)
#loc18 = loc("examples/kernels/binary_ops.py":111:22)
#loc19 = loc("examples/kernels/binary_ops.py":112:40)
#loc20 = loc("examples/kernels/binary_ops.py":112:52)
#loc21 = loc("examples/kernels/binary_ops.py":112:22)
#loc22 = loc("examples/kernels/binary_ops.py":114:31)
#loc23 = loc("examples/kernels/binary_ops.py":114:55)
#loc24 = loc("examples/kernels/binary_ops.py":114:37)
#loc25 = loc("examples/kernels/binary_ops.py":116:16)
#loc26 = loc("examples/kernels/binary_ops.py":117:16)
#loc27 = loc("examples/kernels/binary_ops.py":118:12)
#loc28 = loc("examples/kernels/binary_ops.py":119:21)
#loc29 = loc("examples/kernels/binary_ops.py":119:4)


// -----// IR Dump Before Canonicalizer (canonicalize) ('builtin.module' operation) //----- //
#blocked = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>
#loc = loc("examples/kernels/binary_ops.py":97:0)
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.target = "cuda:89", "ttg.threads-per-warp" = 32 : i32} {
  tt.func public @add_2d_kernel(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg1: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg2: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg3: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg4: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg5: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg6: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg7: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0)) attributes {noinline = false} {
    %cst = arith.constant dense<0.000000e+00> : tensor<32x32xf32, #blocked> loc(#loc1)
    %c32_i32 = arith.constant 32 : i32 loc(#loc1)
    %0 = tt.get_program_id x : i32 loc(#loc2)
    %1 = tt.get_program_id y : i32 loc(#loc3)
    %2 = arith.muli %0, %c32_i32 : i32 loc(#loc4)
    %3 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc5)
    %4 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc5)
    %5 = tt.splat %2 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc6)
    %6 = arith.addi %5, %3 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc6)
    %7 = tt.splat %arg3 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc7)
    %8 = arith.remsi %6, %7 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc7)
    %9 = arith.muli %1, %c32_i32 : i32 loc(#loc8)
    %10 = tt.splat %9 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc9)
    %11 = arith.addi %10, %4 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc9)
    %12 = tt.splat %arg4 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc10)
    %13 = arith.remsi %11, %12 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc10)
    %14 = tt.expand_dims %8 {axis = 1 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> -> tensor<32x1xi32, #blocked> loc(#loc11)
    %15 = tt.splat %arg5 : i32 -> tensor<32x1xi32, #blocked> loc(#loc12)
    %16 = arith.muli %14, %15 : tensor<32x1xi32, #blocked> loc(#loc12)
    %17 = tt.expand_dims %13 {axis = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> -> tensor<1x32xi32, #blocked> loc(#loc13)
    %18 = tt.broadcast %16 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %19 = tt.broadcast %17 : tensor<1x32xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %20 = arith.addi %18, %19 : tensor<32x32xi32, #blocked> loc(#loc14)
    %21 = tt.splat %arg0 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc15)
    %22 = tt.addptr %21, %20 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc15)
    %23 = tt.splat %arg6 : i32 -> tensor<32x1xi32, #blocked> loc(#loc16)
    %24 = arith.muli %14, %23 : tensor<32x1xi32, #blocked> loc(#loc16)
    %25 = tt.broadcast %24 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc17)
    %26 = arith.addi %25, %19 : tensor<32x32xi32, #blocked> loc(#loc17)
    %27 = tt.splat %arg1 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc18)
    %28 = tt.addptr %27, %26 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc18)
    %29 = tt.splat %arg7 : i32 -> tensor<32x1xi32, #blocked> loc(#loc19)
    %30 = arith.muli %14, %29 : tensor<32x1xi32, #blocked> loc(#loc19)
    %31 = tt.broadcast %30 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc20)
    %32 = arith.addi %31, %19 : tensor<32x32xi32, #blocked> loc(#loc20)
    %33 = tt.splat %arg2 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc21)
    %34 = tt.addptr %33, %32 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc21)
    %35 = tt.splat %arg3 : i32 -> tensor<32x1xi32, #blocked> loc(#loc22)
    %36 = arith.cmpi slt, %14, %35 : tensor<32x1xi32, #blocked> loc(#loc22)
    %37 = tt.splat %arg4 : i32 -> tensor<1x32xi32, #blocked> loc(#loc23)
    %38 = arith.cmpi slt, %17, %37 : tensor<1x32xi32, #blocked> loc(#loc23)
    %39 = tt.broadcast %36 : tensor<32x1xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %40 = tt.broadcast %38 : tensor<1x32xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %41 = arith.andi %39, %40 : tensor<32x32xi1, #blocked> loc(#loc24)
    %42 = tt.load %22, %41, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc25)
    %43 = tt.load %28, %41, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc26)
    %44 = arith.addf %42, %43 : tensor<32x32xf32, #blocked> loc(#loc27)
    tt.store %34, %44, %41 : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc28)
    tt.return loc(#loc29)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("examples/kernels/binary_ops.py":106:26)
#loc3 = loc("examples/kernels/binary_ops.py":107:26)
#loc4 = loc("examples/kernels/binary_ops.py":108:22)
#loc5 = loc("examples/kernels/binary_ops.py":108:50)
#loc6 = loc("examples/kernels/binary_ops.py":108:37)
#loc7 = loc("examples/kernels/binary_ops.py":108:67)
#loc8 = loc("examples/kernels/binary_ops.py":109:22)
#loc9 = loc("examples/kernels/binary_ops.py":109:37)
#loc10 = loc("examples/kernels/binary_ops.py":109:67)
#loc11 = loc("examples/kernels/binary_ops.py":110:29)
#loc12 = loc("examples/kernels/binary_ops.py":110:40)
#loc13 = loc("examples/kernels/binary_ops.py":110:59)
#loc14 = loc("examples/kernels/binary_ops.py":110:52)
#loc15 = loc("examples/kernels/binary_ops.py":110:22)
#loc16 = loc("examples/kernels/binary_ops.py":111:40)
#loc17 = loc("examples/kernels/binary_ops.py":111:52)
#loc18 = loc("examples/kernels/binary_ops.py":111:22)
#loc19 = loc("examples/kernels/binary_ops.py":112:40)
#loc20 = loc("examples/kernels/binary_ops.py":112:52)
#loc21 = loc("examples/kernels/binary_ops.py":112:22)
#loc22 = loc("examples/kernels/binary_ops.py":114:31)
#loc23 = loc("examples/kernels/binary_ops.py":114:55)
#loc24 = loc("examples/kernels/binary_ops.py":114:37)
#loc25 = loc("examples/kernels/binary_ops.py":116:16)
#loc26 = loc("examples/kernels/binary_ops.py":117:16)
#loc27 = loc("examples/kernels/binary_ops.py":118:12)
#loc28 = loc("examples/kernels/binary_ops.py":119:21)
#loc29 = loc("examples/kernels/binary_ops.py":119:4)


// -----// IR Dump Before CSE (cse) ('builtin.module' operation) //----- //
#blocked = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>
#loc = loc("examples/kernels/binary_ops.py":97:0)
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.target = "cuda:89", "ttg.threads-per-warp" = 32 : i32} {
  tt.func public @add_2d_kernel(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg1: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg2: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg3: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg4: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg5: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg6: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg7: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0)) attributes {noinline = false} {
    %cst = arith.constant dense<0.000000e+00> : tensor<32x32xf32, #blocked> loc(#loc1)
    %c32_i32 = arith.constant 32 : i32 loc(#loc1)
    %0 = tt.get_program_id x : i32 loc(#loc2)
    %1 = tt.get_program_id y : i32 loc(#loc3)
    %2 = arith.muli %0, %c32_i32 : i32 loc(#loc4)
    %3 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc5)
    %4 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc5)
    %5 = tt.splat %2 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc6)
    %6 = arith.addi %5, %3 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc6)
    %7 = tt.splat %arg3 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc7)
    %8 = arith.remsi %6, %7 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc7)
    %9 = arith.muli %1, %c32_i32 : i32 loc(#loc8)
    %10 = tt.splat %9 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc9)
    %11 = arith.addi %10, %4 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc9)
    %12 = tt.splat %arg4 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc10)
    %13 = arith.remsi %11, %12 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc10)
    %14 = tt.expand_dims %8 {axis = 1 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> -> tensor<32x1xi32, #blocked> loc(#loc11)
    %15 = tt.splat %arg5 : i32 -> tensor<32x1xi32, #blocked> loc(#loc12)
    %16 = arith.muli %14, %15 : tensor<32x1xi32, #blocked> loc(#loc12)
    %17 = tt.expand_dims %13 {axis = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> -> tensor<1x32xi32, #blocked> loc(#loc13)
    %18 = tt.broadcast %16 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %19 = tt.broadcast %17 : tensor<1x32xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %20 = arith.addi %18, %19 : tensor<32x32xi32, #blocked> loc(#loc14)
    %21 = tt.splat %arg0 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc15)
    %22 = tt.addptr %21, %20 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc15)
    %23 = tt.splat %arg6 : i32 -> tensor<32x1xi32, #blocked> loc(#loc16)
    %24 = arith.muli %14, %23 : tensor<32x1xi32, #blocked> loc(#loc16)
    %25 = tt.broadcast %24 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc17)
    %26 = arith.addi %25, %19 : tensor<32x32xi32, #blocked> loc(#loc17)
    %27 = tt.splat %arg1 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc18)
    %28 = tt.addptr %27, %26 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc18)
    %29 = tt.splat %arg7 : i32 -> tensor<32x1xi32, #blocked> loc(#loc19)
    %30 = arith.muli %14, %29 : tensor<32x1xi32, #blocked> loc(#loc19)
    %31 = tt.broadcast %30 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc20)
    %32 = arith.addi %31, %19 : tensor<32x32xi32, #blocked> loc(#loc20)
    %33 = tt.splat %arg2 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc21)
    %34 = tt.addptr %33, %32 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc21)
    %35 = tt.splat %arg3 : i32 -> tensor<32x1xi32, #blocked> loc(#loc22)
    %36 = arith.cmpi slt, %14, %35 : tensor<32x1xi32, #blocked> loc(#loc22)
    %37 = tt.splat %arg4 : i32 -> tensor<1x32xi32, #blocked> loc(#loc23)
    %38 = arith.cmpi slt, %17, %37 : tensor<1x32xi32, #blocked> loc(#loc23)
    %39 = tt.broadcast %36 : tensor<32x1xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %40 = tt.broadcast %38 : tensor<1x32xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %41 = arith.andi %39, %40 : tensor<32x32xi1, #blocked> loc(#loc24)
    %42 = tt.load %22, %41, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc25)
    %43 = tt.load %28, %41, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc26)
    %44 = arith.addf %42, %43 : tensor<32x32xf32, #blocked> loc(#loc27)
    tt.store %34, %44, %41 : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc28)
    tt.return loc(#loc29)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("examples/kernels/binary_ops.py":106:26)
#loc3 = loc("examples/kernels/binary_ops.py":107:26)
#loc4 = loc("examples/kernels/binary_ops.py":108:22)
#loc5 = loc("examples/kernels/binary_ops.py":108:50)
#loc6 = loc("examples/kernels/binary_ops.py":108:37)
#loc7 = loc("examples/kernels/binary_ops.py":108:67)
#loc8 = loc("examples/kernels/binary_ops.py":109:22)
#loc9 = loc("examples/kernels/binary_ops.py":109:37)
#loc10 = loc("examples/kernels/binary_ops.py":109:67)
#loc11 = loc("examples/kernels/binary_ops.py":110:29)
#loc12 = loc("examples/kernels/binary_ops.py":110:40)
#loc13 = loc("examples/kernels/binary_ops.py":110:59)
#loc14 = loc("examples/kernels/binary_ops.py":110:52)
#loc15 = loc("examples/kernels/binary_ops.py":110:22)
#loc16 = loc("examples/kernels/binary_ops.py":111:40)
#loc17 = loc("examples/kernels/binary_ops.py":111:52)
#loc18 = loc("examples/kernels/binary_ops.py":111:22)
#loc19 = loc("examples/kernels/binary_ops.py":112:40)
#loc20 = loc("examples/kernels/binary_ops.py":112:52)
#loc21 = loc("examples/kernels/binary_ops.py":112:22)
#loc22 = loc("examples/kernels/binary_ops.py":114:31)
#loc23 = loc("examples/kernels/binary_ops.py":114:55)
#loc24 = loc("examples/kernels/binary_ops.py":114:37)
#loc25 = loc("examples/kernels/binary_ops.py":116:16)
#loc26 = loc("examples/kernels/binary_ops.py":117:16)
#loc27 = loc("examples/kernels/binary_ops.py":118:12)
#loc28 = loc("examples/kernels/binary_ops.py":119:21)
#loc29 = loc("examples/kernels/binary_ops.py":119:4)


// -----// IR Dump Before TritonGPUFuseNestedLoops (tritongpu-fuse-nested-loops) ('builtin.module' operation) //----- //
#blocked = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>
#loc = loc("examples/kernels/binary_ops.py":97:0)
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.target = "cuda:89", "ttg.threads-per-warp" = 32 : i32} {
  tt.func public @add_2d_kernel(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg1: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg2: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg3: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg4: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg5: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg6: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg7: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0)) attributes {noinline = false} {
    %cst = arith.constant dense<0.000000e+00> : tensor<32x32xf32, #blocked> loc(#loc1)
    %c32_i32 = arith.constant 32 : i32 loc(#loc1)
    %0 = tt.get_program_id x : i32 loc(#loc2)
    %1 = tt.get_program_id y : i32 loc(#loc3)
    %2 = arith.muli %0, %c32_i32 : i32 loc(#loc4)
    %3 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc5)
    %4 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc5)
    %5 = tt.splat %2 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc6)
    %6 = arith.addi %5, %3 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc6)
    %7 = tt.splat %arg3 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc7)
    %8 = arith.remsi %6, %7 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc7)
    %9 = arith.muli %1, %c32_i32 : i32 loc(#loc8)
    %10 = tt.splat %9 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc9)
    %11 = arith.addi %10, %4 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc9)
    %12 = tt.splat %arg4 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc10)
    %13 = arith.remsi %11, %12 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc10)
    %14 = tt.expand_dims %8 {axis = 1 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> -> tensor<32x1xi32, #blocked> loc(#loc11)
    %15 = tt.splat %arg5 : i32 -> tensor<32x1xi32, #blocked> loc(#loc12)
    %16 = arith.muli %14, %15 : tensor<32x1xi32, #blocked> loc(#loc12)
    %17 = tt.expand_dims %13 {axis = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> -> tensor<1x32xi32, #blocked> loc(#loc13)
    %18 = tt.broadcast %16 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %19 = tt.broadcast %17 : tensor<1x32xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %20 = arith.addi %18, %19 : tensor<32x32xi32, #blocked> loc(#loc14)
    %21 = tt.splat %arg0 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc15)
    %22 = tt.addptr %21, %20 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc15)
    %23 = tt.splat %arg6 : i32 -> tensor<32x1xi32, #blocked> loc(#loc16)
    %24 = arith.muli %14, %23 : tensor<32x1xi32, #blocked> loc(#loc16)
    %25 = tt.broadcast %24 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc17)
    %26 = arith.addi %25, %19 : tensor<32x32xi32, #blocked> loc(#loc17)
    %27 = tt.splat %arg1 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc18)
    %28 = tt.addptr %27, %26 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc18)
    %29 = tt.splat %arg7 : i32 -> tensor<32x1xi32, #blocked> loc(#loc19)
    %30 = arith.muli %14, %29 : tensor<32x1xi32, #blocked> loc(#loc19)
    %31 = tt.broadcast %30 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc20)
    %32 = arith.addi %31, %19 : tensor<32x32xi32, #blocked> loc(#loc20)
    %33 = tt.splat %arg2 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc21)
    %34 = tt.addptr %33, %32 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc21)
    %35 = tt.splat %arg3 : i32 -> tensor<32x1xi32, #blocked> loc(#loc22)
    %36 = arith.cmpi slt, %14, %35 : tensor<32x1xi32, #blocked> loc(#loc22)
    %37 = tt.splat %arg4 : i32 -> tensor<1x32xi32, #blocked> loc(#loc23)
    %38 = arith.cmpi slt, %17, %37 : tensor<1x32xi32, #blocked> loc(#loc23)
    %39 = tt.broadcast %36 : tensor<32x1xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %40 = tt.broadcast %38 : tensor<1x32xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %41 = arith.andi %39, %40 : tensor<32x32xi1, #blocked> loc(#loc24)
    %42 = tt.load %22, %41, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc25)
    %43 = tt.load %28, %41, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc26)
    %44 = arith.addf %42, %43 : tensor<32x32xf32, #blocked> loc(#loc27)
    tt.store %34, %44, %41 : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc28)
    tt.return loc(#loc29)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("examples/kernels/binary_ops.py":106:26)
#loc3 = loc("examples/kernels/binary_ops.py":107:26)
#loc4 = loc("examples/kernels/binary_ops.py":108:22)
#loc5 = loc("examples/kernels/binary_ops.py":108:50)
#loc6 = loc("examples/kernels/binary_ops.py":108:37)
#loc7 = loc("examples/kernels/binary_ops.py":108:67)
#loc8 = loc("examples/kernels/binary_ops.py":109:22)
#loc9 = loc("examples/kernels/binary_ops.py":109:37)
#loc10 = loc("examples/kernels/binary_ops.py":109:67)
#loc11 = loc("examples/kernels/binary_ops.py":110:29)
#loc12 = loc("examples/kernels/binary_ops.py":110:40)
#loc13 = loc("examples/kernels/binary_ops.py":110:59)
#loc14 = loc("examples/kernels/binary_ops.py":110:52)
#loc15 = loc("examples/kernels/binary_ops.py":110:22)
#loc16 = loc("examples/kernels/binary_ops.py":111:40)
#loc17 = loc("examples/kernels/binary_ops.py":111:52)
#loc18 = loc("examples/kernels/binary_ops.py":111:22)
#loc19 = loc("examples/kernels/binary_ops.py":112:40)
#loc20 = loc("examples/kernels/binary_ops.py":112:52)
#loc21 = loc("examples/kernels/binary_ops.py":112:22)
#loc22 = loc("examples/kernels/binary_ops.py":114:31)
#loc23 = loc("examples/kernels/binary_ops.py":114:55)
#loc24 = loc("examples/kernels/binary_ops.py":114:37)
#loc25 = loc("examples/kernels/binary_ops.py":116:16)
#loc26 = loc("examples/kernels/binary_ops.py":117:16)
#loc27 = loc("examples/kernels/binary_ops.py":118:12)
#loc28 = loc("examples/kernels/binary_ops.py":119:21)
#loc29 = loc("examples/kernels/binary_ops.py":119:4)


// -----// IR Dump Before Canonicalizer (canonicalize) ('builtin.module' operation) //----- //
#blocked = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>
#loc = loc("examples/kernels/binary_ops.py":97:0)
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.target = "cuda:89", "ttg.threads-per-warp" = 32 : i32} {
  tt.func public @add_2d_kernel(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg1: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg2: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg3: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg4: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg5: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg6: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg7: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0)) attributes {noinline = false} {
    %cst = arith.constant dense<0.000000e+00> : tensor<32x32xf32, #blocked> loc(#loc1)
    %c32_i32 = arith.constant 32 : i32 loc(#loc1)
    %0 = tt.get_program_id x : i32 loc(#loc2)
    %1 = tt.get_program_id y : i32 loc(#loc3)
    %2 = arith.muli %0, %c32_i32 : i32 loc(#loc4)
    %3 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc5)
    %4 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc5)
    %5 = tt.splat %2 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc6)
    %6 = arith.addi %5, %3 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc6)
    %7 = tt.splat %arg3 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc7)
    %8 = arith.remsi %6, %7 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc7)
    %9 = arith.muli %1, %c32_i32 : i32 loc(#loc8)
    %10 = tt.splat %9 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc9)
    %11 = arith.addi %10, %4 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc9)
    %12 = tt.splat %arg4 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc10)
    %13 = arith.remsi %11, %12 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc10)
    %14 = tt.expand_dims %8 {axis = 1 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> -> tensor<32x1xi32, #blocked> loc(#loc11)
    %15 = tt.splat %arg5 : i32 -> tensor<32x1xi32, #blocked> loc(#loc12)
    %16 = arith.muli %14, %15 : tensor<32x1xi32, #blocked> loc(#loc12)
    %17 = tt.expand_dims %13 {axis = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> -> tensor<1x32xi32, #blocked> loc(#loc13)
    %18 = tt.broadcast %16 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %19 = tt.broadcast %17 : tensor<1x32xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %20 = arith.addi %18, %19 : tensor<32x32xi32, #blocked> loc(#loc14)
    %21 = tt.splat %arg0 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc15)
    %22 = tt.addptr %21, %20 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc15)
    %23 = tt.splat %arg6 : i32 -> tensor<32x1xi32, #blocked> loc(#loc16)
    %24 = arith.muli %14, %23 : tensor<32x1xi32, #blocked> loc(#loc16)
    %25 = tt.broadcast %24 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc17)
    %26 = arith.addi %25, %19 : tensor<32x32xi32, #blocked> loc(#loc17)
    %27 = tt.splat %arg1 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc18)
    %28 = tt.addptr %27, %26 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc18)
    %29 = tt.splat %arg7 : i32 -> tensor<32x1xi32, #blocked> loc(#loc19)
    %30 = arith.muli %14, %29 : tensor<32x1xi32, #blocked> loc(#loc19)
    %31 = tt.broadcast %30 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc20)
    %32 = arith.addi %31, %19 : tensor<32x32xi32, #blocked> loc(#loc20)
    %33 = tt.splat %arg2 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc21)
    %34 = tt.addptr %33, %32 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc21)
    %35 = tt.splat %arg3 : i32 -> tensor<32x1xi32, #blocked> loc(#loc22)
    %36 = arith.cmpi slt, %14, %35 : tensor<32x1xi32, #blocked> loc(#loc22)
    %37 = tt.splat %arg4 : i32 -> tensor<1x32xi32, #blocked> loc(#loc23)
    %38 = arith.cmpi slt, %17, %37 : tensor<1x32xi32, #blocked> loc(#loc23)
    %39 = tt.broadcast %36 : tensor<32x1xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %40 = tt.broadcast %38 : tensor<1x32xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %41 = arith.andi %39, %40 : tensor<32x32xi1, #blocked> loc(#loc24)
    %42 = tt.load %22, %41, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc25)
    %43 = tt.load %28, %41, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc26)
    %44 = arith.addf %42, %43 : tensor<32x32xf32, #blocked> loc(#loc27)
    tt.store %34, %44, %41 : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc28)
    tt.return loc(#loc29)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("examples/kernels/binary_ops.py":106:26)
#loc3 = loc("examples/kernels/binary_ops.py":107:26)
#loc4 = loc("examples/kernels/binary_ops.py":108:22)
#loc5 = loc("examples/kernels/binary_ops.py":108:50)
#loc6 = loc("examples/kernels/binary_ops.py":108:37)
#loc7 = loc("examples/kernels/binary_ops.py":108:67)
#loc8 = loc("examples/kernels/binary_ops.py":109:22)
#loc9 = loc("examples/kernels/binary_ops.py":109:37)
#loc10 = loc("examples/kernels/binary_ops.py":109:67)
#loc11 = loc("examples/kernels/binary_ops.py":110:29)
#loc12 = loc("examples/kernels/binary_ops.py":110:40)
#loc13 = loc("examples/kernels/binary_ops.py":110:59)
#loc14 = loc("examples/kernels/binary_ops.py":110:52)
#loc15 = loc("examples/kernels/binary_ops.py":110:22)
#loc16 = loc("examples/kernels/binary_ops.py":111:40)
#loc17 = loc("examples/kernels/binary_ops.py":111:52)
#loc18 = loc("examples/kernels/binary_ops.py":111:22)
#loc19 = loc("examples/kernels/binary_ops.py":112:40)
#loc20 = loc("examples/kernels/binary_ops.py":112:52)
#loc21 = loc("examples/kernels/binary_ops.py":112:22)
#loc22 = loc("examples/kernels/binary_ops.py":114:31)
#loc23 = loc("examples/kernels/binary_ops.py":114:55)
#loc24 = loc("examples/kernels/binary_ops.py":114:37)
#loc25 = loc("examples/kernels/binary_ops.py":116:16)
#loc26 = loc("examples/kernels/binary_ops.py":117:16)
#loc27 = loc("examples/kernels/binary_ops.py":118:12)
#loc28 = loc("examples/kernels/binary_ops.py":119:21)
#loc29 = loc("examples/kernels/binary_ops.py":119:4)


// -----// IR Dump Before LoopInvariantCodeMotion (loop-invariant-code-motion) ('builtin.module' operation) //----- //
#blocked = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>
#loc = loc("examples/kernels/binary_ops.py":97:0)
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.target = "cuda:89", "ttg.threads-per-warp" = 32 : i32} {
  tt.func public @add_2d_kernel(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg1: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg2: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg3: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg4: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg5: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg6: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg7: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0)) attributes {noinline = false} {
    %cst = arith.constant dense<0.000000e+00> : tensor<32x32xf32, #blocked> loc(#loc1)
    %c32_i32 = arith.constant 32 : i32 loc(#loc1)
    %0 = tt.get_program_id x : i32 loc(#loc2)
    %1 = tt.get_program_id y : i32 loc(#loc3)
    %2 = arith.muli %0, %c32_i32 : i32 loc(#loc4)
    %3 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc5)
    %4 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc5)
    %5 = tt.splat %2 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc6)
    %6 = arith.addi %5, %3 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc6)
    %7 = tt.splat %arg3 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc7)
    %8 = arith.remsi %6, %7 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc7)
    %9 = arith.muli %1, %c32_i32 : i32 loc(#loc8)
    %10 = tt.splat %9 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc9)
    %11 = arith.addi %10, %4 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc9)
    %12 = tt.splat %arg4 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc10)
    %13 = arith.remsi %11, %12 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc10)
    %14 = tt.expand_dims %8 {axis = 1 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> -> tensor<32x1xi32, #blocked> loc(#loc11)
    %15 = tt.splat %arg5 : i32 -> tensor<32x1xi32, #blocked> loc(#loc12)
    %16 = arith.muli %14, %15 : tensor<32x1xi32, #blocked> loc(#loc12)
    %17 = tt.expand_dims %13 {axis = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> -> tensor<1x32xi32, #blocked> loc(#loc13)
    %18 = tt.broadcast %16 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %19 = tt.broadcast %17 : tensor<1x32xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %20 = arith.addi %18, %19 : tensor<32x32xi32, #blocked> loc(#loc14)
    %21 = tt.splat %arg0 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc15)
    %22 = tt.addptr %21, %20 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc15)
    %23 = tt.splat %arg6 : i32 -> tensor<32x1xi32, #blocked> loc(#loc16)
    %24 = arith.muli %14, %23 : tensor<32x1xi32, #blocked> loc(#loc16)
    %25 = tt.broadcast %24 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc17)
    %26 = arith.addi %25, %19 : tensor<32x32xi32, #blocked> loc(#loc17)
    %27 = tt.splat %arg1 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc18)
    %28 = tt.addptr %27, %26 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc18)
    %29 = tt.splat %arg7 : i32 -> tensor<32x1xi32, #blocked> loc(#loc19)
    %30 = arith.muli %14, %29 : tensor<32x1xi32, #blocked> loc(#loc19)
    %31 = tt.broadcast %30 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc20)
    %32 = arith.addi %31, %19 : tensor<32x32xi32, #blocked> loc(#loc20)
    %33 = tt.splat %arg2 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc21)
    %34 = tt.addptr %33, %32 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc21)
    %35 = tt.splat %arg3 : i32 -> tensor<32x1xi32, #blocked> loc(#loc22)
    %36 = arith.cmpi slt, %14, %35 : tensor<32x1xi32, #blocked> loc(#loc22)
    %37 = tt.splat %arg4 : i32 -> tensor<1x32xi32, #blocked> loc(#loc23)
    %38 = arith.cmpi slt, %17, %37 : tensor<1x32xi32, #blocked> loc(#loc23)
    %39 = tt.broadcast %36 : tensor<32x1xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %40 = tt.broadcast %38 : tensor<1x32xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %41 = arith.andi %39, %40 : tensor<32x32xi1, #blocked> loc(#loc24)
    %42 = tt.load %22, %41, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc25)
    %43 = tt.load %28, %41, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc26)
    %44 = arith.addf %42, %43 : tensor<32x32xf32, #blocked> loc(#loc27)
    tt.store %34, %44, %41 : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc28)
    tt.return loc(#loc29)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("examples/kernels/binary_ops.py":106:26)
#loc3 = loc("examples/kernels/binary_ops.py":107:26)
#loc4 = loc("examples/kernels/binary_ops.py":108:22)
#loc5 = loc("examples/kernels/binary_ops.py":108:50)
#loc6 = loc("examples/kernels/binary_ops.py":108:37)
#loc7 = loc("examples/kernels/binary_ops.py":108:67)
#loc8 = loc("examples/kernels/binary_ops.py":109:22)
#loc9 = loc("examples/kernels/binary_ops.py":109:37)
#loc10 = loc("examples/kernels/binary_ops.py":109:67)
#loc11 = loc("examples/kernels/binary_ops.py":110:29)
#loc12 = loc("examples/kernels/binary_ops.py":110:40)
#loc13 = loc("examples/kernels/binary_ops.py":110:59)
#loc14 = loc("examples/kernels/binary_ops.py":110:52)
#loc15 = loc("examples/kernels/binary_ops.py":110:22)
#loc16 = loc("examples/kernels/binary_ops.py":111:40)
#loc17 = loc("examples/kernels/binary_ops.py":111:52)
#loc18 = loc("examples/kernels/binary_ops.py":111:22)
#loc19 = loc("examples/kernels/binary_ops.py":112:40)
#loc20 = loc("examples/kernels/binary_ops.py":112:52)
#loc21 = loc("examples/kernels/binary_ops.py":112:22)
#loc22 = loc("examples/kernels/binary_ops.py":114:31)
#loc23 = loc("examples/kernels/binary_ops.py":114:55)
#loc24 = loc("examples/kernels/binary_ops.py":114:37)
#loc25 = loc("examples/kernels/binary_ops.py":116:16)
#loc26 = loc("examples/kernels/binary_ops.py":117:16)
#loc27 = loc("examples/kernels/binary_ops.py":118:12)
#loc28 = loc("examples/kernels/binary_ops.py":119:21)
#loc29 = loc("examples/kernels/binary_ops.py":119:4)


// -----// IR Dump Before TritonGPUOptimizeAccumulatorInit (tritongpu-optimize-accumulator-init) ('builtin.module' operation) //----- //
#blocked = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>
#loc = loc("examples/kernels/binary_ops.py":97:0)
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.target = "cuda:89", "ttg.threads-per-warp" = 32 : i32} {
  tt.func public @add_2d_kernel(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg1: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg2: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg3: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg4: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg5: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg6: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg7: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0)) attributes {noinline = false} {
    %cst = arith.constant dense<0.000000e+00> : tensor<32x32xf32, #blocked> loc(#loc1)
    %c32_i32 = arith.constant 32 : i32 loc(#loc1)
    %0 = tt.get_program_id x : i32 loc(#loc2)
    %1 = tt.get_program_id y : i32 loc(#loc3)
    %2 = arith.muli %0, %c32_i32 : i32 loc(#loc4)
    %3 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc5)
    %4 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc5)
    %5 = tt.splat %2 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc6)
    %6 = arith.addi %5, %3 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc6)
    %7 = tt.splat %arg3 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc7)
    %8 = arith.remsi %6, %7 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc7)
    %9 = arith.muli %1, %c32_i32 : i32 loc(#loc8)
    %10 = tt.splat %9 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc9)
    %11 = arith.addi %10, %4 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc9)
    %12 = tt.splat %arg4 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc10)
    %13 = arith.remsi %11, %12 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc10)
    %14 = tt.expand_dims %8 {axis = 1 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> -> tensor<32x1xi32, #blocked> loc(#loc11)
    %15 = tt.splat %arg5 : i32 -> tensor<32x1xi32, #blocked> loc(#loc12)
    %16 = arith.muli %14, %15 : tensor<32x1xi32, #blocked> loc(#loc12)
    %17 = tt.expand_dims %13 {axis = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> -> tensor<1x32xi32, #blocked> loc(#loc13)
    %18 = tt.broadcast %16 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %19 = tt.broadcast %17 : tensor<1x32xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %20 = arith.addi %18, %19 : tensor<32x32xi32, #blocked> loc(#loc14)
    %21 = tt.splat %arg0 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc15)
    %22 = tt.addptr %21, %20 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc15)
    %23 = tt.splat %arg6 : i32 -> tensor<32x1xi32, #blocked> loc(#loc16)
    %24 = arith.muli %14, %23 : tensor<32x1xi32, #blocked> loc(#loc16)
    %25 = tt.broadcast %24 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc17)
    %26 = arith.addi %25, %19 : tensor<32x32xi32, #blocked> loc(#loc17)
    %27 = tt.splat %arg1 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc18)
    %28 = tt.addptr %27, %26 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc18)
    %29 = tt.splat %arg7 : i32 -> tensor<32x1xi32, #blocked> loc(#loc19)
    %30 = arith.muli %14, %29 : tensor<32x1xi32, #blocked> loc(#loc19)
    %31 = tt.broadcast %30 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc20)
    %32 = arith.addi %31, %19 : tensor<32x32xi32, #blocked> loc(#loc20)
    %33 = tt.splat %arg2 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc21)
    %34 = tt.addptr %33, %32 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc21)
    %35 = tt.splat %arg3 : i32 -> tensor<32x1xi32, #blocked> loc(#loc22)
    %36 = arith.cmpi slt, %14, %35 : tensor<32x1xi32, #blocked> loc(#loc22)
    %37 = tt.splat %arg4 : i32 -> tensor<1x32xi32, #blocked> loc(#loc23)
    %38 = arith.cmpi slt, %17, %37 : tensor<1x32xi32, #blocked> loc(#loc23)
    %39 = tt.broadcast %36 : tensor<32x1xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %40 = tt.broadcast %38 : tensor<1x32xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %41 = arith.andi %39, %40 : tensor<32x32xi1, #blocked> loc(#loc24)
    %42 = tt.load %22, %41, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc25)
    %43 = tt.load %28, %41, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc26)
    %44 = arith.addf %42, %43 : tensor<32x32xf32, #blocked> loc(#loc27)
    tt.store %34, %44, %41 : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc28)
    tt.return loc(#loc29)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("examples/kernels/binary_ops.py":106:26)
#loc3 = loc("examples/kernels/binary_ops.py":107:26)
#loc4 = loc("examples/kernels/binary_ops.py":108:22)
#loc5 = loc("examples/kernels/binary_ops.py":108:50)
#loc6 = loc("examples/kernels/binary_ops.py":108:37)
#loc7 = loc("examples/kernels/binary_ops.py":108:67)
#loc8 = loc("examples/kernels/binary_ops.py":109:22)
#loc9 = loc("examples/kernels/binary_ops.py":109:37)
#loc10 = loc("examples/kernels/binary_ops.py":109:67)
#loc11 = loc("examples/kernels/binary_ops.py":110:29)
#loc12 = loc("examples/kernels/binary_ops.py":110:40)
#loc13 = loc("examples/kernels/binary_ops.py":110:59)
#loc14 = loc("examples/kernels/binary_ops.py":110:52)
#loc15 = loc("examples/kernels/binary_ops.py":110:22)
#loc16 = loc("examples/kernels/binary_ops.py":111:40)
#loc17 = loc("examples/kernels/binary_ops.py":111:52)
#loc18 = loc("examples/kernels/binary_ops.py":111:22)
#loc19 = loc("examples/kernels/binary_ops.py":112:40)
#loc20 = loc("examples/kernels/binary_ops.py":112:52)
#loc21 = loc("examples/kernels/binary_ops.py":112:22)
#loc22 = loc("examples/kernels/binary_ops.py":114:31)
#loc23 = loc("examples/kernels/binary_ops.py":114:55)
#loc24 = loc("examples/kernels/binary_ops.py":114:37)
#loc25 = loc("examples/kernels/binary_ops.py":116:16)
#loc26 = loc("examples/kernels/binary_ops.py":117:16)
#loc27 = loc("examples/kernels/binary_ops.py":118:12)
#loc28 = loc("examples/kernels/binary_ops.py":119:21)
#loc29 = loc("examples/kernels/binary_ops.py":119:4)


// -----// IR Dump Before Canonicalizer (canonicalize) ('builtin.module' operation) //----- //
#blocked = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>
#loc = loc("examples/kernels/binary_ops.py":97:0)
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.target = "cuda:89", "ttg.threads-per-warp" = 32 : i32} {
  tt.func public @add_2d_kernel(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg1: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg2: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg3: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg4: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg5: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg6: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg7: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0)) attributes {noinline = false} {
    %cst = arith.constant dense<0.000000e+00> : tensor<32x32xf32, #blocked> loc(#loc1)
    %c32_i32 = arith.constant 32 : i32 loc(#loc1)
    %0 = tt.get_program_id x : i32 loc(#loc2)
    %1 = tt.get_program_id y : i32 loc(#loc3)
    %2 = arith.muli %0, %c32_i32 : i32 loc(#loc4)
    %3 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc5)
    %4 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc5)
    %5 = tt.splat %2 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc6)
    %6 = arith.addi %5, %3 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc6)
    %7 = tt.splat %arg3 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc7)
    %8 = arith.remsi %6, %7 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc7)
    %9 = arith.muli %1, %c32_i32 : i32 loc(#loc8)
    %10 = tt.splat %9 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc9)
    %11 = arith.addi %10, %4 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc9)
    %12 = tt.splat %arg4 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc10)
    %13 = arith.remsi %11, %12 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc10)
    %14 = tt.expand_dims %8 {axis = 1 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> -> tensor<32x1xi32, #blocked> loc(#loc11)
    %15 = tt.splat %arg5 : i32 -> tensor<32x1xi32, #blocked> loc(#loc12)
    %16 = arith.muli %14, %15 : tensor<32x1xi32, #blocked> loc(#loc12)
    %17 = tt.expand_dims %13 {axis = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> -> tensor<1x32xi32, #blocked> loc(#loc13)
    %18 = tt.broadcast %16 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %19 = tt.broadcast %17 : tensor<1x32xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %20 = arith.addi %18, %19 : tensor<32x32xi32, #blocked> loc(#loc14)
    %21 = tt.splat %arg0 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc15)
    %22 = tt.addptr %21, %20 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc15)
    %23 = tt.splat %arg6 : i32 -> tensor<32x1xi32, #blocked> loc(#loc16)
    %24 = arith.muli %14, %23 : tensor<32x1xi32, #blocked> loc(#loc16)
    %25 = tt.broadcast %24 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc17)
    %26 = arith.addi %25, %19 : tensor<32x32xi32, #blocked> loc(#loc17)
    %27 = tt.splat %arg1 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc18)
    %28 = tt.addptr %27, %26 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc18)
    %29 = tt.splat %arg7 : i32 -> tensor<32x1xi32, #blocked> loc(#loc19)
    %30 = arith.muli %14, %29 : tensor<32x1xi32, #blocked> loc(#loc19)
    %31 = tt.broadcast %30 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc20)
    %32 = arith.addi %31, %19 : tensor<32x32xi32, #blocked> loc(#loc20)
    %33 = tt.splat %arg2 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc21)
    %34 = tt.addptr %33, %32 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc21)
    %35 = tt.splat %arg3 : i32 -> tensor<32x1xi32, #blocked> loc(#loc22)
    %36 = arith.cmpi slt, %14, %35 : tensor<32x1xi32, #blocked> loc(#loc22)
    %37 = tt.splat %arg4 : i32 -> tensor<1x32xi32, #blocked> loc(#loc23)
    %38 = arith.cmpi slt, %17, %37 : tensor<1x32xi32, #blocked> loc(#loc23)
    %39 = tt.broadcast %36 : tensor<32x1xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %40 = tt.broadcast %38 : tensor<1x32xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %41 = arith.andi %39, %40 : tensor<32x32xi1, #blocked> loc(#loc24)
    %42 = tt.load %22, %41, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc25)
    %43 = tt.load %28, %41, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc26)
    %44 = arith.addf %42, %43 : tensor<32x32xf32, #blocked> loc(#loc27)
    tt.store %34, %44, %41 : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc28)
    tt.return loc(#loc29)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("examples/kernels/binary_ops.py":106:26)
#loc3 = loc("examples/kernels/binary_ops.py":107:26)
#loc4 = loc("examples/kernels/binary_ops.py":108:22)
#loc5 = loc("examples/kernels/binary_ops.py":108:50)
#loc6 = loc("examples/kernels/binary_ops.py":108:37)
#loc7 = loc("examples/kernels/binary_ops.py":108:67)
#loc8 = loc("examples/kernels/binary_ops.py":109:22)
#loc9 = loc("examples/kernels/binary_ops.py":109:37)
#loc10 = loc("examples/kernels/binary_ops.py":109:67)
#loc11 = loc("examples/kernels/binary_ops.py":110:29)
#loc12 = loc("examples/kernels/binary_ops.py":110:40)
#loc13 = loc("examples/kernels/binary_ops.py":110:59)
#loc14 = loc("examples/kernels/binary_ops.py":110:52)
#loc15 = loc("examples/kernels/binary_ops.py":110:22)
#loc16 = loc("examples/kernels/binary_ops.py":111:40)
#loc17 = loc("examples/kernels/binary_ops.py":111:52)
#loc18 = loc("examples/kernels/binary_ops.py":111:22)
#loc19 = loc("examples/kernels/binary_ops.py":112:40)
#loc20 = loc("examples/kernels/binary_ops.py":112:52)
#loc21 = loc("examples/kernels/binary_ops.py":112:22)
#loc22 = loc("examples/kernels/binary_ops.py":114:31)
#loc23 = loc("examples/kernels/binary_ops.py":114:55)
#loc24 = loc("examples/kernels/binary_ops.py":114:37)
#loc25 = loc("examples/kernels/binary_ops.py":116:16)
#loc26 = loc("examples/kernels/binary_ops.py":117:16)
#loc27 = loc("examples/kernels/binary_ops.py":118:12)
#loc28 = loc("examples/kernels/binary_ops.py":119:21)
#loc29 = loc("examples/kernels/binary_ops.py":119:4)


// -----// IR Dump Before TritonGPUCombineTensorSelectAndIf (tritongpu-combine-tensor-select-and-if) ('builtin.module' operation) //----- //
#blocked = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>
#loc = loc("examples/kernels/binary_ops.py":97:0)
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.target = "cuda:89", "ttg.threads-per-warp" = 32 : i32} {
  tt.func public @add_2d_kernel(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg1: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg2: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg3: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg4: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg5: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg6: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg7: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0)) attributes {noinline = false} {
    %cst = arith.constant dense<0.000000e+00> : tensor<32x32xf32, #blocked> loc(#loc1)
    %c32_i32 = arith.constant 32 : i32 loc(#loc1)
    %0 = tt.get_program_id x : i32 loc(#loc2)
    %1 = tt.get_program_id y : i32 loc(#loc3)
    %2 = arith.muli %0, %c32_i32 : i32 loc(#loc4)
    %3 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc5)
    %4 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc5)
    %5 = tt.splat %2 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc6)
    %6 = arith.addi %5, %3 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc6)
    %7 = tt.splat %arg3 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc7)
    %8 = arith.remsi %6, %7 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc7)
    %9 = arith.muli %1, %c32_i32 : i32 loc(#loc8)
    %10 = tt.splat %9 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc9)
    %11 = arith.addi %10, %4 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc9)
    %12 = tt.splat %arg4 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc10)
    %13 = arith.remsi %11, %12 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc10)
    %14 = tt.expand_dims %8 {axis = 1 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> -> tensor<32x1xi32, #blocked> loc(#loc11)
    %15 = tt.splat %arg5 : i32 -> tensor<32x1xi32, #blocked> loc(#loc12)
    %16 = arith.muli %14, %15 : tensor<32x1xi32, #blocked> loc(#loc12)
    %17 = tt.expand_dims %13 {axis = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> -> tensor<1x32xi32, #blocked> loc(#loc13)
    %18 = tt.broadcast %16 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %19 = tt.broadcast %17 : tensor<1x32xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %20 = arith.addi %18, %19 : tensor<32x32xi32, #blocked> loc(#loc14)
    %21 = tt.splat %arg0 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc15)
    %22 = tt.addptr %21, %20 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc15)
    %23 = tt.splat %arg6 : i32 -> tensor<32x1xi32, #blocked> loc(#loc16)
    %24 = arith.muli %14, %23 : tensor<32x1xi32, #blocked> loc(#loc16)
    %25 = tt.broadcast %24 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc17)
    %26 = arith.addi %25, %19 : tensor<32x32xi32, #blocked> loc(#loc17)
    %27 = tt.splat %arg1 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc18)
    %28 = tt.addptr %27, %26 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc18)
    %29 = tt.splat %arg7 : i32 -> tensor<32x1xi32, #blocked> loc(#loc19)
    %30 = arith.muli %14, %29 : tensor<32x1xi32, #blocked> loc(#loc19)
    %31 = tt.broadcast %30 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc20)
    %32 = arith.addi %31, %19 : tensor<32x32xi32, #blocked> loc(#loc20)
    %33 = tt.splat %arg2 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc21)
    %34 = tt.addptr %33, %32 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc21)
    %35 = tt.splat %arg3 : i32 -> tensor<32x1xi32, #blocked> loc(#loc22)
    %36 = arith.cmpi slt, %14, %35 : tensor<32x1xi32, #blocked> loc(#loc22)
    %37 = tt.splat %arg4 : i32 -> tensor<1x32xi32, #blocked> loc(#loc23)
    %38 = arith.cmpi slt, %17, %37 : tensor<1x32xi32, #blocked> loc(#loc23)
    %39 = tt.broadcast %36 : tensor<32x1xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %40 = tt.broadcast %38 : tensor<1x32xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %41 = arith.andi %39, %40 : tensor<32x32xi1, #blocked> loc(#loc24)
    %42 = tt.load %22, %41, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc25)
    %43 = tt.load %28, %41, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc26)
    %44 = arith.addf %42, %43 : tensor<32x32xf32, #blocked> loc(#loc27)
    tt.store %34, %44, %41 : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc28)
    tt.return loc(#loc29)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("examples/kernels/binary_ops.py":106:26)
#loc3 = loc("examples/kernels/binary_ops.py":107:26)
#loc4 = loc("examples/kernels/binary_ops.py":108:22)
#loc5 = loc("examples/kernels/binary_ops.py":108:50)
#loc6 = loc("examples/kernels/binary_ops.py":108:37)
#loc7 = loc("examples/kernels/binary_ops.py":108:67)
#loc8 = loc("examples/kernels/binary_ops.py":109:22)
#loc9 = loc("examples/kernels/binary_ops.py":109:37)
#loc10 = loc("examples/kernels/binary_ops.py":109:67)
#loc11 = loc("examples/kernels/binary_ops.py":110:29)
#loc12 = loc("examples/kernels/binary_ops.py":110:40)
#loc13 = loc("examples/kernels/binary_ops.py":110:59)
#loc14 = loc("examples/kernels/binary_ops.py":110:52)
#loc15 = loc("examples/kernels/binary_ops.py":110:22)
#loc16 = loc("examples/kernels/binary_ops.py":111:40)
#loc17 = loc("examples/kernels/binary_ops.py":111:52)
#loc18 = loc("examples/kernels/binary_ops.py":111:22)
#loc19 = loc("examples/kernels/binary_ops.py":112:40)
#loc20 = loc("examples/kernels/binary_ops.py":112:52)
#loc21 = loc("examples/kernels/binary_ops.py":112:22)
#loc22 = loc("examples/kernels/binary_ops.py":114:31)
#loc23 = loc("examples/kernels/binary_ops.py":114:55)
#loc24 = loc("examples/kernels/binary_ops.py":114:37)
#loc25 = loc("examples/kernels/binary_ops.py":116:16)
#loc26 = loc("examples/kernels/binary_ops.py":117:16)
#loc27 = loc("examples/kernels/binary_ops.py":118:12)
#loc28 = loc("examples/kernels/binary_ops.py":119:21)
#loc29 = loc("examples/kernels/binary_ops.py":119:4)


// -----// IR Dump Before TritonGPUWSTaskPartition (tritongpu-warp-spec-task-partition) ('builtin.module' operation) //----- //
#blocked = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>
#loc = loc("examples/kernels/binary_ops.py":97:0)
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.target = "cuda:89", "ttg.threads-per-warp" = 32 : i32} {
  tt.func public @add_2d_kernel(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg1: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg2: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg3: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg4: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg5: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg6: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg7: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0)) attributes {noinline = false} {
    %cst = arith.constant dense<0.000000e+00> : tensor<32x32xf32, #blocked> loc(#loc1)
    %c32_i32 = arith.constant 32 : i32 loc(#loc1)
    %0 = tt.get_program_id x : i32 loc(#loc2)
    %1 = tt.get_program_id y : i32 loc(#loc3)
    %2 = arith.muli %0, %c32_i32 : i32 loc(#loc4)
    %3 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc5)
    %4 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc5)
    %5 = tt.splat %2 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc6)
    %6 = arith.addi %5, %3 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc6)
    %7 = tt.splat %arg3 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc7)
    %8 = arith.remsi %6, %7 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc7)
    %9 = arith.muli %1, %c32_i32 : i32 loc(#loc8)
    %10 = tt.splat %9 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc9)
    %11 = arith.addi %10, %4 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc9)
    %12 = tt.splat %arg4 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc10)
    %13 = arith.remsi %11, %12 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc10)
    %14 = tt.expand_dims %8 {axis = 1 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> -> tensor<32x1xi32, #blocked> loc(#loc11)
    %15 = tt.splat %arg5 : i32 -> tensor<32x1xi32, #blocked> loc(#loc12)
    %16 = arith.muli %14, %15 : tensor<32x1xi32, #blocked> loc(#loc12)
    %17 = tt.expand_dims %13 {axis = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> -> tensor<1x32xi32, #blocked> loc(#loc13)
    %18 = tt.broadcast %16 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %19 = tt.broadcast %17 : tensor<1x32xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %20 = arith.addi %18, %19 : tensor<32x32xi32, #blocked> loc(#loc14)
    %21 = tt.splat %arg0 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc15)
    %22 = tt.addptr %21, %20 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc15)
    %23 = tt.splat %arg6 : i32 -> tensor<32x1xi32, #blocked> loc(#loc16)
    %24 = arith.muli %14, %23 : tensor<32x1xi32, #blocked> loc(#loc16)
    %25 = tt.broadcast %24 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc17)
    %26 = arith.addi %25, %19 : tensor<32x32xi32, #blocked> loc(#loc17)
    %27 = tt.splat %arg1 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc18)
    %28 = tt.addptr %27, %26 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc18)
    %29 = tt.splat %arg7 : i32 -> tensor<32x1xi32, #blocked> loc(#loc19)
    %30 = arith.muli %14, %29 : tensor<32x1xi32, #blocked> loc(#loc19)
    %31 = tt.broadcast %30 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc20)
    %32 = arith.addi %31, %19 : tensor<32x32xi32, #blocked> loc(#loc20)
    %33 = tt.splat %arg2 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc21)
    %34 = tt.addptr %33, %32 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc21)
    %35 = tt.splat %arg3 : i32 -> tensor<32x1xi32, #blocked> loc(#loc22)
    %36 = arith.cmpi slt, %14, %35 : tensor<32x1xi32, #blocked> loc(#loc22)
    %37 = tt.splat %arg4 : i32 -> tensor<1x32xi32, #blocked> loc(#loc23)
    %38 = arith.cmpi slt, %17, %37 : tensor<1x32xi32, #blocked> loc(#loc23)
    %39 = tt.broadcast %36 : tensor<32x1xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %40 = tt.broadcast %38 : tensor<1x32xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %41 = arith.andi %39, %40 : tensor<32x32xi1, #blocked> loc(#loc24)
    %42 = tt.load %22, %41, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc25)
    %43 = tt.load %28, %41, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc26)
    %44 = arith.addf %42, %43 : tensor<32x32xf32, #blocked> loc(#loc27)
    tt.store %34, %44, %41 : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc28)
    tt.return loc(#loc29)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("examples/kernels/binary_ops.py":106:26)
#loc3 = loc("examples/kernels/binary_ops.py":107:26)
#loc4 = loc("examples/kernels/binary_ops.py":108:22)
#loc5 = loc("examples/kernels/binary_ops.py":108:50)
#loc6 = loc("examples/kernels/binary_ops.py":108:37)
#loc7 = loc("examples/kernels/binary_ops.py":108:67)
#loc8 = loc("examples/kernels/binary_ops.py":109:22)
#loc9 = loc("examples/kernels/binary_ops.py":109:37)
#loc10 = loc("examples/kernels/binary_ops.py":109:67)
#loc11 = loc("examples/kernels/binary_ops.py":110:29)
#loc12 = loc("examples/kernels/binary_ops.py":110:40)
#loc13 = loc("examples/kernels/binary_ops.py":110:59)
#loc14 = loc("examples/kernels/binary_ops.py":110:52)
#loc15 = loc("examples/kernels/binary_ops.py":110:22)
#loc16 = loc("examples/kernels/binary_ops.py":111:40)
#loc17 = loc("examples/kernels/binary_ops.py":111:52)
#loc18 = loc("examples/kernels/binary_ops.py":111:22)
#loc19 = loc("examples/kernels/binary_ops.py":112:40)
#loc20 = loc("examples/kernels/binary_ops.py":112:52)
#loc21 = loc("examples/kernels/binary_ops.py":112:22)
#loc22 = loc("examples/kernels/binary_ops.py":114:31)
#loc23 = loc("examples/kernels/binary_ops.py":114:55)
#loc24 = loc("examples/kernels/binary_ops.py":114:37)
#loc25 = loc("examples/kernels/binary_ops.py":116:16)
#loc26 = loc("examples/kernels/binary_ops.py":117:16)
#loc27 = loc("examples/kernels/binary_ops.py":118:12)
#loc28 = loc("examples/kernels/binary_ops.py":119:21)
#loc29 = loc("examples/kernels/binary_ops.py":119:4)


// -----// IR Dump Before TritonGPUTaskIdPropagate (triton-gpu-taskid-propagate) ('builtin.module' operation) //----- //
#blocked = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>
#loc = loc("examples/kernels/binary_ops.py":97:0)
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.target = "cuda:89", "ttg.threads-per-warp" = 32 : i32} {
  tt.func public @add_2d_kernel(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg1: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg2: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg3: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg4: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg5: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg6: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg7: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0)) attributes {noinline = false} {
    %cst = arith.constant dense<0.000000e+00> : tensor<32x32xf32, #blocked> loc(#loc1)
    %c32_i32 = arith.constant 32 : i32 loc(#loc1)
    %0 = tt.get_program_id x : i32 loc(#loc2)
    %1 = tt.get_program_id y : i32 loc(#loc3)
    %2 = arith.muli %0, %c32_i32 : i32 loc(#loc4)
    %3 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc5)
    %4 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc5)
    %5 = tt.splat %2 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc6)
    %6 = arith.addi %5, %3 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc6)
    %7 = tt.splat %arg3 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc7)
    %8 = arith.remsi %6, %7 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc7)
    %9 = arith.muli %1, %c32_i32 : i32 loc(#loc8)
    %10 = tt.splat %9 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc9)
    %11 = arith.addi %10, %4 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc9)
    %12 = tt.splat %arg4 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc10)
    %13 = arith.remsi %11, %12 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc10)
    %14 = tt.expand_dims %8 {axis = 1 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> -> tensor<32x1xi32, #blocked> loc(#loc11)
    %15 = tt.splat %arg5 : i32 -> tensor<32x1xi32, #blocked> loc(#loc12)
    %16 = arith.muli %14, %15 : tensor<32x1xi32, #blocked> loc(#loc12)
    %17 = tt.expand_dims %13 {axis = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> -> tensor<1x32xi32, #blocked> loc(#loc13)
    %18 = tt.broadcast %16 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %19 = tt.broadcast %17 : tensor<1x32xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %20 = arith.addi %18, %19 : tensor<32x32xi32, #blocked> loc(#loc14)
    %21 = tt.splat %arg0 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc15)
    %22 = tt.addptr %21, %20 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc15)
    %23 = tt.splat %arg6 : i32 -> tensor<32x1xi32, #blocked> loc(#loc16)
    %24 = arith.muli %14, %23 : tensor<32x1xi32, #blocked> loc(#loc16)
    %25 = tt.broadcast %24 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc17)
    %26 = arith.addi %25, %19 : tensor<32x32xi32, #blocked> loc(#loc17)
    %27 = tt.splat %arg1 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc18)
    %28 = tt.addptr %27, %26 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc18)
    %29 = tt.splat %arg7 : i32 -> tensor<32x1xi32, #blocked> loc(#loc19)
    %30 = arith.muli %14, %29 : tensor<32x1xi32, #blocked> loc(#loc19)
    %31 = tt.broadcast %30 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc20)
    %32 = arith.addi %31, %19 : tensor<32x32xi32, #blocked> loc(#loc20)
    %33 = tt.splat %arg2 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc21)
    %34 = tt.addptr %33, %32 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc21)
    %35 = tt.splat %arg3 : i32 -> tensor<32x1xi32, #blocked> loc(#loc22)
    %36 = arith.cmpi slt, %14, %35 : tensor<32x1xi32, #blocked> loc(#loc22)
    %37 = tt.splat %arg4 : i32 -> tensor<1x32xi32, #blocked> loc(#loc23)
    %38 = arith.cmpi slt, %17, %37 : tensor<1x32xi32, #blocked> loc(#loc23)
    %39 = tt.broadcast %36 : tensor<32x1xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %40 = tt.broadcast %38 : tensor<1x32xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %41 = arith.andi %39, %40 : tensor<32x32xi1, #blocked> loc(#loc24)
    %42 = tt.load %22, %41, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc25)
    %43 = tt.load %28, %41, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc26)
    %44 = arith.addf %42, %43 : tensor<32x32xf32, #blocked> loc(#loc27)
    tt.store %34, %44, %41 : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc28)
    tt.return loc(#loc29)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("examples/kernels/binary_ops.py":106:26)
#loc3 = loc("examples/kernels/binary_ops.py":107:26)
#loc4 = loc("examples/kernels/binary_ops.py":108:22)
#loc5 = loc("examples/kernels/binary_ops.py":108:50)
#loc6 = loc("examples/kernels/binary_ops.py":108:37)
#loc7 = loc("examples/kernels/binary_ops.py":108:67)
#loc8 = loc("examples/kernels/binary_ops.py":109:22)
#loc9 = loc("examples/kernels/binary_ops.py":109:37)
#loc10 = loc("examples/kernels/binary_ops.py":109:67)
#loc11 = loc("examples/kernels/binary_ops.py":110:29)
#loc12 = loc("examples/kernels/binary_ops.py":110:40)
#loc13 = loc("examples/kernels/binary_ops.py":110:59)
#loc14 = loc("examples/kernels/binary_ops.py":110:52)
#loc15 = loc("examples/kernels/binary_ops.py":110:22)
#loc16 = loc("examples/kernels/binary_ops.py":111:40)
#loc17 = loc("examples/kernels/binary_ops.py":111:52)
#loc18 = loc("examples/kernels/binary_ops.py":111:22)
#loc19 = loc("examples/kernels/binary_ops.py":112:40)
#loc20 = loc("examples/kernels/binary_ops.py":112:52)
#loc21 = loc("examples/kernels/binary_ops.py":112:22)
#loc22 = loc("examples/kernels/binary_ops.py":114:31)
#loc23 = loc("examples/kernels/binary_ops.py":114:55)
#loc24 = loc("examples/kernels/binary_ops.py":114:37)
#loc25 = loc("examples/kernels/binary_ops.py":116:16)
#loc26 = loc("examples/kernels/binary_ops.py":117:16)
#loc27 = loc("examples/kernels/binary_ops.py":118:12)
#loc28 = loc("examples/kernels/binary_ops.py":119:21)
#loc29 = loc("examples/kernels/binary_ops.py":119:4)


// -----// IR Dump Before TritonGPUWSDataPartition (tritongpu-warp-spec-data-partition) ('builtin.module' operation) //----- //
#blocked = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>
#loc = loc("examples/kernels/binary_ops.py":97:0)
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.target = "cuda:89", "ttg.threads-per-warp" = 32 : i32} {
  tt.func public @add_2d_kernel(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg1: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg2: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg3: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg4: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg5: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg6: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg7: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0)) attributes {noinline = false} {
    %cst = arith.constant dense<0.000000e+00> : tensor<32x32xf32, #blocked> loc(#loc1)
    %c32_i32 = arith.constant 32 : i32 loc(#loc1)
    %0 = tt.get_program_id x : i32 loc(#loc2)
    %1 = tt.get_program_id y : i32 loc(#loc3)
    %2 = arith.muli %0, %c32_i32 : i32 loc(#loc4)
    %3 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc5)
    %4 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc5)
    %5 = tt.splat %2 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc6)
    %6 = arith.addi %5, %3 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc6)
    %7 = tt.splat %arg3 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc7)
    %8 = arith.remsi %6, %7 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc7)
    %9 = arith.muli %1, %c32_i32 : i32 loc(#loc8)
    %10 = tt.splat %9 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc9)
    %11 = arith.addi %10, %4 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc9)
    %12 = tt.splat %arg4 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc10)
    %13 = arith.remsi %11, %12 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc10)
    %14 = tt.expand_dims %8 {axis = 1 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> -> tensor<32x1xi32, #blocked> loc(#loc11)
    %15 = tt.splat %arg5 : i32 -> tensor<32x1xi32, #blocked> loc(#loc12)
    %16 = arith.muli %14, %15 : tensor<32x1xi32, #blocked> loc(#loc12)
    %17 = tt.expand_dims %13 {axis = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> -> tensor<1x32xi32, #blocked> loc(#loc13)
    %18 = tt.broadcast %16 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %19 = tt.broadcast %17 : tensor<1x32xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %20 = arith.addi %18, %19 : tensor<32x32xi32, #blocked> loc(#loc14)
    %21 = tt.splat %arg0 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc15)
    %22 = tt.addptr %21, %20 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc15)
    %23 = tt.splat %arg6 : i32 -> tensor<32x1xi32, #blocked> loc(#loc16)
    %24 = arith.muli %14, %23 : tensor<32x1xi32, #blocked> loc(#loc16)
    %25 = tt.broadcast %24 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc17)
    %26 = arith.addi %25, %19 : tensor<32x32xi32, #blocked> loc(#loc17)
    %27 = tt.splat %arg1 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc18)
    %28 = tt.addptr %27, %26 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc18)
    %29 = tt.splat %arg7 : i32 -> tensor<32x1xi32, #blocked> loc(#loc19)
    %30 = arith.muli %14, %29 : tensor<32x1xi32, #blocked> loc(#loc19)
    %31 = tt.broadcast %30 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc20)
    %32 = arith.addi %31, %19 : tensor<32x32xi32, #blocked> loc(#loc20)
    %33 = tt.splat %arg2 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc21)
    %34 = tt.addptr %33, %32 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc21)
    %35 = tt.splat %arg3 : i32 -> tensor<32x1xi32, #blocked> loc(#loc22)
    %36 = arith.cmpi slt, %14, %35 : tensor<32x1xi32, #blocked> loc(#loc22)
    %37 = tt.splat %arg4 : i32 -> tensor<1x32xi32, #blocked> loc(#loc23)
    %38 = arith.cmpi slt, %17, %37 : tensor<1x32xi32, #blocked> loc(#loc23)
    %39 = tt.broadcast %36 : tensor<32x1xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %40 = tt.broadcast %38 : tensor<1x32xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %41 = arith.andi %39, %40 : tensor<32x32xi1, #blocked> loc(#loc24)
    %42 = tt.load %22, %41, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc25)
    %43 = tt.load %28, %41, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc26)
    %44 = arith.addf %42, %43 : tensor<32x32xf32, #blocked> loc(#loc27)
    tt.store %34, %44, %41 : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc28)
    tt.return loc(#loc29)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("examples/kernels/binary_ops.py":106:26)
#loc3 = loc("examples/kernels/binary_ops.py":107:26)
#loc4 = loc("examples/kernels/binary_ops.py":108:22)
#loc5 = loc("examples/kernels/binary_ops.py":108:50)
#loc6 = loc("examples/kernels/binary_ops.py":108:37)
#loc7 = loc("examples/kernels/binary_ops.py":108:67)
#loc8 = loc("examples/kernels/binary_ops.py":109:22)
#loc9 = loc("examples/kernels/binary_ops.py":109:37)
#loc10 = loc("examples/kernels/binary_ops.py":109:67)
#loc11 = loc("examples/kernels/binary_ops.py":110:29)
#loc12 = loc("examples/kernels/binary_ops.py":110:40)
#loc13 = loc("examples/kernels/binary_ops.py":110:59)
#loc14 = loc("examples/kernels/binary_ops.py":110:52)
#loc15 = loc("examples/kernels/binary_ops.py":110:22)
#loc16 = loc("examples/kernels/binary_ops.py":111:40)
#loc17 = loc("examples/kernels/binary_ops.py":111:52)
#loc18 = loc("examples/kernels/binary_ops.py":111:22)
#loc19 = loc("examples/kernels/binary_ops.py":112:40)
#loc20 = loc("examples/kernels/binary_ops.py":112:52)
#loc21 = loc("examples/kernels/binary_ops.py":112:22)
#loc22 = loc("examples/kernels/binary_ops.py":114:31)
#loc23 = loc("examples/kernels/binary_ops.py":114:55)
#loc24 = loc("examples/kernels/binary_ops.py":114:37)
#loc25 = loc("examples/kernels/binary_ops.py":116:16)
#loc26 = loc("examples/kernels/binary_ops.py":117:16)
#loc27 = loc("examples/kernels/binary_ops.py":118:12)
#loc28 = loc("examples/kernels/binary_ops.py":119:21)
#loc29 = loc("examples/kernels/binary_ops.py":119:4)


// -----// IR Dump Before TritonGPUWSCodePartition (tritongpu-warp-spec-code-partition) ('builtin.module' operation) //----- //
#blocked = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>
#loc = loc("examples/kernels/binary_ops.py":97:0)
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.target = "cuda:89", "ttg.threads-per-warp" = 32 : i32} {
  tt.func public @add_2d_kernel(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg1: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg2: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg3: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg4: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg5: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg6: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg7: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0)) attributes {noinline = false} {
    %cst = arith.constant dense<0.000000e+00> : tensor<32x32xf32, #blocked> loc(#loc1)
    %c32_i32 = arith.constant 32 : i32 loc(#loc1)
    %0 = tt.get_program_id x : i32 loc(#loc2)
    %1 = tt.get_program_id y : i32 loc(#loc3)
    %2 = arith.muli %0, %c32_i32 : i32 loc(#loc4)
    %3 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc5)
    %4 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc5)
    %5 = tt.splat %2 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc6)
    %6 = arith.addi %5, %3 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc6)
    %7 = tt.splat %arg3 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc7)
    %8 = arith.remsi %6, %7 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc7)
    %9 = arith.muli %1, %c32_i32 : i32 loc(#loc8)
    %10 = tt.splat %9 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc9)
    %11 = arith.addi %10, %4 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc9)
    %12 = tt.splat %arg4 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc10)
    %13 = arith.remsi %11, %12 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc10)
    %14 = tt.expand_dims %8 {axis = 1 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> -> tensor<32x1xi32, #blocked> loc(#loc11)
    %15 = tt.splat %arg5 : i32 -> tensor<32x1xi32, #blocked> loc(#loc12)
    %16 = arith.muli %14, %15 : tensor<32x1xi32, #blocked> loc(#loc12)
    %17 = tt.expand_dims %13 {axis = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> -> tensor<1x32xi32, #blocked> loc(#loc13)
    %18 = tt.broadcast %16 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %19 = tt.broadcast %17 : tensor<1x32xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %20 = arith.addi %18, %19 : tensor<32x32xi32, #blocked> loc(#loc14)
    %21 = tt.splat %arg0 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc15)
    %22 = tt.addptr %21, %20 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc15)
    %23 = tt.splat %arg6 : i32 -> tensor<32x1xi32, #blocked> loc(#loc16)
    %24 = arith.muli %14, %23 : tensor<32x1xi32, #blocked> loc(#loc16)
    %25 = tt.broadcast %24 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc17)
    %26 = arith.addi %25, %19 : tensor<32x32xi32, #blocked> loc(#loc17)
    %27 = tt.splat %arg1 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc18)
    %28 = tt.addptr %27, %26 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc18)
    %29 = tt.splat %arg7 : i32 -> tensor<32x1xi32, #blocked> loc(#loc19)
    %30 = arith.muli %14, %29 : tensor<32x1xi32, #blocked> loc(#loc19)
    %31 = tt.broadcast %30 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc20)
    %32 = arith.addi %31, %19 : tensor<32x32xi32, #blocked> loc(#loc20)
    %33 = tt.splat %arg2 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc21)
    %34 = tt.addptr %33, %32 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc21)
    %35 = tt.splat %arg3 : i32 -> tensor<32x1xi32, #blocked> loc(#loc22)
    %36 = arith.cmpi slt, %14, %35 : tensor<32x1xi32, #blocked> loc(#loc22)
    %37 = tt.splat %arg4 : i32 -> tensor<1x32xi32, #blocked> loc(#loc23)
    %38 = arith.cmpi slt, %17, %37 : tensor<1x32xi32, #blocked> loc(#loc23)
    %39 = tt.broadcast %36 : tensor<32x1xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %40 = tt.broadcast %38 : tensor<1x32xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %41 = arith.andi %39, %40 : tensor<32x32xi1, #blocked> loc(#loc24)
    %42 = tt.load %22, %41, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc25)
    %43 = tt.load %28, %41, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc26)
    %44 = arith.addf %42, %43 : tensor<32x32xf32, #blocked> loc(#loc27)
    tt.store %34, %44, %41 : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc28)
    tt.return loc(#loc29)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("examples/kernels/binary_ops.py":106:26)
#loc3 = loc("examples/kernels/binary_ops.py":107:26)
#loc4 = loc("examples/kernels/binary_ops.py":108:22)
#loc5 = loc("examples/kernels/binary_ops.py":108:50)
#loc6 = loc("examples/kernels/binary_ops.py":108:37)
#loc7 = loc("examples/kernels/binary_ops.py":108:67)
#loc8 = loc("examples/kernels/binary_ops.py":109:22)
#loc9 = loc("examples/kernels/binary_ops.py":109:37)
#loc10 = loc("examples/kernels/binary_ops.py":109:67)
#loc11 = loc("examples/kernels/binary_ops.py":110:29)
#loc12 = loc("examples/kernels/binary_ops.py":110:40)
#loc13 = loc("examples/kernels/binary_ops.py":110:59)
#loc14 = loc("examples/kernels/binary_ops.py":110:52)
#loc15 = loc("examples/kernels/binary_ops.py":110:22)
#loc16 = loc("examples/kernels/binary_ops.py":111:40)
#loc17 = loc("examples/kernels/binary_ops.py":111:52)
#loc18 = loc("examples/kernels/binary_ops.py":111:22)
#loc19 = loc("examples/kernels/binary_ops.py":112:40)
#loc20 = loc("examples/kernels/binary_ops.py":112:52)
#loc21 = loc("examples/kernels/binary_ops.py":112:22)
#loc22 = loc("examples/kernels/binary_ops.py":114:31)
#loc23 = loc("examples/kernels/binary_ops.py":114:55)
#loc24 = loc("examples/kernels/binary_ops.py":114:37)
#loc25 = loc("examples/kernels/binary_ops.py":116:16)
#loc26 = loc("examples/kernels/binary_ops.py":117:16)
#loc27 = loc("examples/kernels/binary_ops.py":118:12)
#loc28 = loc("examples/kernels/binary_ops.py":119:21)
#loc29 = loc("examples/kernels/binary_ops.py":119:4)


// -----// IR Dump Before TritonGPUPipeline (tritongpu-pipeline) ('builtin.module' operation) //----- //
#blocked = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>
#loc = loc("examples/kernels/binary_ops.py":97:0)
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.target = "cuda:89", "ttg.threads-per-warp" = 32 : i32} {
  tt.func public @add_2d_kernel(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg1: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg2: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg3: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg4: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg5: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg6: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg7: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0)) attributes {noinline = false} {
    %cst = arith.constant dense<0.000000e+00> : tensor<32x32xf32, #blocked> loc(#loc1)
    %c32_i32 = arith.constant 32 : i32 loc(#loc1)
    %0 = tt.get_program_id x : i32 loc(#loc2)
    %1 = tt.get_program_id y : i32 loc(#loc3)
    %2 = arith.muli %0, %c32_i32 : i32 loc(#loc4)
    %3 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc5)
    %4 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc5)
    %5 = tt.splat %2 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc6)
    %6 = arith.addi %5, %3 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc6)
    %7 = tt.splat %arg3 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc7)
    %8 = arith.remsi %6, %7 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc7)
    %9 = arith.muli %1, %c32_i32 : i32 loc(#loc8)
    %10 = tt.splat %9 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc9)
    %11 = arith.addi %10, %4 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc9)
    %12 = tt.splat %arg4 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc10)
    %13 = arith.remsi %11, %12 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc10)
    %14 = tt.expand_dims %8 {axis = 1 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> -> tensor<32x1xi32, #blocked> loc(#loc11)
    %15 = tt.splat %arg5 : i32 -> tensor<32x1xi32, #blocked> loc(#loc12)
    %16 = arith.muli %14, %15 : tensor<32x1xi32, #blocked> loc(#loc12)
    %17 = tt.expand_dims %13 {axis = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> -> tensor<1x32xi32, #blocked> loc(#loc13)
    %18 = tt.broadcast %16 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %19 = tt.broadcast %17 : tensor<1x32xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %20 = arith.addi %18, %19 : tensor<32x32xi32, #blocked> loc(#loc14)
    %21 = tt.splat %arg0 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc15)
    %22 = tt.addptr %21, %20 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc15)
    %23 = tt.splat %arg6 : i32 -> tensor<32x1xi32, #blocked> loc(#loc16)
    %24 = arith.muli %14, %23 : tensor<32x1xi32, #blocked> loc(#loc16)
    %25 = tt.broadcast %24 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc17)
    %26 = arith.addi %25, %19 : tensor<32x32xi32, #blocked> loc(#loc17)
    %27 = tt.splat %arg1 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc18)
    %28 = tt.addptr %27, %26 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc18)
    %29 = tt.splat %arg7 : i32 -> tensor<32x1xi32, #blocked> loc(#loc19)
    %30 = arith.muli %14, %29 : tensor<32x1xi32, #blocked> loc(#loc19)
    %31 = tt.broadcast %30 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc20)
    %32 = arith.addi %31, %19 : tensor<32x32xi32, #blocked> loc(#loc20)
    %33 = tt.splat %arg2 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc21)
    %34 = tt.addptr %33, %32 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc21)
    %35 = tt.splat %arg3 : i32 -> tensor<32x1xi32, #blocked> loc(#loc22)
    %36 = arith.cmpi slt, %14, %35 : tensor<32x1xi32, #blocked> loc(#loc22)
    %37 = tt.splat %arg4 : i32 -> tensor<1x32xi32, #blocked> loc(#loc23)
    %38 = arith.cmpi slt, %17, %37 : tensor<1x32xi32, #blocked> loc(#loc23)
    %39 = tt.broadcast %36 : tensor<32x1xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %40 = tt.broadcast %38 : tensor<1x32xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %41 = arith.andi %39, %40 : tensor<32x32xi1, #blocked> loc(#loc24)
    %42 = tt.load %22, %41, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc25)
    %43 = tt.load %28, %41, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc26)
    %44 = arith.addf %42, %43 : tensor<32x32xf32, #blocked> loc(#loc27)
    tt.store %34, %44, %41 : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc28)
    tt.return loc(#loc29)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("examples/kernels/binary_ops.py":106:26)
#loc3 = loc("examples/kernels/binary_ops.py":107:26)
#loc4 = loc("examples/kernels/binary_ops.py":108:22)
#loc5 = loc("examples/kernels/binary_ops.py":108:50)
#loc6 = loc("examples/kernels/binary_ops.py":108:37)
#loc7 = loc("examples/kernels/binary_ops.py":108:67)
#loc8 = loc("examples/kernels/binary_ops.py":109:22)
#loc9 = loc("examples/kernels/binary_ops.py":109:37)
#loc10 = loc("examples/kernels/binary_ops.py":109:67)
#loc11 = loc("examples/kernels/binary_ops.py":110:29)
#loc12 = loc("examples/kernels/binary_ops.py":110:40)
#loc13 = loc("examples/kernels/binary_ops.py":110:59)
#loc14 = loc("examples/kernels/binary_ops.py":110:52)
#loc15 = loc("examples/kernels/binary_ops.py":110:22)
#loc16 = loc("examples/kernels/binary_ops.py":111:40)
#loc17 = loc("examples/kernels/binary_ops.py":111:52)
#loc18 = loc("examples/kernels/binary_ops.py":111:22)
#loc19 = loc("examples/kernels/binary_ops.py":112:40)
#loc20 = loc("examples/kernels/binary_ops.py":112:52)
#loc21 = loc("examples/kernels/binary_ops.py":112:22)
#loc22 = loc("examples/kernels/binary_ops.py":114:31)
#loc23 = loc("examples/kernels/binary_ops.py":114:55)
#loc24 = loc("examples/kernels/binary_ops.py":114:37)
#loc25 = loc("examples/kernels/binary_ops.py":116:16)
#loc26 = loc("examples/kernels/binary_ops.py":117:16)
#loc27 = loc("examples/kernels/binary_ops.py":118:12)
#loc28 = loc("examples/kernels/binary_ops.py":119:21)
#loc29 = loc("examples/kernels/binary_ops.py":119:4)


// -----// SoftwarePipeliner internal IR Dump After: AssignLatencies
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.target = "cuda:89", "ttg.threads-per-warp" = 32 : i32} {
  tt.func public @add_2d_kernel(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %arg1: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %arg2: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %arg3: i32 {tt.divisibility = 16 : i32}, %arg4: i32 {tt.divisibility = 16 : i32}, %arg5: i32 {tt.divisibility = 16 : i32}, %arg6: i32 {tt.divisibility = 16 : i32}, %arg7: i32 {tt.divisibility = 16 : i32}) attributes {noinline = false} {
    %cst = arith.constant dense<0.000000e+00> : tensor<32x32xf32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %c32_i32 = arith.constant 32 : i32
    %0 = tt.get_program_id x : i32
    %1 = tt.get_program_id y : i32
    %2 = arith.muli %0, %c32_i32 : i32
    %3 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>}>>
    %4 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>}>>
    %5 = tt.splat %2 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>}>>
    %6 = arith.addi %5, %3 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>}>>
    %7 = tt.splat %arg3 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>}>>
    %8 = arith.remsi %6, %7 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>}>>
    %9 = arith.muli %1, %c32_i32 : i32
    %10 = tt.splat %9 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>}>>
    %11 = arith.addi %10, %4 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>}>>
    %12 = tt.splat %arg4 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>}>>
    %13 = arith.remsi %11, %12 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>}>>
    %14 = tt.expand_dims %8 {axis = 1 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>}>> -> tensor<32x1xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %15 = tt.splat %arg5 : i32 -> tensor<32x1xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %16 = arith.muli %14, %15 : tensor<32x1xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %17 = tt.expand_dims %13 {axis = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>}>> -> tensor<1x32xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %18 = tt.broadcast %16 : tensor<32x1xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>> -> tensor<32x32xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %19 = tt.broadcast %17 : tensor<1x32xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>> -> tensor<32x32xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %20 = arith.addi %18, %19 : tensor<32x32xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %21 = tt.splat %arg0 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %22 = tt.addptr %21, %20 : tensor<32x32x!tt.ptr<f32>, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>, tensor<32x32xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %23 = tt.splat %arg6 : i32 -> tensor<32x1xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %24 = arith.muli %14, %23 : tensor<32x1xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %25 = tt.broadcast %24 : tensor<32x1xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>> -> tensor<32x32xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %26 = arith.addi %25, %19 : tensor<32x32xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %27 = tt.splat %arg1 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %28 = tt.addptr %27, %26 : tensor<32x32x!tt.ptr<f32>, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>, tensor<32x32xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %29 = tt.splat %arg7 : i32 -> tensor<32x1xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %30 = arith.muli %14, %29 : tensor<32x1xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %31 = tt.broadcast %30 : tensor<32x1xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>> -> tensor<32x32xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %32 = arith.addi %31, %19 : tensor<32x32xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %33 = tt.splat %arg2 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %34 = tt.addptr %33, %32 : tensor<32x32x!tt.ptr<f32>, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>, tensor<32x32xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %35 = tt.splat %arg3 : i32 -> tensor<32x1xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %36 = arith.cmpi slt, %14, %35 : tensor<32x1xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %37 = tt.splat %arg4 : i32 -> tensor<1x32xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %38 = arith.cmpi slt, %17, %37 : tensor<1x32xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %39 = tt.broadcast %36 : tensor<32x1xi1, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>> -> tensor<32x32xi1, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %40 = tt.broadcast %38 : tensor<1x32xi1, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>> -> tensor<32x32xi1, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %41 = arith.andi %39, %40 : tensor<32x32xi1, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %42 = tt.load %22, %41, %cst : tensor<32x32x!tt.ptr<f32>, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %43 = tt.load %28, %41, %cst : tensor<32x32x!tt.ptr<f32>, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %44 = arith.addf %42, %43 : tensor<32x32xf32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    tt.store %34, %44, %41 : tensor<32x32x!tt.ptr<f32>, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    tt.return
  }
}


// -----// SoftwarePipeliner internal IR Dump After: ScheduleLoops
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.target = "cuda:89", "ttg.threads-per-warp" = 32 : i32} {
  tt.func public @add_2d_kernel(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %arg1: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %arg2: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %arg3: i32 {tt.divisibility = 16 : i32}, %arg4: i32 {tt.divisibility = 16 : i32}, %arg5: i32 {tt.divisibility = 16 : i32}, %arg6: i32 {tt.divisibility = 16 : i32}, %arg7: i32 {tt.divisibility = 16 : i32}) attributes {noinline = false} {
    %cst = arith.constant dense<0.000000e+00> : tensor<32x32xf32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %c32_i32 = arith.constant 32 : i32
    %0 = tt.get_program_id x : i32
    %1 = tt.get_program_id y : i32
    %2 = arith.muli %0, %c32_i32 : i32
    %3 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>}>>
    %4 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>}>>
    %5 = tt.splat %2 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>}>>
    %6 = arith.addi %5, %3 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>}>>
    %7 = tt.splat %arg3 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>}>>
    %8 = arith.remsi %6, %7 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>}>>
    %9 = arith.muli %1, %c32_i32 : i32
    %10 = tt.splat %9 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>}>>
    %11 = arith.addi %10, %4 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>}>>
    %12 = tt.splat %arg4 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>}>>
    %13 = arith.remsi %11, %12 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>}>>
    %14 = tt.expand_dims %8 {axis = 1 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>}>> -> tensor<32x1xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %15 = tt.splat %arg5 : i32 -> tensor<32x1xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %16 = arith.muli %14, %15 : tensor<32x1xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %17 = tt.expand_dims %13 {axis = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>}>> -> tensor<1x32xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %18 = tt.broadcast %16 : tensor<32x1xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>> -> tensor<32x32xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %19 = tt.broadcast %17 : tensor<1x32xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>> -> tensor<32x32xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %20 = arith.addi %18, %19 : tensor<32x32xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %21 = tt.splat %arg0 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %22 = tt.addptr %21, %20 : tensor<32x32x!tt.ptr<f32>, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>, tensor<32x32xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %23 = tt.splat %arg6 : i32 -> tensor<32x1xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %24 = arith.muli %14, %23 : tensor<32x1xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %25 = tt.broadcast %24 : tensor<32x1xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>> -> tensor<32x32xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %26 = arith.addi %25, %19 : tensor<32x32xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %27 = tt.splat %arg1 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %28 = tt.addptr %27, %26 : tensor<32x32x!tt.ptr<f32>, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>, tensor<32x32xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %29 = tt.splat %arg7 : i32 -> tensor<32x1xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %30 = arith.muli %14, %29 : tensor<32x1xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %31 = tt.broadcast %30 : tensor<32x1xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>> -> tensor<32x32xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %32 = arith.addi %31, %19 : tensor<32x32xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %33 = tt.splat %arg2 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %34 = tt.addptr %33, %32 : tensor<32x32x!tt.ptr<f32>, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>, tensor<32x32xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %35 = tt.splat %arg3 : i32 -> tensor<32x1xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %36 = arith.cmpi slt, %14, %35 : tensor<32x1xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %37 = tt.splat %arg4 : i32 -> tensor<1x32xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %38 = arith.cmpi slt, %17, %37 : tensor<1x32xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %39 = tt.broadcast %36 : tensor<32x1xi1, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>> -> tensor<32x32xi1, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %40 = tt.broadcast %38 : tensor<1x32xi1, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>> -> tensor<32x32xi1, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %41 = arith.andi %39, %40 : tensor<32x32xi1, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %42 = tt.load %22, %41, %cst : tensor<32x32x!tt.ptr<f32>, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %43 = tt.load %28, %41, %cst : tensor<32x32x!tt.ptr<f32>, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %44 = arith.addf %42, %43 : tensor<32x32xf32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    tt.store %34, %44, %41 : tensor<32x32x!tt.ptr<f32>, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    tt.return
  }
}


// -----// SoftwarePipeliner internal IR Dump After: LowerLoops
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.target = "cuda:89", "ttg.threads-per-warp" = 32 : i32} {
  tt.func public @add_2d_kernel(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %arg1: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %arg2: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %arg3: i32 {tt.divisibility = 16 : i32}, %arg4: i32 {tt.divisibility = 16 : i32}, %arg5: i32 {tt.divisibility = 16 : i32}, %arg6: i32 {tt.divisibility = 16 : i32}, %arg7: i32 {tt.divisibility = 16 : i32}) attributes {noinline = false} {
    %cst = arith.constant dense<0.000000e+00> : tensor<32x32xf32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %c32_i32 = arith.constant 32 : i32
    %0 = tt.get_program_id x : i32
    %1 = tt.get_program_id y : i32
    %2 = arith.muli %0, %c32_i32 : i32
    %3 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>}>>
    %4 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>}>>
    %5 = tt.splat %2 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>}>>
    %6 = arith.addi %5, %3 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>}>>
    %7 = tt.splat %arg3 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>}>>
    %8 = arith.remsi %6, %7 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>}>>
    %9 = arith.muli %1, %c32_i32 : i32
    %10 = tt.splat %9 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>}>>
    %11 = arith.addi %10, %4 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>}>>
    %12 = tt.splat %arg4 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>}>>
    %13 = arith.remsi %11, %12 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>}>>
    %14 = tt.expand_dims %8 {axis = 1 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>}>> -> tensor<32x1xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %15 = tt.splat %arg5 : i32 -> tensor<32x1xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %16 = arith.muli %14, %15 : tensor<32x1xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %17 = tt.expand_dims %13 {axis = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>}>> -> tensor<1x32xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %18 = tt.broadcast %16 : tensor<32x1xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>> -> tensor<32x32xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %19 = tt.broadcast %17 : tensor<1x32xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>> -> tensor<32x32xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %20 = arith.addi %18, %19 : tensor<32x32xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %21 = tt.splat %arg0 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %22 = tt.addptr %21, %20 : tensor<32x32x!tt.ptr<f32>, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>, tensor<32x32xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %23 = tt.splat %arg6 : i32 -> tensor<32x1xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %24 = arith.muli %14, %23 : tensor<32x1xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %25 = tt.broadcast %24 : tensor<32x1xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>> -> tensor<32x32xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %26 = arith.addi %25, %19 : tensor<32x32xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %27 = tt.splat %arg1 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %28 = tt.addptr %27, %26 : tensor<32x32x!tt.ptr<f32>, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>, tensor<32x32xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %29 = tt.splat %arg7 : i32 -> tensor<32x1xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %30 = arith.muli %14, %29 : tensor<32x1xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %31 = tt.broadcast %30 : tensor<32x1xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>> -> tensor<32x32xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %32 = arith.addi %31, %19 : tensor<32x32xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %33 = tt.splat %arg2 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %34 = tt.addptr %33, %32 : tensor<32x32x!tt.ptr<f32>, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>, tensor<32x32xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %35 = tt.splat %arg3 : i32 -> tensor<32x1xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %36 = arith.cmpi slt, %14, %35 : tensor<32x1xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %37 = tt.splat %arg4 : i32 -> tensor<1x32xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %38 = arith.cmpi slt, %17, %37 : tensor<1x32xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %39 = tt.broadcast %36 : tensor<32x1xi1, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>> -> tensor<32x32xi1, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %40 = tt.broadcast %38 : tensor<1x32xi1, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>> -> tensor<32x32xi1, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %41 = arith.andi %39, %40 : tensor<32x32xi1, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %42 = tt.load %22, %41, %cst : tensor<32x32x!tt.ptr<f32>, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %43 = tt.load %28, %41, %cst : tensor<32x32x!tt.ptr<f32>, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %44 = arith.addf %42, %43 : tensor<32x32xf32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    tt.store %34, %44, %41 : tensor<32x32x!tt.ptr<f32>, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    tt.return
  }
}


// -----// SoftwarePipeliner internal IR Dump After: ExpandLoops
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.target = "cuda:89", "ttg.threads-per-warp" = 32 : i32} {
  tt.func public @add_2d_kernel(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %arg1: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %arg2: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %arg3: i32 {tt.divisibility = 16 : i32}, %arg4: i32 {tt.divisibility = 16 : i32}, %arg5: i32 {tt.divisibility = 16 : i32}, %arg6: i32 {tt.divisibility = 16 : i32}, %arg7: i32 {tt.divisibility = 16 : i32}) attributes {noinline = false} {
    %cst = arith.constant dense<0.000000e+00> : tensor<32x32xf32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %c32_i32 = arith.constant 32 : i32
    %0 = tt.get_program_id x : i32
    %1 = tt.get_program_id y : i32
    %2 = arith.muli %0, %c32_i32 : i32
    %3 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>}>>
    %4 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>}>>
    %5 = tt.splat %2 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>}>>
    %6 = arith.addi %5, %3 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>}>>
    %7 = tt.splat %arg3 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>}>>
    %8 = arith.remsi %6, %7 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>}>>
    %9 = arith.muli %1, %c32_i32 : i32
    %10 = tt.splat %9 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>}>>
    %11 = arith.addi %10, %4 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>}>>
    %12 = tt.splat %arg4 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>}>>
    %13 = arith.remsi %11, %12 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>}>>
    %14 = tt.expand_dims %8 {axis = 1 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>}>> -> tensor<32x1xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %15 = tt.splat %arg5 : i32 -> tensor<32x1xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %16 = arith.muli %14, %15 : tensor<32x1xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %17 = tt.expand_dims %13 {axis = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>}>> -> tensor<1x32xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %18 = tt.broadcast %16 : tensor<32x1xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>> -> tensor<32x32xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %19 = tt.broadcast %17 : tensor<1x32xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>> -> tensor<32x32xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %20 = arith.addi %18, %19 : tensor<32x32xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %21 = tt.splat %arg0 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %22 = tt.addptr %21, %20 : tensor<32x32x!tt.ptr<f32>, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>, tensor<32x32xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %23 = tt.splat %arg6 : i32 -> tensor<32x1xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %24 = arith.muli %14, %23 : tensor<32x1xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %25 = tt.broadcast %24 : tensor<32x1xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>> -> tensor<32x32xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %26 = arith.addi %25, %19 : tensor<32x32xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %27 = tt.splat %arg1 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %28 = tt.addptr %27, %26 : tensor<32x32x!tt.ptr<f32>, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>, tensor<32x32xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %29 = tt.splat %arg7 : i32 -> tensor<32x1xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %30 = arith.muli %14, %29 : tensor<32x1xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %31 = tt.broadcast %30 : tensor<32x1xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>> -> tensor<32x32xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %32 = arith.addi %31, %19 : tensor<32x32xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %33 = tt.splat %arg2 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %34 = tt.addptr %33, %32 : tensor<32x32x!tt.ptr<f32>, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>, tensor<32x32xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %35 = tt.splat %arg3 : i32 -> tensor<32x1xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %36 = arith.cmpi slt, %14, %35 : tensor<32x1xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %37 = tt.splat %arg4 : i32 -> tensor<1x32xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %38 = arith.cmpi slt, %17, %37 : tensor<1x32xi32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %39 = tt.broadcast %36 : tensor<32x1xi1, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>> -> tensor<32x32xi1, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %40 = tt.broadcast %38 : tensor<1x32xi1, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>> -> tensor<32x32xi1, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %41 = arith.andi %39, %40 : tensor<32x32xi1, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %42 = tt.load %22, %41, %cst : tensor<32x32x!tt.ptr<f32>, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %43 = tt.load %28, %41, %cst : tensor<32x32x!tt.ptr<f32>, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    %44 = arith.addf %42, %43 : tensor<32x32xf32, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    tt.store %34, %44, %41 : tensor<32x32x!tt.ptr<f32>, #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>>
    tt.return
  }
}


// -----// IR Dump Before TritonGPUPingPongSync (tritongpu-ping-pong-sync) ('builtin.module' operation) //----- //
#blocked = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>
#loc = loc("examples/kernels/binary_ops.py":97:0)
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.target = "cuda:89", "ttg.threads-per-warp" = 32 : i32} {
  tt.func public @add_2d_kernel(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg1: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg2: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg3: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg4: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg5: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg6: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg7: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0)) attributes {noinline = false} {
    %cst = arith.constant dense<0.000000e+00> : tensor<32x32xf32, #blocked> loc(#loc1)
    %c32_i32 = arith.constant 32 : i32 loc(#loc1)
    %0 = tt.get_program_id x : i32 loc(#loc2)
    %1 = tt.get_program_id y : i32 loc(#loc3)
    %2 = arith.muli %0, %c32_i32 : i32 loc(#loc4)
    %3 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc5)
    %4 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc5)
    %5 = tt.splat %2 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc6)
    %6 = arith.addi %5, %3 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc6)
    %7 = tt.splat %arg3 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc7)
    %8 = arith.remsi %6, %7 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc7)
    %9 = arith.muli %1, %c32_i32 : i32 loc(#loc8)
    %10 = tt.splat %9 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc9)
    %11 = arith.addi %10, %4 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc9)
    %12 = tt.splat %arg4 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc10)
    %13 = arith.remsi %11, %12 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc10)
    %14 = tt.expand_dims %8 {axis = 1 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> -> tensor<32x1xi32, #blocked> loc(#loc11)
    %15 = tt.splat %arg5 : i32 -> tensor<32x1xi32, #blocked> loc(#loc12)
    %16 = arith.muli %14, %15 : tensor<32x1xi32, #blocked> loc(#loc12)
    %17 = tt.expand_dims %13 {axis = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> -> tensor<1x32xi32, #blocked> loc(#loc13)
    %18 = tt.broadcast %16 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %19 = tt.broadcast %17 : tensor<1x32xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %20 = arith.addi %18, %19 : tensor<32x32xi32, #blocked> loc(#loc14)
    %21 = tt.splat %arg0 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc15)
    %22 = tt.addptr %21, %20 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc15)
    %23 = tt.splat %arg6 : i32 -> tensor<32x1xi32, #blocked> loc(#loc16)
    %24 = arith.muli %14, %23 : tensor<32x1xi32, #blocked> loc(#loc16)
    %25 = tt.broadcast %24 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc17)
    %26 = arith.addi %25, %19 : tensor<32x32xi32, #blocked> loc(#loc17)
    %27 = tt.splat %arg1 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc18)
    %28 = tt.addptr %27, %26 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc18)
    %29 = tt.splat %arg7 : i32 -> tensor<32x1xi32, #blocked> loc(#loc19)
    %30 = arith.muli %14, %29 : tensor<32x1xi32, #blocked> loc(#loc19)
    %31 = tt.broadcast %30 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc20)
    %32 = arith.addi %31, %19 : tensor<32x32xi32, #blocked> loc(#loc20)
    %33 = tt.splat %arg2 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc21)
    %34 = tt.addptr %33, %32 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc21)
    %35 = tt.splat %arg3 : i32 -> tensor<32x1xi32, #blocked> loc(#loc22)
    %36 = arith.cmpi slt, %14, %35 : tensor<32x1xi32, #blocked> loc(#loc22)
    %37 = tt.splat %arg4 : i32 -> tensor<1x32xi32, #blocked> loc(#loc23)
    %38 = arith.cmpi slt, %17, %37 : tensor<1x32xi32, #blocked> loc(#loc23)
    %39 = tt.broadcast %36 : tensor<32x1xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %40 = tt.broadcast %38 : tensor<1x32xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %41 = arith.andi %39, %40 : tensor<32x32xi1, #blocked> loc(#loc24)
    %42 = tt.load %22, %41, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc25)
    %43 = tt.load %28, %41, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc26)
    %44 = arith.addf %42, %43 : tensor<32x32xf32, #blocked> loc(#loc27)
    tt.store %34, %44, %41 : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc28)
    tt.return loc(#loc29)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("examples/kernels/binary_ops.py":106:26)
#loc3 = loc("examples/kernels/binary_ops.py":107:26)
#loc4 = loc("examples/kernels/binary_ops.py":108:22)
#loc5 = loc("examples/kernels/binary_ops.py":108:50)
#loc6 = loc("examples/kernels/binary_ops.py":108:37)
#loc7 = loc("examples/kernels/binary_ops.py":108:67)
#loc8 = loc("examples/kernels/binary_ops.py":109:22)
#loc9 = loc("examples/kernels/binary_ops.py":109:37)
#loc10 = loc("examples/kernels/binary_ops.py":109:67)
#loc11 = loc("examples/kernels/binary_ops.py":110:29)
#loc12 = loc("examples/kernels/binary_ops.py":110:40)
#loc13 = loc("examples/kernels/binary_ops.py":110:59)
#loc14 = loc("examples/kernels/binary_ops.py":110:52)
#loc15 = loc("examples/kernels/binary_ops.py":110:22)
#loc16 = loc("examples/kernels/binary_ops.py":111:40)
#loc17 = loc("examples/kernels/binary_ops.py":111:52)
#loc18 = loc("examples/kernels/binary_ops.py":111:22)
#loc19 = loc("examples/kernels/binary_ops.py":112:40)
#loc20 = loc("examples/kernels/binary_ops.py":112:52)
#loc21 = loc("examples/kernels/binary_ops.py":112:22)
#loc22 = loc("examples/kernels/binary_ops.py":114:31)
#loc23 = loc("examples/kernels/binary_ops.py":114:55)
#loc24 = loc("examples/kernels/binary_ops.py":114:37)
#loc25 = loc("examples/kernels/binary_ops.py":116:16)
#loc26 = loc("examples/kernels/binary_ops.py":117:16)
#loc27 = loc("examples/kernels/binary_ops.py":118:12)
#loc28 = loc("examples/kernels/binary_ops.py":119:21)
#loc29 = loc("examples/kernels/binary_ops.py":119:4)


// -----// IR Dump Before TritonGPUWSLowering (tritongpu-warp-spec-lowering) ('builtin.module' operation) //----- //
#blocked = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>
#loc = loc("examples/kernels/binary_ops.py":97:0)
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.target = "cuda:89", "ttg.threads-per-warp" = 32 : i32} {
  tt.func public @add_2d_kernel(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg1: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg2: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg3: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg4: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg5: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg6: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg7: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0)) attributes {noinline = false} {
    %cst = arith.constant dense<0.000000e+00> : tensor<32x32xf32, #blocked> loc(#loc1)
    %c32_i32 = arith.constant 32 : i32 loc(#loc1)
    %0 = tt.get_program_id x : i32 loc(#loc2)
    %1 = tt.get_program_id y : i32 loc(#loc3)
    %2 = arith.muli %0, %c32_i32 : i32 loc(#loc4)
    %3 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc5)
    %4 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc5)
    %5 = tt.splat %2 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc6)
    %6 = arith.addi %5, %3 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc6)
    %7 = tt.splat %arg3 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc7)
    %8 = arith.remsi %6, %7 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc7)
    %9 = arith.muli %1, %c32_i32 : i32 loc(#loc8)
    %10 = tt.splat %9 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc9)
    %11 = arith.addi %10, %4 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc9)
    %12 = tt.splat %arg4 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc10)
    %13 = arith.remsi %11, %12 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc10)
    %14 = tt.expand_dims %8 {axis = 1 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> -> tensor<32x1xi32, #blocked> loc(#loc11)
    %15 = tt.splat %arg5 : i32 -> tensor<32x1xi32, #blocked> loc(#loc12)
    %16 = arith.muli %14, %15 : tensor<32x1xi32, #blocked> loc(#loc12)
    %17 = tt.expand_dims %13 {axis = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> -> tensor<1x32xi32, #blocked> loc(#loc13)
    %18 = tt.broadcast %16 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %19 = tt.broadcast %17 : tensor<1x32xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %20 = arith.addi %18, %19 : tensor<32x32xi32, #blocked> loc(#loc14)
    %21 = tt.splat %arg0 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc15)
    %22 = tt.addptr %21, %20 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc15)
    %23 = tt.splat %arg6 : i32 -> tensor<32x1xi32, #blocked> loc(#loc16)
    %24 = arith.muli %14, %23 : tensor<32x1xi32, #blocked> loc(#loc16)
    %25 = tt.broadcast %24 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc17)
    %26 = arith.addi %25, %19 : tensor<32x32xi32, #blocked> loc(#loc17)
    %27 = tt.splat %arg1 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc18)
    %28 = tt.addptr %27, %26 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc18)
    %29 = tt.splat %arg7 : i32 -> tensor<32x1xi32, #blocked> loc(#loc19)
    %30 = arith.muli %14, %29 : tensor<32x1xi32, #blocked> loc(#loc19)
    %31 = tt.broadcast %30 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc20)
    %32 = arith.addi %31, %19 : tensor<32x32xi32, #blocked> loc(#loc20)
    %33 = tt.splat %arg2 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc21)
    %34 = tt.addptr %33, %32 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc21)
    %35 = tt.splat %arg3 : i32 -> tensor<32x1xi32, #blocked> loc(#loc22)
    %36 = arith.cmpi slt, %14, %35 : tensor<32x1xi32, #blocked> loc(#loc22)
    %37 = tt.splat %arg4 : i32 -> tensor<1x32xi32, #blocked> loc(#loc23)
    %38 = arith.cmpi slt, %17, %37 : tensor<1x32xi32, #blocked> loc(#loc23)
    %39 = tt.broadcast %36 : tensor<32x1xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %40 = tt.broadcast %38 : tensor<1x32xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %41 = arith.andi %39, %40 : tensor<32x32xi1, #blocked> loc(#loc24)
    %42 = tt.load %22, %41, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc25)
    %43 = tt.load %28, %41, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc26)
    %44 = arith.addf %42, %43 : tensor<32x32xf32, #blocked> loc(#loc27)
    tt.store %34, %44, %41 : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc28)
    tt.return loc(#loc29)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("examples/kernels/binary_ops.py":106:26)
#loc3 = loc("examples/kernels/binary_ops.py":107:26)
#loc4 = loc("examples/kernels/binary_ops.py":108:22)
#loc5 = loc("examples/kernels/binary_ops.py":108:50)
#loc6 = loc("examples/kernels/binary_ops.py":108:37)
#loc7 = loc("examples/kernels/binary_ops.py":108:67)
#loc8 = loc("examples/kernels/binary_ops.py":109:22)
#loc9 = loc("examples/kernels/binary_ops.py":109:37)
#loc10 = loc("examples/kernels/binary_ops.py":109:67)
#loc11 = loc("examples/kernels/binary_ops.py":110:29)
#loc12 = loc("examples/kernels/binary_ops.py":110:40)
#loc13 = loc("examples/kernels/binary_ops.py":110:59)
#loc14 = loc("examples/kernels/binary_ops.py":110:52)
#loc15 = loc("examples/kernels/binary_ops.py":110:22)
#loc16 = loc("examples/kernels/binary_ops.py":111:40)
#loc17 = loc("examples/kernels/binary_ops.py":111:52)
#loc18 = loc("examples/kernels/binary_ops.py":111:22)
#loc19 = loc("examples/kernels/binary_ops.py":112:40)
#loc20 = loc("examples/kernels/binary_ops.py":112:52)
#loc21 = loc("examples/kernels/binary_ops.py":112:22)
#loc22 = loc("examples/kernels/binary_ops.py":114:31)
#loc23 = loc("examples/kernels/binary_ops.py":114:55)
#loc24 = loc("examples/kernels/binary_ops.py":114:37)
#loc25 = loc("examples/kernels/binary_ops.py":116:16)
#loc26 = loc("examples/kernels/binary_ops.py":117:16)
#loc27 = loc("examples/kernels/binary_ops.py":118:12)
#loc28 = loc("examples/kernels/binary_ops.py":119:21)
#loc29 = loc("examples/kernels/binary_ops.py":119:4)


// -----// IR Dump Before TritonGPUPrefetch (tritongpu-prefetch) ('builtin.module' operation) //----- //
#blocked = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>
#loc = loc("examples/kernels/binary_ops.py":97:0)
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.target = "cuda:89", "ttg.threads-per-warp" = 32 : i32} {
  tt.func public @add_2d_kernel(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg1: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg2: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg3: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg4: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg5: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg6: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg7: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0)) attributes {noinline = false} {
    %cst = arith.constant dense<0.000000e+00> : tensor<32x32xf32, #blocked> loc(#loc1)
    %c32_i32 = arith.constant 32 : i32 loc(#loc1)
    %0 = tt.get_program_id x : i32 loc(#loc2)
    %1 = tt.get_program_id y : i32 loc(#loc3)
    %2 = arith.muli %0, %c32_i32 : i32 loc(#loc4)
    %3 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc5)
    %4 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc5)
    %5 = tt.splat %2 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc6)
    %6 = arith.addi %5, %3 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc6)
    %7 = tt.splat %arg3 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc7)
    %8 = arith.remsi %6, %7 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc7)
    %9 = arith.muli %1, %c32_i32 : i32 loc(#loc8)
    %10 = tt.splat %9 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc9)
    %11 = arith.addi %10, %4 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc9)
    %12 = tt.splat %arg4 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc10)
    %13 = arith.remsi %11, %12 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc10)
    %14 = tt.expand_dims %8 {axis = 1 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> -> tensor<32x1xi32, #blocked> loc(#loc11)
    %15 = tt.splat %arg5 : i32 -> tensor<32x1xi32, #blocked> loc(#loc12)
    %16 = arith.muli %14, %15 : tensor<32x1xi32, #blocked> loc(#loc12)
    %17 = tt.expand_dims %13 {axis = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> -> tensor<1x32xi32, #blocked> loc(#loc13)
    %18 = tt.broadcast %16 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %19 = tt.broadcast %17 : tensor<1x32xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %20 = arith.addi %18, %19 : tensor<32x32xi32, #blocked> loc(#loc14)
    %21 = tt.splat %arg0 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc15)
    %22 = tt.addptr %21, %20 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc15)
    %23 = tt.splat %arg6 : i32 -> tensor<32x1xi32, #blocked> loc(#loc16)
    %24 = arith.muli %14, %23 : tensor<32x1xi32, #blocked> loc(#loc16)
    %25 = tt.broadcast %24 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc17)
    %26 = arith.addi %25, %19 : tensor<32x32xi32, #blocked> loc(#loc17)
    %27 = tt.splat %arg1 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc18)
    %28 = tt.addptr %27, %26 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc18)
    %29 = tt.splat %arg7 : i32 -> tensor<32x1xi32, #blocked> loc(#loc19)
    %30 = arith.muli %14, %29 : tensor<32x1xi32, #blocked> loc(#loc19)
    %31 = tt.broadcast %30 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc20)
    %32 = arith.addi %31, %19 : tensor<32x32xi32, #blocked> loc(#loc20)
    %33 = tt.splat %arg2 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc21)
    %34 = tt.addptr %33, %32 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc21)
    %35 = tt.splat %arg3 : i32 -> tensor<32x1xi32, #blocked> loc(#loc22)
    %36 = arith.cmpi slt, %14, %35 : tensor<32x1xi32, #blocked> loc(#loc22)
    %37 = tt.splat %arg4 : i32 -> tensor<1x32xi32, #blocked> loc(#loc23)
    %38 = arith.cmpi slt, %17, %37 : tensor<1x32xi32, #blocked> loc(#loc23)
    %39 = tt.broadcast %36 : tensor<32x1xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %40 = tt.broadcast %38 : tensor<1x32xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %41 = arith.andi %39, %40 : tensor<32x32xi1, #blocked> loc(#loc24)
    %42 = tt.load %22, %41, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc25)
    %43 = tt.load %28, %41, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc26)
    %44 = arith.addf %42, %43 : tensor<32x32xf32, #blocked> loc(#loc27)
    tt.store %34, %44, %41 : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc28)
    tt.return loc(#loc29)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("examples/kernels/binary_ops.py":106:26)
#loc3 = loc("examples/kernels/binary_ops.py":107:26)
#loc4 = loc("examples/kernels/binary_ops.py":108:22)
#loc5 = loc("examples/kernels/binary_ops.py":108:50)
#loc6 = loc("examples/kernels/binary_ops.py":108:37)
#loc7 = loc("examples/kernels/binary_ops.py":108:67)
#loc8 = loc("examples/kernels/binary_ops.py":109:22)
#loc9 = loc("examples/kernels/binary_ops.py":109:37)
#loc10 = loc("examples/kernels/binary_ops.py":109:67)
#loc11 = loc("examples/kernels/binary_ops.py":110:29)
#loc12 = loc("examples/kernels/binary_ops.py":110:40)
#loc13 = loc("examples/kernels/binary_ops.py":110:59)
#loc14 = loc("examples/kernels/binary_ops.py":110:52)
#loc15 = loc("examples/kernels/binary_ops.py":110:22)
#loc16 = loc("examples/kernels/binary_ops.py":111:40)
#loc17 = loc("examples/kernels/binary_ops.py":111:52)
#loc18 = loc("examples/kernels/binary_ops.py":111:22)
#loc19 = loc("examples/kernels/binary_ops.py":112:40)
#loc20 = loc("examples/kernels/binary_ops.py":112:52)
#loc21 = loc("examples/kernels/binary_ops.py":112:22)
#loc22 = loc("examples/kernels/binary_ops.py":114:31)
#loc23 = loc("examples/kernels/binary_ops.py":114:55)
#loc24 = loc("examples/kernels/binary_ops.py":114:37)
#loc25 = loc("examples/kernels/binary_ops.py":116:16)
#loc26 = loc("examples/kernels/binary_ops.py":117:16)
#loc27 = loc("examples/kernels/binary_ops.py":118:12)
#loc28 = loc("examples/kernels/binary_ops.py":119:21)
#loc29 = loc("examples/kernels/binary_ops.py":119:4)


// -----// IR Dump Before TritonGPUOptimizeDotOperands (tritongpu-optimize-dot-operands) ('builtin.module' operation) //----- //
#blocked = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>
#loc = loc("examples/kernels/binary_ops.py":97:0)
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.target = "cuda:89", "ttg.threads-per-warp" = 32 : i32} {
  tt.func public @add_2d_kernel(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg1: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg2: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg3: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg4: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg5: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg6: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg7: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0)) attributes {noinline = false} {
    %cst = arith.constant dense<0.000000e+00> : tensor<32x32xf32, #blocked> loc(#loc1)
    %c32_i32 = arith.constant 32 : i32 loc(#loc1)
    %0 = tt.get_program_id x : i32 loc(#loc2)
    %1 = tt.get_program_id y : i32 loc(#loc3)
    %2 = arith.muli %0, %c32_i32 : i32 loc(#loc4)
    %3 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc5)
    %4 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc5)
    %5 = tt.splat %2 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc6)
    %6 = arith.addi %5, %3 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc6)
    %7 = tt.splat %arg3 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc7)
    %8 = arith.remsi %6, %7 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc7)
    %9 = arith.muli %1, %c32_i32 : i32 loc(#loc8)
    %10 = tt.splat %9 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc9)
    %11 = arith.addi %10, %4 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc9)
    %12 = tt.splat %arg4 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc10)
    %13 = arith.remsi %11, %12 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc10)
    %14 = tt.expand_dims %8 {axis = 1 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> -> tensor<32x1xi32, #blocked> loc(#loc11)
    %15 = tt.splat %arg5 : i32 -> tensor<32x1xi32, #blocked> loc(#loc12)
    %16 = arith.muli %14, %15 : tensor<32x1xi32, #blocked> loc(#loc12)
    %17 = tt.expand_dims %13 {axis = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> -> tensor<1x32xi32, #blocked> loc(#loc13)
    %18 = tt.broadcast %16 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %19 = tt.broadcast %17 : tensor<1x32xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %20 = arith.addi %18, %19 : tensor<32x32xi32, #blocked> loc(#loc14)
    %21 = tt.splat %arg0 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc15)
    %22 = tt.addptr %21, %20 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc15)
    %23 = tt.splat %arg6 : i32 -> tensor<32x1xi32, #blocked> loc(#loc16)
    %24 = arith.muli %14, %23 : tensor<32x1xi32, #blocked> loc(#loc16)
    %25 = tt.broadcast %24 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc17)
    %26 = arith.addi %25, %19 : tensor<32x32xi32, #blocked> loc(#loc17)
    %27 = tt.splat %arg1 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc18)
    %28 = tt.addptr %27, %26 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc18)
    %29 = tt.splat %arg7 : i32 -> tensor<32x1xi32, #blocked> loc(#loc19)
    %30 = arith.muli %14, %29 : tensor<32x1xi32, #blocked> loc(#loc19)
    %31 = tt.broadcast %30 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc20)
    %32 = arith.addi %31, %19 : tensor<32x32xi32, #blocked> loc(#loc20)
    %33 = tt.splat %arg2 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc21)
    %34 = tt.addptr %33, %32 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc21)
    %35 = tt.splat %arg3 : i32 -> tensor<32x1xi32, #blocked> loc(#loc22)
    %36 = arith.cmpi slt, %14, %35 : tensor<32x1xi32, #blocked> loc(#loc22)
    %37 = tt.splat %arg4 : i32 -> tensor<1x32xi32, #blocked> loc(#loc23)
    %38 = arith.cmpi slt, %17, %37 : tensor<1x32xi32, #blocked> loc(#loc23)
    %39 = tt.broadcast %36 : tensor<32x1xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %40 = tt.broadcast %38 : tensor<1x32xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %41 = arith.andi %39, %40 : tensor<32x32xi1, #blocked> loc(#loc24)
    %42 = tt.load %22, %41, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc25)
    %43 = tt.load %28, %41, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc26)
    %44 = arith.addf %42, %43 : tensor<32x32xf32, #blocked> loc(#loc27)
    tt.store %34, %44, %41 : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc28)
    tt.return loc(#loc29)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("examples/kernels/binary_ops.py":106:26)
#loc3 = loc("examples/kernels/binary_ops.py":107:26)
#loc4 = loc("examples/kernels/binary_ops.py":108:22)
#loc5 = loc("examples/kernels/binary_ops.py":108:50)
#loc6 = loc("examples/kernels/binary_ops.py":108:37)
#loc7 = loc("examples/kernels/binary_ops.py":108:67)
#loc8 = loc("examples/kernels/binary_ops.py":109:22)
#loc9 = loc("examples/kernels/binary_ops.py":109:37)
#loc10 = loc("examples/kernels/binary_ops.py":109:67)
#loc11 = loc("examples/kernels/binary_ops.py":110:29)
#loc12 = loc("examples/kernels/binary_ops.py":110:40)
#loc13 = loc("examples/kernels/binary_ops.py":110:59)
#loc14 = loc("examples/kernels/binary_ops.py":110:52)
#loc15 = loc("examples/kernels/binary_ops.py":110:22)
#loc16 = loc("examples/kernels/binary_ops.py":111:40)
#loc17 = loc("examples/kernels/binary_ops.py":111:52)
#loc18 = loc("examples/kernels/binary_ops.py":111:22)
#loc19 = loc("examples/kernels/binary_ops.py":112:40)
#loc20 = loc("examples/kernels/binary_ops.py":112:52)
#loc21 = loc("examples/kernels/binary_ops.py":112:22)
#loc22 = loc("examples/kernels/binary_ops.py":114:31)
#loc23 = loc("examples/kernels/binary_ops.py":114:55)
#loc24 = loc("examples/kernels/binary_ops.py":114:37)
#loc25 = loc("examples/kernels/binary_ops.py":116:16)
#loc26 = loc("examples/kernels/binary_ops.py":117:16)
#loc27 = loc("examples/kernels/binary_ops.py":118:12)
#loc28 = loc("examples/kernels/binary_ops.py":119:21)
#loc29 = loc("examples/kernels/binary_ops.py":119:4)


// -----// IR Dump Before Canonicalizer (canonicalize) ('builtin.module' operation) //----- //
#blocked = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>
#loc = loc("examples/kernels/binary_ops.py":97:0)
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.target = "cuda:89", "ttg.threads-per-warp" = 32 : i32} {
  tt.func public @add_2d_kernel(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg1: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg2: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg3: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg4: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg5: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg6: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg7: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0)) attributes {noinline = false} {
    %cst = arith.constant dense<0.000000e+00> : tensor<32x32xf32, #blocked> loc(#loc1)
    %c32_i32 = arith.constant 32 : i32 loc(#loc1)
    %0 = tt.get_program_id x : i32 loc(#loc2)
    %1 = tt.get_program_id y : i32 loc(#loc3)
    %2 = arith.muli %0, %c32_i32 : i32 loc(#loc4)
    %3 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc5)
    %4 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc5)
    %5 = tt.splat %2 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc6)
    %6 = arith.addi %5, %3 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc6)
    %7 = tt.splat %arg3 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc7)
    %8 = arith.remsi %6, %7 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc7)
    %9 = arith.muli %1, %c32_i32 : i32 loc(#loc8)
    %10 = tt.splat %9 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc9)
    %11 = arith.addi %10, %4 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc9)
    %12 = tt.splat %arg4 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc10)
    %13 = arith.remsi %11, %12 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc10)
    %14 = tt.expand_dims %8 {axis = 1 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> -> tensor<32x1xi32, #blocked> loc(#loc11)
    %15 = tt.splat %arg5 : i32 -> tensor<32x1xi32, #blocked> loc(#loc12)
    %16 = arith.muli %14, %15 : tensor<32x1xi32, #blocked> loc(#loc12)
    %17 = tt.expand_dims %13 {axis = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> -> tensor<1x32xi32, #blocked> loc(#loc13)
    %18 = tt.broadcast %16 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %19 = tt.broadcast %17 : tensor<1x32xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %20 = arith.addi %18, %19 : tensor<32x32xi32, #blocked> loc(#loc14)
    %21 = tt.splat %arg0 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc15)
    %22 = tt.addptr %21, %20 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc15)
    %23 = tt.splat %arg6 : i32 -> tensor<32x1xi32, #blocked> loc(#loc16)
    %24 = arith.muli %14, %23 : tensor<32x1xi32, #blocked> loc(#loc16)
    %25 = tt.broadcast %24 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc17)
    %26 = arith.addi %25, %19 : tensor<32x32xi32, #blocked> loc(#loc17)
    %27 = tt.splat %arg1 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc18)
    %28 = tt.addptr %27, %26 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc18)
    %29 = tt.splat %arg7 : i32 -> tensor<32x1xi32, #blocked> loc(#loc19)
    %30 = arith.muli %14, %29 : tensor<32x1xi32, #blocked> loc(#loc19)
    %31 = tt.broadcast %30 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc20)
    %32 = arith.addi %31, %19 : tensor<32x32xi32, #blocked> loc(#loc20)
    %33 = tt.splat %arg2 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc21)
    %34 = tt.addptr %33, %32 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc21)
    %35 = tt.splat %arg3 : i32 -> tensor<32x1xi32, #blocked> loc(#loc22)
    %36 = arith.cmpi slt, %14, %35 : tensor<32x1xi32, #blocked> loc(#loc22)
    %37 = tt.splat %arg4 : i32 -> tensor<1x32xi32, #blocked> loc(#loc23)
    %38 = arith.cmpi slt, %17, %37 : tensor<1x32xi32, #blocked> loc(#loc23)
    %39 = tt.broadcast %36 : tensor<32x1xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %40 = tt.broadcast %38 : tensor<1x32xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %41 = arith.andi %39, %40 : tensor<32x32xi1, #blocked> loc(#loc24)
    %42 = tt.load %22, %41, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc25)
    %43 = tt.load %28, %41, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc26)
    %44 = arith.addf %42, %43 : tensor<32x32xf32, #blocked> loc(#loc27)
    tt.store %34, %44, %41 : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc28)
    tt.return loc(#loc29)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("examples/kernels/binary_ops.py":106:26)
#loc3 = loc("examples/kernels/binary_ops.py":107:26)
#loc4 = loc("examples/kernels/binary_ops.py":108:22)
#loc5 = loc("examples/kernels/binary_ops.py":108:50)
#loc6 = loc("examples/kernels/binary_ops.py":108:37)
#loc7 = loc("examples/kernels/binary_ops.py":108:67)
#loc8 = loc("examples/kernels/binary_ops.py":109:22)
#loc9 = loc("examples/kernels/binary_ops.py":109:37)
#loc10 = loc("examples/kernels/binary_ops.py":109:67)
#loc11 = loc("examples/kernels/binary_ops.py":110:29)
#loc12 = loc("examples/kernels/binary_ops.py":110:40)
#loc13 = loc("examples/kernels/binary_ops.py":110:59)
#loc14 = loc("examples/kernels/binary_ops.py":110:52)
#loc15 = loc("examples/kernels/binary_ops.py":110:22)
#loc16 = loc("examples/kernels/binary_ops.py":111:40)
#loc17 = loc("examples/kernels/binary_ops.py":111:52)
#loc18 = loc("examples/kernels/binary_ops.py":111:22)
#loc19 = loc("examples/kernels/binary_ops.py":112:40)
#loc20 = loc("examples/kernels/binary_ops.py":112:52)
#loc21 = loc("examples/kernels/binary_ops.py":112:22)
#loc22 = loc("examples/kernels/binary_ops.py":114:31)
#loc23 = loc("examples/kernels/binary_ops.py":114:55)
#loc24 = loc("examples/kernels/binary_ops.py":114:37)
#loc25 = loc("examples/kernels/binary_ops.py":116:16)
#loc26 = loc("examples/kernels/binary_ops.py":117:16)
#loc27 = loc("examples/kernels/binary_ops.py":118:12)
#loc28 = loc("examples/kernels/binary_ops.py":119:21)
#loc29 = loc("examples/kernels/binary_ops.py":119:4)


// -----// IR Dump Before TritonGPUCoalesceAsyncCopy (tritongpu-coalesce-async-copy) ('builtin.module' operation) //----- //
#blocked = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>
#loc = loc("examples/kernels/binary_ops.py":97:0)
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.target = "cuda:89", "ttg.threads-per-warp" = 32 : i32} {
  tt.func public @add_2d_kernel(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg1: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg2: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg3: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg4: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg5: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg6: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg7: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0)) attributes {noinline = false} {
    %cst = arith.constant dense<0.000000e+00> : tensor<32x32xf32, #blocked> loc(#loc1)
    %c32_i32 = arith.constant 32 : i32 loc(#loc1)
    %0 = tt.get_program_id x : i32 loc(#loc2)
    %1 = tt.get_program_id y : i32 loc(#loc3)
    %2 = arith.muli %0, %c32_i32 : i32 loc(#loc4)
    %3 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc5)
    %4 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc5)
    %5 = tt.splat %2 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc6)
    %6 = arith.addi %5, %3 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc6)
    %7 = tt.splat %arg3 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc7)
    %8 = arith.remsi %6, %7 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc7)
    %9 = arith.muli %1, %c32_i32 : i32 loc(#loc8)
    %10 = tt.splat %9 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc9)
    %11 = arith.addi %10, %4 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc9)
    %12 = tt.splat %arg4 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc10)
    %13 = arith.remsi %11, %12 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc10)
    %14 = tt.expand_dims %8 {axis = 1 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> -> tensor<32x1xi32, #blocked> loc(#loc11)
    %15 = tt.splat %arg5 : i32 -> tensor<32x1xi32, #blocked> loc(#loc12)
    %16 = arith.muli %14, %15 : tensor<32x1xi32, #blocked> loc(#loc12)
    %17 = tt.expand_dims %13 {axis = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> -> tensor<1x32xi32, #blocked> loc(#loc13)
    %18 = tt.broadcast %16 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %19 = tt.broadcast %17 : tensor<1x32xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %20 = arith.addi %18, %19 : tensor<32x32xi32, #blocked> loc(#loc14)
    %21 = tt.splat %arg0 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc15)
    %22 = tt.addptr %21, %20 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc15)
    %23 = tt.splat %arg6 : i32 -> tensor<32x1xi32, #blocked> loc(#loc16)
    %24 = arith.muli %14, %23 : tensor<32x1xi32, #blocked> loc(#loc16)
    %25 = tt.broadcast %24 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc17)
    %26 = arith.addi %25, %19 : tensor<32x32xi32, #blocked> loc(#loc17)
    %27 = tt.splat %arg1 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc18)
    %28 = tt.addptr %27, %26 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc18)
    %29 = tt.splat %arg7 : i32 -> tensor<32x1xi32, #blocked> loc(#loc19)
    %30 = arith.muli %14, %29 : tensor<32x1xi32, #blocked> loc(#loc19)
    %31 = tt.broadcast %30 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc20)
    %32 = arith.addi %31, %19 : tensor<32x32xi32, #blocked> loc(#loc20)
    %33 = tt.splat %arg2 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc21)
    %34 = tt.addptr %33, %32 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc21)
    %35 = tt.splat %arg3 : i32 -> tensor<32x1xi32, #blocked> loc(#loc22)
    %36 = arith.cmpi slt, %14, %35 : tensor<32x1xi32, #blocked> loc(#loc22)
    %37 = tt.splat %arg4 : i32 -> tensor<1x32xi32, #blocked> loc(#loc23)
    %38 = arith.cmpi slt, %17, %37 : tensor<1x32xi32, #blocked> loc(#loc23)
    %39 = tt.broadcast %36 : tensor<32x1xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %40 = tt.broadcast %38 : tensor<1x32xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %41 = arith.andi %39, %40 : tensor<32x32xi1, #blocked> loc(#loc24)
    %42 = tt.load %22, %41, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc25)
    %43 = tt.load %28, %41, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc26)
    %44 = arith.addf %42, %43 : tensor<32x32xf32, #blocked> loc(#loc27)
    tt.store %34, %44, %41 : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc28)
    tt.return loc(#loc29)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("examples/kernels/binary_ops.py":106:26)
#loc3 = loc("examples/kernels/binary_ops.py":107:26)
#loc4 = loc("examples/kernels/binary_ops.py":108:22)
#loc5 = loc("examples/kernels/binary_ops.py":108:50)
#loc6 = loc("examples/kernels/binary_ops.py":108:37)
#loc7 = loc("examples/kernels/binary_ops.py":108:67)
#loc8 = loc("examples/kernels/binary_ops.py":109:22)
#loc9 = loc("examples/kernels/binary_ops.py":109:37)
#loc10 = loc("examples/kernels/binary_ops.py":109:67)
#loc11 = loc("examples/kernels/binary_ops.py":110:29)
#loc12 = loc("examples/kernels/binary_ops.py":110:40)
#loc13 = loc("examples/kernels/binary_ops.py":110:59)
#loc14 = loc("examples/kernels/binary_ops.py":110:52)
#loc15 = loc("examples/kernels/binary_ops.py":110:22)
#loc16 = loc("examples/kernels/binary_ops.py":111:40)
#loc17 = loc("examples/kernels/binary_ops.py":111:52)
#loc18 = loc("examples/kernels/binary_ops.py":111:22)
#loc19 = loc("examples/kernels/binary_ops.py":112:40)
#loc20 = loc("examples/kernels/binary_ops.py":112:52)
#loc21 = loc("examples/kernels/binary_ops.py":112:22)
#loc22 = loc("examples/kernels/binary_ops.py":114:31)
#loc23 = loc("examples/kernels/binary_ops.py":114:55)
#loc24 = loc("examples/kernels/binary_ops.py":114:37)
#loc25 = loc("examples/kernels/binary_ops.py":116:16)
#loc26 = loc("examples/kernels/binary_ops.py":117:16)
#loc27 = loc("examples/kernels/binary_ops.py":118:12)
#loc28 = loc("examples/kernels/binary_ops.py":119:21)
#loc29 = loc("examples/kernels/binary_ops.py":119:4)


// -----// IR Dump Before TritonGPURemoveLayoutConversions (tritongpu-remove-layout-conversions) ('builtin.module' operation) //----- //
#blocked = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>
#loc = loc("examples/kernels/binary_ops.py":97:0)
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.target = "cuda:89", "ttg.threads-per-warp" = 32 : i32} {
  tt.func public @add_2d_kernel(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg1: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg2: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg3: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg4: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg5: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg6: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg7: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0)) attributes {noinline = false} {
    %cst = arith.constant dense<0.000000e+00> : tensor<32x32xf32, #blocked> loc(#loc1)
    %c32_i32 = arith.constant 32 : i32 loc(#loc1)
    %0 = tt.get_program_id x : i32 loc(#loc2)
    %1 = tt.get_program_id y : i32 loc(#loc3)
    %2 = arith.muli %0, %c32_i32 : i32 loc(#loc4)
    %3 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc5)
    %4 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc5)
    %5 = tt.splat %2 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc6)
    %6 = arith.addi %5, %3 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc6)
    %7 = tt.splat %arg3 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc7)
    %8 = arith.remsi %6, %7 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc7)
    %9 = arith.muli %1, %c32_i32 : i32 loc(#loc8)
    %10 = tt.splat %9 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc9)
    %11 = arith.addi %10, %4 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc9)
    %12 = tt.splat %arg4 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc10)
    %13 = arith.remsi %11, %12 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc10)
    %14 = tt.expand_dims %8 {axis = 1 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> -> tensor<32x1xi32, #blocked> loc(#loc11)
    %15 = tt.splat %arg5 : i32 -> tensor<32x1xi32, #blocked> loc(#loc12)
    %16 = arith.muli %14, %15 : tensor<32x1xi32, #blocked> loc(#loc12)
    %17 = tt.expand_dims %13 {axis = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> -> tensor<1x32xi32, #blocked> loc(#loc13)
    %18 = tt.broadcast %16 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %19 = tt.broadcast %17 : tensor<1x32xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %20 = arith.addi %18, %19 : tensor<32x32xi32, #blocked> loc(#loc14)
    %21 = tt.splat %arg0 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc15)
    %22 = tt.addptr %21, %20 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc15)
    %23 = tt.splat %arg6 : i32 -> tensor<32x1xi32, #blocked> loc(#loc16)
    %24 = arith.muli %14, %23 : tensor<32x1xi32, #blocked> loc(#loc16)
    %25 = tt.broadcast %24 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc17)
    %26 = arith.addi %25, %19 : tensor<32x32xi32, #blocked> loc(#loc17)
    %27 = tt.splat %arg1 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc18)
    %28 = tt.addptr %27, %26 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc18)
    %29 = tt.splat %arg7 : i32 -> tensor<32x1xi32, #blocked> loc(#loc19)
    %30 = arith.muli %14, %29 : tensor<32x1xi32, #blocked> loc(#loc19)
    %31 = tt.broadcast %30 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc20)
    %32 = arith.addi %31, %19 : tensor<32x32xi32, #blocked> loc(#loc20)
    %33 = tt.splat %arg2 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc21)
    %34 = tt.addptr %33, %32 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc21)
    %35 = tt.splat %arg3 : i32 -> tensor<32x1xi32, #blocked> loc(#loc22)
    %36 = arith.cmpi slt, %14, %35 : tensor<32x1xi32, #blocked> loc(#loc22)
    %37 = tt.splat %arg4 : i32 -> tensor<1x32xi32, #blocked> loc(#loc23)
    %38 = arith.cmpi slt, %17, %37 : tensor<1x32xi32, #blocked> loc(#loc23)
    %39 = tt.broadcast %36 : tensor<32x1xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %40 = tt.broadcast %38 : tensor<1x32xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %41 = arith.andi %39, %40 : tensor<32x32xi1, #blocked> loc(#loc24)
    %42 = tt.load %22, %41, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc25)
    %43 = tt.load %28, %41, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc26)
    %44 = arith.addf %42, %43 : tensor<32x32xf32, #blocked> loc(#loc27)
    tt.store %34, %44, %41 : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc28)
    tt.return loc(#loc29)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("examples/kernels/binary_ops.py":106:26)
#loc3 = loc("examples/kernels/binary_ops.py":107:26)
#loc4 = loc("examples/kernels/binary_ops.py":108:22)
#loc5 = loc("examples/kernels/binary_ops.py":108:50)
#loc6 = loc("examples/kernels/binary_ops.py":108:37)
#loc7 = loc("examples/kernels/binary_ops.py":108:67)
#loc8 = loc("examples/kernels/binary_ops.py":109:22)
#loc9 = loc("examples/kernels/binary_ops.py":109:37)
#loc10 = loc("examples/kernels/binary_ops.py":109:67)
#loc11 = loc("examples/kernels/binary_ops.py":110:29)
#loc12 = loc("examples/kernels/binary_ops.py":110:40)
#loc13 = loc("examples/kernels/binary_ops.py":110:59)
#loc14 = loc("examples/kernels/binary_ops.py":110:52)
#loc15 = loc("examples/kernels/binary_ops.py":110:22)
#loc16 = loc("examples/kernels/binary_ops.py":111:40)
#loc17 = loc("examples/kernels/binary_ops.py":111:52)
#loc18 = loc("examples/kernels/binary_ops.py":111:22)
#loc19 = loc("examples/kernels/binary_ops.py":112:40)
#loc20 = loc("examples/kernels/binary_ops.py":112:52)
#loc21 = loc("examples/kernels/binary_ops.py":112:22)
#loc22 = loc("examples/kernels/binary_ops.py":114:31)
#loc23 = loc("examples/kernels/binary_ops.py":114:55)
#loc24 = loc("examples/kernels/binary_ops.py":114:37)
#loc25 = loc("examples/kernels/binary_ops.py":116:16)
#loc26 = loc("examples/kernels/binary_ops.py":117:16)
#loc27 = loc("examples/kernels/binary_ops.py":118:12)
#loc28 = loc("examples/kernels/binary_ops.py":119:21)
#loc29 = loc("examples/kernels/binary_ops.py":119:4)


// -----// IR Dump Before TritonGPUReduceDataDuplication (tritongpu-reduce-data-duplication) ('builtin.module' operation) //----- //
#blocked = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>
#loc = loc("examples/kernels/binary_ops.py":97:0)
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.target = "cuda:89", "ttg.threads-per-warp" = 32 : i32} {
  tt.func public @add_2d_kernel(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg1: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg2: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg3: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg4: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg5: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg6: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg7: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0)) attributes {noinline = false} {
    %cst = arith.constant dense<0.000000e+00> : tensor<32x32xf32, #blocked> loc(#loc1)
    %c32_i32 = arith.constant 32 : i32 loc(#loc1)
    %0 = tt.get_program_id x : i32 loc(#loc2)
    %1 = tt.get_program_id y : i32 loc(#loc3)
    %2 = arith.muli %0, %c32_i32 : i32 loc(#loc4)
    %3 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc5)
    %4 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc5)
    %5 = tt.splat %2 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc6)
    %6 = arith.addi %5, %3 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc6)
    %7 = tt.splat %arg3 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc7)
    %8 = arith.remsi %6, %7 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc7)
    %9 = arith.muli %1, %c32_i32 : i32 loc(#loc8)
    %10 = tt.splat %9 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc9)
    %11 = arith.addi %10, %4 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc9)
    %12 = tt.splat %arg4 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc10)
    %13 = arith.remsi %11, %12 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc10)
    %14 = tt.expand_dims %8 {axis = 1 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> -> tensor<32x1xi32, #blocked> loc(#loc11)
    %15 = tt.splat %arg5 : i32 -> tensor<32x1xi32, #blocked> loc(#loc12)
    %16 = arith.muli %14, %15 : tensor<32x1xi32, #blocked> loc(#loc12)
    %17 = tt.expand_dims %13 {axis = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> -> tensor<1x32xi32, #blocked> loc(#loc13)
    %18 = tt.broadcast %16 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %19 = tt.broadcast %17 : tensor<1x32xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %20 = arith.addi %18, %19 : tensor<32x32xi32, #blocked> loc(#loc14)
    %21 = tt.splat %arg0 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc15)
    %22 = tt.addptr %21, %20 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc15)
    %23 = tt.splat %arg6 : i32 -> tensor<32x1xi32, #blocked> loc(#loc16)
    %24 = arith.muli %14, %23 : tensor<32x1xi32, #blocked> loc(#loc16)
    %25 = tt.broadcast %24 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc17)
    %26 = arith.addi %25, %19 : tensor<32x32xi32, #blocked> loc(#loc17)
    %27 = tt.splat %arg1 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc18)
    %28 = tt.addptr %27, %26 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc18)
    %29 = tt.splat %arg7 : i32 -> tensor<32x1xi32, #blocked> loc(#loc19)
    %30 = arith.muli %14, %29 : tensor<32x1xi32, #blocked> loc(#loc19)
    %31 = tt.broadcast %30 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc20)
    %32 = arith.addi %31, %19 : tensor<32x32xi32, #blocked> loc(#loc20)
    %33 = tt.splat %arg2 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc21)
    %34 = tt.addptr %33, %32 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc21)
    %35 = tt.splat %arg3 : i32 -> tensor<32x1xi32, #blocked> loc(#loc22)
    %36 = arith.cmpi slt, %14, %35 : tensor<32x1xi32, #blocked> loc(#loc22)
    %37 = tt.splat %arg4 : i32 -> tensor<1x32xi32, #blocked> loc(#loc23)
    %38 = arith.cmpi slt, %17, %37 : tensor<1x32xi32, #blocked> loc(#loc23)
    %39 = tt.broadcast %36 : tensor<32x1xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %40 = tt.broadcast %38 : tensor<1x32xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %41 = arith.andi %39, %40 : tensor<32x32xi1, #blocked> loc(#loc24)
    %42 = tt.load %22, %41, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc25)
    %43 = tt.load %28, %41, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc26)
    %44 = arith.addf %42, %43 : tensor<32x32xf32, #blocked> loc(#loc27)
    tt.store %34, %44, %41 : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc28)
    tt.return loc(#loc29)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("examples/kernels/binary_ops.py":106:26)
#loc3 = loc("examples/kernels/binary_ops.py":107:26)
#loc4 = loc("examples/kernels/binary_ops.py":108:22)
#loc5 = loc("examples/kernels/binary_ops.py":108:50)
#loc6 = loc("examples/kernels/binary_ops.py":108:37)
#loc7 = loc("examples/kernels/binary_ops.py":108:67)
#loc8 = loc("examples/kernels/binary_ops.py":109:22)
#loc9 = loc("examples/kernels/binary_ops.py":109:37)
#loc10 = loc("examples/kernels/binary_ops.py":109:67)
#loc11 = loc("examples/kernels/binary_ops.py":110:29)
#loc12 = loc("examples/kernels/binary_ops.py":110:40)
#loc13 = loc("examples/kernels/binary_ops.py":110:59)
#loc14 = loc("examples/kernels/binary_ops.py":110:52)
#loc15 = loc("examples/kernels/binary_ops.py":110:22)
#loc16 = loc("examples/kernels/binary_ops.py":111:40)
#loc17 = loc("examples/kernels/binary_ops.py":111:52)
#loc18 = loc("examples/kernels/binary_ops.py":111:22)
#loc19 = loc("examples/kernels/binary_ops.py":112:40)
#loc20 = loc("examples/kernels/binary_ops.py":112:52)
#loc21 = loc("examples/kernels/binary_ops.py":112:22)
#loc22 = loc("examples/kernels/binary_ops.py":114:31)
#loc23 = loc("examples/kernels/binary_ops.py":114:55)
#loc24 = loc("examples/kernels/binary_ops.py":114:37)
#loc25 = loc("examples/kernels/binary_ops.py":116:16)
#loc26 = loc("examples/kernels/binary_ops.py":117:16)
#loc27 = loc("examples/kernels/binary_ops.py":118:12)
#loc28 = loc("examples/kernels/binary_ops.py":119:21)
#loc29 = loc("examples/kernels/binary_ops.py":119:4)


// -----// IR Dump Before TritonGPUReorderInstructions (tritongpu-reorder-instructions) ('builtin.module' operation) //----- //
#blocked = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>
#loc = loc("examples/kernels/binary_ops.py":97:0)
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.target = "cuda:89", "ttg.threads-per-warp" = 32 : i32} {
  tt.func public @add_2d_kernel(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg1: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg2: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg3: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg4: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg5: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg6: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg7: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0)) attributes {noinline = false} {
    %cst = arith.constant dense<0.000000e+00> : tensor<32x32xf32, #blocked> loc(#loc1)
    %c32_i32 = arith.constant 32 : i32 loc(#loc1)
    %0 = tt.get_program_id x : i32 loc(#loc2)
    %1 = tt.get_program_id y : i32 loc(#loc3)
    %2 = arith.muli %0, %c32_i32 : i32 loc(#loc4)
    %3 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc5)
    %4 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc5)
    %5 = tt.splat %2 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc6)
    %6 = arith.addi %5, %3 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc6)
    %7 = tt.splat %arg3 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc7)
    %8 = arith.remsi %6, %7 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc7)
    %9 = arith.muli %1, %c32_i32 : i32 loc(#loc8)
    %10 = tt.splat %9 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc9)
    %11 = arith.addi %10, %4 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc9)
    %12 = tt.splat %arg4 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc10)
    %13 = arith.remsi %11, %12 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc10)
    %14 = tt.expand_dims %8 {axis = 1 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> -> tensor<32x1xi32, #blocked> loc(#loc11)
    %15 = tt.splat %arg5 : i32 -> tensor<32x1xi32, #blocked> loc(#loc12)
    %16 = arith.muli %14, %15 : tensor<32x1xi32, #blocked> loc(#loc12)
    %17 = tt.expand_dims %13 {axis = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> -> tensor<1x32xi32, #blocked> loc(#loc13)
    %18 = tt.broadcast %16 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %19 = tt.broadcast %17 : tensor<1x32xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %20 = arith.addi %18, %19 : tensor<32x32xi32, #blocked> loc(#loc14)
    %21 = tt.splat %arg0 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc15)
    %22 = tt.addptr %21, %20 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc15)
    %23 = tt.splat %arg6 : i32 -> tensor<32x1xi32, #blocked> loc(#loc16)
    %24 = arith.muli %14, %23 : tensor<32x1xi32, #blocked> loc(#loc16)
    %25 = tt.broadcast %24 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc17)
    %26 = arith.addi %25, %19 : tensor<32x32xi32, #blocked> loc(#loc17)
    %27 = tt.splat %arg1 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc18)
    %28 = tt.addptr %27, %26 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc18)
    %29 = tt.splat %arg7 : i32 -> tensor<32x1xi32, #blocked> loc(#loc19)
    %30 = arith.muli %14, %29 : tensor<32x1xi32, #blocked> loc(#loc19)
    %31 = tt.broadcast %30 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc20)
    %32 = arith.addi %31, %19 : tensor<32x32xi32, #blocked> loc(#loc20)
    %33 = tt.splat %arg2 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc21)
    %34 = tt.addptr %33, %32 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc21)
    %35 = tt.splat %arg3 : i32 -> tensor<32x1xi32, #blocked> loc(#loc22)
    %36 = arith.cmpi slt, %14, %35 : tensor<32x1xi32, #blocked> loc(#loc22)
    %37 = tt.splat %arg4 : i32 -> tensor<1x32xi32, #blocked> loc(#loc23)
    %38 = arith.cmpi slt, %17, %37 : tensor<1x32xi32, #blocked> loc(#loc23)
    %39 = tt.broadcast %36 : tensor<32x1xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %40 = tt.broadcast %38 : tensor<1x32xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %41 = arith.andi %39, %40 : tensor<32x32xi1, #blocked> loc(#loc24)
    %42 = tt.load %22, %41, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc25)
    %43 = tt.load %28, %41, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc26)
    %44 = arith.addf %42, %43 : tensor<32x32xf32, #blocked> loc(#loc27)
    tt.store %34, %44, %41 : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc28)
    tt.return loc(#loc29)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("examples/kernels/binary_ops.py":106:26)
#loc3 = loc("examples/kernels/binary_ops.py":107:26)
#loc4 = loc("examples/kernels/binary_ops.py":108:22)
#loc5 = loc("examples/kernels/binary_ops.py":108:50)
#loc6 = loc("examples/kernels/binary_ops.py":108:37)
#loc7 = loc("examples/kernels/binary_ops.py":108:67)
#loc8 = loc("examples/kernels/binary_ops.py":109:22)
#loc9 = loc("examples/kernels/binary_ops.py":109:37)
#loc10 = loc("examples/kernels/binary_ops.py":109:67)
#loc11 = loc("examples/kernels/binary_ops.py":110:29)
#loc12 = loc("examples/kernels/binary_ops.py":110:40)
#loc13 = loc("examples/kernels/binary_ops.py":110:59)
#loc14 = loc("examples/kernels/binary_ops.py":110:52)
#loc15 = loc("examples/kernels/binary_ops.py":110:22)
#loc16 = loc("examples/kernels/binary_ops.py":111:40)
#loc17 = loc("examples/kernels/binary_ops.py":111:52)
#loc18 = loc("examples/kernels/binary_ops.py":111:22)
#loc19 = loc("examples/kernels/binary_ops.py":112:40)
#loc20 = loc("examples/kernels/binary_ops.py":112:52)
#loc21 = loc("examples/kernels/binary_ops.py":112:22)
#loc22 = loc("examples/kernels/binary_ops.py":114:31)
#loc23 = loc("examples/kernels/binary_ops.py":114:55)
#loc24 = loc("examples/kernels/binary_ops.py":114:37)
#loc25 = loc("examples/kernels/binary_ops.py":116:16)
#loc26 = loc("examples/kernels/binary_ops.py":117:16)
#loc27 = loc("examples/kernels/binary_ops.py":118:12)
#loc28 = loc("examples/kernels/binary_ops.py":119:21)
#loc29 = loc("examples/kernels/binary_ops.py":119:4)


// -----// IR Dump Before CSE (cse) ('builtin.module' operation) //----- //
#blocked = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>
#loc = loc("examples/kernels/binary_ops.py":97:0)
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.target = "cuda:89", "ttg.threads-per-warp" = 32 : i32} {
  tt.func public @add_2d_kernel(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg1: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg2: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg3: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg4: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg5: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg6: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg7: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0)) attributes {noinline = false} {
    %cst = arith.constant dense<0.000000e+00> : tensor<32x32xf32, #blocked> loc(#loc1)
    %c32_i32 = arith.constant 32 : i32 loc(#loc1)
    %0 = tt.get_program_id x : i32 loc(#loc2)
    %1 = tt.get_program_id y : i32 loc(#loc3)
    %2 = arith.muli %0, %c32_i32 : i32 loc(#loc4)
    %3 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc5)
    %4 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc5)
    %5 = tt.splat %2 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc6)
    %6 = arith.addi %5, %3 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc6)
    %7 = tt.splat %arg3 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc7)
    %8 = arith.remsi %6, %7 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc7)
    %9 = arith.muli %1, %c32_i32 : i32 loc(#loc8)
    %10 = tt.splat %9 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc9)
    %11 = arith.addi %10, %4 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc9)
    %12 = tt.splat %arg4 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc10)
    %13 = arith.remsi %11, %12 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc10)
    %14 = tt.expand_dims %8 {axis = 1 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> -> tensor<32x1xi32, #blocked> loc(#loc11)
    %15 = tt.splat %arg5 : i32 -> tensor<32x1xi32, #blocked> loc(#loc12)
    %16 = arith.muli %14, %15 : tensor<32x1xi32, #blocked> loc(#loc12)
    %17 = tt.expand_dims %13 {axis = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> -> tensor<1x32xi32, #blocked> loc(#loc13)
    %18 = tt.broadcast %16 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %19 = tt.broadcast %17 : tensor<1x32xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %20 = arith.addi %18, %19 : tensor<32x32xi32, #blocked> loc(#loc14)
    %21 = tt.splat %arg0 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc15)
    %22 = tt.addptr %21, %20 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc15)
    %23 = tt.splat %arg6 : i32 -> tensor<32x1xi32, #blocked> loc(#loc16)
    %24 = arith.muli %14, %23 : tensor<32x1xi32, #blocked> loc(#loc16)
    %25 = tt.broadcast %24 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc17)
    %26 = arith.addi %25, %19 : tensor<32x32xi32, #blocked> loc(#loc17)
    %27 = tt.splat %arg1 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc18)
    %28 = tt.addptr %27, %26 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc18)
    %29 = tt.splat %arg7 : i32 -> tensor<32x1xi32, #blocked> loc(#loc19)
    %30 = arith.muli %14, %29 : tensor<32x1xi32, #blocked> loc(#loc19)
    %31 = tt.broadcast %30 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc20)
    %32 = arith.addi %31, %19 : tensor<32x32xi32, #blocked> loc(#loc20)
    %33 = tt.splat %arg2 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc21)
    %34 = tt.addptr %33, %32 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc21)
    %35 = tt.splat %arg3 : i32 -> tensor<32x1xi32, #blocked> loc(#loc22)
    %36 = arith.cmpi slt, %14, %35 : tensor<32x1xi32, #blocked> loc(#loc22)
    %37 = tt.splat %arg4 : i32 -> tensor<1x32xi32, #blocked> loc(#loc23)
    %38 = arith.cmpi slt, %17, %37 : tensor<1x32xi32, #blocked> loc(#loc23)
    %39 = tt.broadcast %36 : tensor<32x1xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %40 = tt.broadcast %38 : tensor<1x32xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %41 = arith.andi %39, %40 : tensor<32x32xi1, #blocked> loc(#loc24)
    %42 = tt.load %22, %41, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc25)
    %43 = tt.load %28, %41, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc26)
    %44 = arith.addf %42, %43 : tensor<32x32xf32, #blocked> loc(#loc27)
    tt.store %34, %44, %41 : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc28)
    tt.return loc(#loc29)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("examples/kernels/binary_ops.py":106:26)
#loc3 = loc("examples/kernels/binary_ops.py":107:26)
#loc4 = loc("examples/kernels/binary_ops.py":108:22)
#loc5 = loc("examples/kernels/binary_ops.py":108:50)
#loc6 = loc("examples/kernels/binary_ops.py":108:37)
#loc7 = loc("examples/kernels/binary_ops.py":108:67)
#loc8 = loc("examples/kernels/binary_ops.py":109:22)
#loc9 = loc("examples/kernels/binary_ops.py":109:37)
#loc10 = loc("examples/kernels/binary_ops.py":109:67)
#loc11 = loc("examples/kernels/binary_ops.py":110:29)
#loc12 = loc("examples/kernels/binary_ops.py":110:40)
#loc13 = loc("examples/kernels/binary_ops.py":110:59)
#loc14 = loc("examples/kernels/binary_ops.py":110:52)
#loc15 = loc("examples/kernels/binary_ops.py":110:22)
#loc16 = loc("examples/kernels/binary_ops.py":111:40)
#loc17 = loc("examples/kernels/binary_ops.py":111:52)
#loc18 = loc("examples/kernels/binary_ops.py":111:22)
#loc19 = loc("examples/kernels/binary_ops.py":112:40)
#loc20 = loc("examples/kernels/binary_ops.py":112:52)
#loc21 = loc("examples/kernels/binary_ops.py":112:22)
#loc22 = loc("examples/kernels/binary_ops.py":114:31)
#loc23 = loc("examples/kernels/binary_ops.py":114:55)
#loc24 = loc("examples/kernels/binary_ops.py":114:37)
#loc25 = loc("examples/kernels/binary_ops.py":116:16)
#loc26 = loc("examples/kernels/binary_ops.py":117:16)
#loc27 = loc("examples/kernels/binary_ops.py":118:12)
#loc28 = loc("examples/kernels/binary_ops.py":119:21)
#loc29 = loc("examples/kernels/binary_ops.py":119:4)


// -----// IR Dump Before SymbolDCE (symbol-dce) ('builtin.module' operation) //----- //
#blocked = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>
#loc = loc("examples/kernels/binary_ops.py":97:0)
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.target = "cuda:89", "ttg.threads-per-warp" = 32 : i32} {
  tt.func public @add_2d_kernel(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg1: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg2: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg3: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg4: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg5: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg6: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg7: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0)) attributes {noinline = false} {
    %cst = arith.constant dense<0.000000e+00> : tensor<32x32xf32, #blocked> loc(#loc1)
    %c32_i32 = arith.constant 32 : i32 loc(#loc1)
    %0 = tt.get_program_id x : i32 loc(#loc2)
    %1 = tt.get_program_id y : i32 loc(#loc3)
    %2 = arith.muli %0, %c32_i32 : i32 loc(#loc4)
    %3 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc5)
    %4 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc5)
    %5 = tt.splat %2 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc6)
    %6 = arith.addi %5, %3 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc6)
    %7 = tt.splat %arg3 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc7)
    %8 = arith.remsi %6, %7 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc7)
    %9 = arith.muli %1, %c32_i32 : i32 loc(#loc8)
    %10 = tt.splat %9 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc9)
    %11 = arith.addi %10, %4 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc9)
    %12 = tt.splat %arg4 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc10)
    %13 = arith.remsi %11, %12 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc10)
    %14 = tt.expand_dims %8 {axis = 1 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> -> tensor<32x1xi32, #blocked> loc(#loc11)
    %15 = tt.splat %arg5 : i32 -> tensor<32x1xi32, #blocked> loc(#loc12)
    %16 = arith.muli %14, %15 : tensor<32x1xi32, #blocked> loc(#loc12)
    %17 = tt.expand_dims %13 {axis = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> -> tensor<1x32xi32, #blocked> loc(#loc13)
    %18 = tt.broadcast %16 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %19 = tt.broadcast %17 : tensor<1x32xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %20 = arith.addi %18, %19 : tensor<32x32xi32, #blocked> loc(#loc14)
    %21 = tt.splat %arg0 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc15)
    %22 = tt.addptr %21, %20 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc15)
    %23 = tt.splat %arg6 : i32 -> tensor<32x1xi32, #blocked> loc(#loc16)
    %24 = arith.muli %14, %23 : tensor<32x1xi32, #blocked> loc(#loc16)
    %25 = tt.broadcast %24 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc17)
    %26 = arith.addi %25, %19 : tensor<32x32xi32, #blocked> loc(#loc17)
    %27 = tt.splat %arg1 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc18)
    %28 = tt.addptr %27, %26 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc18)
    %29 = tt.splat %arg7 : i32 -> tensor<32x1xi32, #blocked> loc(#loc19)
    %30 = arith.muli %14, %29 : tensor<32x1xi32, #blocked> loc(#loc19)
    %31 = tt.broadcast %30 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc20)
    %32 = arith.addi %31, %19 : tensor<32x32xi32, #blocked> loc(#loc20)
    %33 = tt.splat %arg2 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc21)
    %34 = tt.addptr %33, %32 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc21)
    %35 = tt.splat %arg3 : i32 -> tensor<32x1xi32, #blocked> loc(#loc22)
    %36 = arith.cmpi slt, %14, %35 : tensor<32x1xi32, #blocked> loc(#loc22)
    %37 = tt.splat %arg4 : i32 -> tensor<1x32xi32, #blocked> loc(#loc23)
    %38 = arith.cmpi slt, %17, %37 : tensor<1x32xi32, #blocked> loc(#loc23)
    %39 = tt.broadcast %36 : tensor<32x1xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %40 = tt.broadcast %38 : tensor<1x32xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %41 = arith.andi %39, %40 : tensor<32x32xi1, #blocked> loc(#loc24)
    %42 = tt.load %22, %41, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc25)
    %43 = tt.load %28, %41, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc26)
    %44 = arith.addf %42, %43 : tensor<32x32xf32, #blocked> loc(#loc27)
    tt.store %34, %44, %41 : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc28)
    tt.return loc(#loc29)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("examples/kernels/binary_ops.py":106:26)
#loc3 = loc("examples/kernels/binary_ops.py":107:26)
#loc4 = loc("examples/kernels/binary_ops.py":108:22)
#loc5 = loc("examples/kernels/binary_ops.py":108:50)
#loc6 = loc("examples/kernels/binary_ops.py":108:37)
#loc7 = loc("examples/kernels/binary_ops.py":108:67)
#loc8 = loc("examples/kernels/binary_ops.py":109:22)
#loc9 = loc("examples/kernels/binary_ops.py":109:37)
#loc10 = loc("examples/kernels/binary_ops.py":109:67)
#loc11 = loc("examples/kernels/binary_ops.py":110:29)
#loc12 = loc("examples/kernels/binary_ops.py":110:40)
#loc13 = loc("examples/kernels/binary_ops.py":110:59)
#loc14 = loc("examples/kernels/binary_ops.py":110:52)
#loc15 = loc("examples/kernels/binary_ops.py":110:22)
#loc16 = loc("examples/kernels/binary_ops.py":111:40)
#loc17 = loc("examples/kernels/binary_ops.py":111:52)
#loc18 = loc("examples/kernels/binary_ops.py":111:22)
#loc19 = loc("examples/kernels/binary_ops.py":112:40)
#loc20 = loc("examples/kernels/binary_ops.py":112:52)
#loc21 = loc("examples/kernels/binary_ops.py":112:22)
#loc22 = loc("examples/kernels/binary_ops.py":114:31)
#loc23 = loc("examples/kernels/binary_ops.py":114:55)
#loc24 = loc("examples/kernels/binary_ops.py":114:37)
#loc25 = loc("examples/kernels/binary_ops.py":116:16)
#loc26 = loc("examples/kernels/binary_ops.py":117:16)
#loc27 = loc("examples/kernels/binary_ops.py":118:12)
#loc28 = loc("examples/kernels/binary_ops.py":119:21)
#loc29 = loc("examples/kernels/binary_ops.py":119:4)


// -----// IR Dump Before Canonicalizer (canonicalize) ('builtin.module' operation) //----- //
#blocked = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>
#loc = loc("examples/kernels/binary_ops.py":97:0)
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.target = "cuda:89", "ttg.threads-per-warp" = 32 : i32} {
  tt.func public @add_2d_kernel(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg1: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg2: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg3: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg4: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg5: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg6: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg7: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0)) attributes {noinline = false} {
    %cst = arith.constant dense<0.000000e+00> : tensor<32x32xf32, #blocked> loc(#loc1)
    %c32_i32 = arith.constant 32 : i32 loc(#loc1)
    %0 = tt.get_program_id x : i32 loc(#loc2)
    %1 = tt.get_program_id y : i32 loc(#loc3)
    %2 = arith.muli %0, %c32_i32 : i32 loc(#loc4)
    %3 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc5)
    %4 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc5)
    %5 = tt.splat %2 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc6)
    %6 = arith.addi %5, %3 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc6)
    %7 = tt.splat %arg3 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc7)
    %8 = arith.remsi %6, %7 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc7)
    %9 = arith.muli %1, %c32_i32 : i32 loc(#loc8)
    %10 = tt.splat %9 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc9)
    %11 = arith.addi %10, %4 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc9)
    %12 = tt.splat %arg4 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc10)
    %13 = arith.remsi %11, %12 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc10)
    %14 = tt.expand_dims %8 {axis = 1 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> -> tensor<32x1xi32, #blocked> loc(#loc11)
    %15 = tt.splat %arg5 : i32 -> tensor<32x1xi32, #blocked> loc(#loc12)
    %16 = arith.muli %14, %15 : tensor<32x1xi32, #blocked> loc(#loc12)
    %17 = tt.expand_dims %13 {axis = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> -> tensor<1x32xi32, #blocked> loc(#loc13)
    %18 = tt.broadcast %16 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %19 = tt.broadcast %17 : tensor<1x32xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %20 = arith.addi %18, %19 : tensor<32x32xi32, #blocked> loc(#loc14)
    %21 = tt.splat %arg0 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc15)
    %22 = tt.addptr %21, %20 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc15)
    %23 = tt.splat %arg6 : i32 -> tensor<32x1xi32, #blocked> loc(#loc16)
    %24 = arith.muli %14, %23 : tensor<32x1xi32, #blocked> loc(#loc16)
    %25 = tt.broadcast %24 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc17)
    %26 = arith.addi %25, %19 : tensor<32x32xi32, #blocked> loc(#loc17)
    %27 = tt.splat %arg1 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc18)
    %28 = tt.addptr %27, %26 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc18)
    %29 = tt.splat %arg7 : i32 -> tensor<32x1xi32, #blocked> loc(#loc19)
    %30 = arith.muli %14, %29 : tensor<32x1xi32, #blocked> loc(#loc19)
    %31 = tt.broadcast %30 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc20)
    %32 = arith.addi %31, %19 : tensor<32x32xi32, #blocked> loc(#loc20)
    %33 = tt.splat %arg2 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc21)
    %34 = tt.addptr %33, %32 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc21)
    %35 = tt.splat %arg3 : i32 -> tensor<32x1xi32, #blocked> loc(#loc22)
    %36 = arith.cmpi slt, %14, %35 : tensor<32x1xi32, #blocked> loc(#loc22)
    %37 = tt.splat %arg4 : i32 -> tensor<1x32xi32, #blocked> loc(#loc23)
    %38 = arith.cmpi slt, %17, %37 : tensor<1x32xi32, #blocked> loc(#loc23)
    %39 = tt.broadcast %36 : tensor<32x1xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %40 = tt.broadcast %38 : tensor<1x32xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %41 = arith.andi %39, %40 : tensor<32x32xi1, #blocked> loc(#loc24)
    %42 = tt.load %22, %41, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc25)
    %43 = tt.load %28, %41, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc26)
    %44 = arith.addf %42, %43 : tensor<32x32xf32, #blocked> loc(#loc27)
    tt.store %34, %44, %41 : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc28)
    tt.return loc(#loc29)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("examples/kernels/binary_ops.py":106:26)
#loc3 = loc("examples/kernels/binary_ops.py":107:26)
#loc4 = loc("examples/kernels/binary_ops.py":108:22)
#loc5 = loc("examples/kernels/binary_ops.py":108:50)
#loc6 = loc("examples/kernels/binary_ops.py":108:37)
#loc7 = loc("examples/kernels/binary_ops.py":108:67)
#loc8 = loc("examples/kernels/binary_ops.py":109:22)
#loc9 = loc("examples/kernels/binary_ops.py":109:37)
#loc10 = loc("examples/kernels/binary_ops.py":109:67)
#loc11 = loc("examples/kernels/binary_ops.py":110:29)
#loc12 = loc("examples/kernels/binary_ops.py":110:40)
#loc13 = loc("examples/kernels/binary_ops.py":110:59)
#loc14 = loc("examples/kernels/binary_ops.py":110:52)
#loc15 = loc("examples/kernels/binary_ops.py":110:22)
#loc16 = loc("examples/kernels/binary_ops.py":111:40)
#loc17 = loc("examples/kernels/binary_ops.py":111:52)
#loc18 = loc("examples/kernels/binary_ops.py":111:22)
#loc19 = loc("examples/kernels/binary_ops.py":112:40)
#loc20 = loc("examples/kernels/binary_ops.py":112:52)
#loc21 = loc("examples/kernels/binary_ops.py":112:22)
#loc22 = loc("examples/kernels/binary_ops.py":114:31)
#loc23 = loc("examples/kernels/binary_ops.py":114:55)
#loc24 = loc("examples/kernels/binary_ops.py":114:37)
#loc25 = loc("examples/kernels/binary_ops.py":116:16)
#loc26 = loc("examples/kernels/binary_ops.py":117:16)
#loc27 = loc("examples/kernels/binary_ops.py":118:12)
#loc28 = loc("examples/kernels/binary_ops.py":119:21)
#loc29 = loc("examples/kernels/binary_ops.py":119:4)


// -----// IR Dump Before TritonNvidiaGPUMMALoweringPass (triton-nvidia-mma-lowering) ('builtin.module' operation) //----- //
#blocked = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>
#loc = loc("examples/kernels/binary_ops.py":97:0)
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.target = "cuda:89", "ttg.threads-per-warp" = 32 : i32} {
  tt.func public @add_2d_kernel(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg1: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg2: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg3: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg4: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg5: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg6: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg7: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0)) attributes {noinline = false} {
    %cst = arith.constant dense<0.000000e+00> : tensor<32x32xf32, #blocked> loc(#loc1)
    %c32_i32 = arith.constant 32 : i32 loc(#loc1)
    %0 = tt.get_program_id x : i32 loc(#loc2)
    %1 = tt.get_program_id y : i32 loc(#loc3)
    %2 = arith.muli %0, %c32_i32 : i32 loc(#loc4)
    %3 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc5)
    %4 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc5)
    %5 = tt.splat %2 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc6)
    %6 = arith.addi %5, %3 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc6)
    %7 = tt.splat %arg3 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc7)
    %8 = arith.remsi %6, %7 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc7)
    %9 = arith.muli %1, %c32_i32 : i32 loc(#loc8)
    %10 = tt.splat %9 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc9)
    %11 = arith.addi %10, %4 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc9)
    %12 = tt.splat %arg4 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc10)
    %13 = arith.remsi %11, %12 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc10)
    %14 = tt.expand_dims %8 {axis = 1 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> -> tensor<32x1xi32, #blocked> loc(#loc11)
    %15 = tt.splat %arg5 : i32 -> tensor<32x1xi32, #blocked> loc(#loc12)
    %16 = arith.muli %14, %15 : tensor<32x1xi32, #blocked> loc(#loc12)
    %17 = tt.expand_dims %13 {axis = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> -> tensor<1x32xi32, #blocked> loc(#loc13)
    %18 = tt.broadcast %16 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %19 = tt.broadcast %17 : tensor<1x32xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %20 = arith.addi %18, %19 : tensor<32x32xi32, #blocked> loc(#loc14)
    %21 = tt.splat %arg0 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc15)
    %22 = tt.addptr %21, %20 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc15)
    %23 = tt.splat %arg6 : i32 -> tensor<32x1xi32, #blocked> loc(#loc16)
    %24 = arith.muli %14, %23 : tensor<32x1xi32, #blocked> loc(#loc16)
    %25 = tt.broadcast %24 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc17)
    %26 = arith.addi %25, %19 : tensor<32x32xi32, #blocked> loc(#loc17)
    %27 = tt.splat %arg1 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc18)
    %28 = tt.addptr %27, %26 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc18)
    %29 = tt.splat %arg7 : i32 -> tensor<32x1xi32, #blocked> loc(#loc19)
    %30 = arith.muli %14, %29 : tensor<32x1xi32, #blocked> loc(#loc19)
    %31 = tt.broadcast %30 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc20)
    %32 = arith.addi %31, %19 : tensor<32x32xi32, #blocked> loc(#loc20)
    %33 = tt.splat %arg2 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc21)
    %34 = tt.addptr %33, %32 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc21)
    %35 = tt.splat %arg3 : i32 -> tensor<32x1xi32, #blocked> loc(#loc22)
    %36 = arith.cmpi slt, %14, %35 : tensor<32x1xi32, #blocked> loc(#loc22)
    %37 = tt.splat %arg4 : i32 -> tensor<1x32xi32, #blocked> loc(#loc23)
    %38 = arith.cmpi slt, %17, %37 : tensor<1x32xi32, #blocked> loc(#loc23)
    %39 = tt.broadcast %36 : tensor<32x1xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %40 = tt.broadcast %38 : tensor<1x32xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %41 = arith.andi %39, %40 : tensor<32x32xi1, #blocked> loc(#loc24)
    %42 = tt.load %22, %41, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc25)
    %43 = tt.load %28, %41, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc26)
    %44 = arith.addf %42, %43 : tensor<32x32xf32, #blocked> loc(#loc27)
    tt.store %34, %44, %41 : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc28)
    tt.return loc(#loc29)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("examples/kernels/binary_ops.py":106:26)
#loc3 = loc("examples/kernels/binary_ops.py":107:26)
#loc4 = loc("examples/kernels/binary_ops.py":108:22)
#loc5 = loc("examples/kernels/binary_ops.py":108:50)
#loc6 = loc("examples/kernels/binary_ops.py":108:37)
#loc7 = loc("examples/kernels/binary_ops.py":108:67)
#loc8 = loc("examples/kernels/binary_ops.py":109:22)
#loc9 = loc("examples/kernels/binary_ops.py":109:37)
#loc10 = loc("examples/kernels/binary_ops.py":109:67)
#loc11 = loc("examples/kernels/binary_ops.py":110:29)
#loc12 = loc("examples/kernels/binary_ops.py":110:40)
#loc13 = loc("examples/kernels/binary_ops.py":110:59)
#loc14 = loc("examples/kernels/binary_ops.py":110:52)
#loc15 = loc("examples/kernels/binary_ops.py":110:22)
#loc16 = loc("examples/kernels/binary_ops.py":111:40)
#loc17 = loc("examples/kernels/binary_ops.py":111:52)
#loc18 = loc("examples/kernels/binary_ops.py":111:22)
#loc19 = loc("examples/kernels/binary_ops.py":112:40)
#loc20 = loc("examples/kernels/binary_ops.py":112:52)
#loc21 = loc("examples/kernels/binary_ops.py":112:22)
#loc22 = loc("examples/kernels/binary_ops.py":114:31)
#loc23 = loc("examples/kernels/binary_ops.py":114:55)
#loc24 = loc("examples/kernels/binary_ops.py":114:37)
#loc25 = loc("examples/kernels/binary_ops.py":116:16)
#loc26 = loc("examples/kernels/binary_ops.py":117:16)
#loc27 = loc("examples/kernels/binary_ops.py":118:12)
#loc28 = loc("examples/kernels/binary_ops.py":119:21)
#loc29 = loc("examples/kernels/binary_ops.py":119:4)


// -----// IR Dump Before TritonGPUCombineTensorSelectAndIf (tritongpu-combine-tensor-select-and-if) ('builtin.module' operation) //----- //
#blocked = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>
#loc = loc("examples/kernels/binary_ops.py":97:0)
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.target = "cuda:89", "ttg.threads-per-warp" = 32 : i32} {
  tt.func public @add_2d_kernel(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg1: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg2: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg3: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg4: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg5: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg6: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg7: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0)) attributes {noinline = false} {
    %cst = arith.constant dense<0.000000e+00> : tensor<32x32xf32, #blocked> loc(#loc1)
    %c32_i32 = arith.constant 32 : i32 loc(#loc1)
    %0 = tt.get_program_id x : i32 loc(#loc2)
    %1 = tt.get_program_id y : i32 loc(#loc3)
    %2 = arith.muli %0, %c32_i32 : i32 loc(#loc4)
    %3 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc5)
    %4 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc5)
    %5 = tt.splat %2 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc6)
    %6 = arith.addi %5, %3 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc6)
    %7 = tt.splat %arg3 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc7)
    %8 = arith.remsi %6, %7 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc7)
    %9 = arith.muli %1, %c32_i32 : i32 loc(#loc8)
    %10 = tt.splat %9 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc9)
    %11 = arith.addi %10, %4 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc9)
    %12 = tt.splat %arg4 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc10)
    %13 = arith.remsi %11, %12 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc10)
    %14 = tt.expand_dims %8 {axis = 1 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> -> tensor<32x1xi32, #blocked> loc(#loc11)
    %15 = tt.splat %arg5 : i32 -> tensor<32x1xi32, #blocked> loc(#loc12)
    %16 = arith.muli %14, %15 : tensor<32x1xi32, #blocked> loc(#loc12)
    %17 = tt.expand_dims %13 {axis = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> -> tensor<1x32xi32, #blocked> loc(#loc13)
    %18 = tt.broadcast %16 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %19 = tt.broadcast %17 : tensor<1x32xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %20 = arith.addi %18, %19 : tensor<32x32xi32, #blocked> loc(#loc14)
    %21 = tt.splat %arg0 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc15)
    %22 = tt.addptr %21, %20 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc15)
    %23 = tt.splat %arg6 : i32 -> tensor<32x1xi32, #blocked> loc(#loc16)
    %24 = arith.muli %14, %23 : tensor<32x1xi32, #blocked> loc(#loc16)
    %25 = tt.broadcast %24 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc17)
    %26 = arith.addi %25, %19 : tensor<32x32xi32, #blocked> loc(#loc17)
    %27 = tt.splat %arg1 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc18)
    %28 = tt.addptr %27, %26 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc18)
    %29 = tt.splat %arg7 : i32 -> tensor<32x1xi32, #blocked> loc(#loc19)
    %30 = arith.muli %14, %29 : tensor<32x1xi32, #blocked> loc(#loc19)
    %31 = tt.broadcast %30 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc20)
    %32 = arith.addi %31, %19 : tensor<32x32xi32, #blocked> loc(#loc20)
    %33 = tt.splat %arg2 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc21)
    %34 = tt.addptr %33, %32 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc21)
    %35 = tt.splat %arg3 : i32 -> tensor<32x1xi32, #blocked> loc(#loc22)
    %36 = arith.cmpi slt, %14, %35 : tensor<32x1xi32, #blocked> loc(#loc22)
    %37 = tt.splat %arg4 : i32 -> tensor<1x32xi32, #blocked> loc(#loc23)
    %38 = arith.cmpi slt, %17, %37 : tensor<1x32xi32, #blocked> loc(#loc23)
    %39 = tt.broadcast %36 : tensor<32x1xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %40 = tt.broadcast %38 : tensor<1x32xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %41 = arith.andi %39, %40 : tensor<32x32xi1, #blocked> loc(#loc24)
    %42 = tt.load %22, %41, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc25)
    %43 = tt.load %28, %41, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc26)
    %44 = arith.addf %42, %43 : tensor<32x32xf32, #blocked> loc(#loc27)
    tt.store %34, %44, %41 : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc28)
    tt.return loc(#loc29)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("examples/kernels/binary_ops.py":106:26)
#loc3 = loc("examples/kernels/binary_ops.py":107:26)
#loc4 = loc("examples/kernels/binary_ops.py":108:22)
#loc5 = loc("examples/kernels/binary_ops.py":108:50)
#loc6 = loc("examples/kernels/binary_ops.py":108:37)
#loc7 = loc("examples/kernels/binary_ops.py":108:67)
#loc8 = loc("examples/kernels/binary_ops.py":109:22)
#loc9 = loc("examples/kernels/binary_ops.py":109:37)
#loc10 = loc("examples/kernels/binary_ops.py":109:67)
#loc11 = loc("examples/kernels/binary_ops.py":110:29)
#loc12 = loc("examples/kernels/binary_ops.py":110:40)
#loc13 = loc("examples/kernels/binary_ops.py":110:59)
#loc14 = loc("examples/kernels/binary_ops.py":110:52)
#loc15 = loc("examples/kernels/binary_ops.py":110:22)
#loc16 = loc("examples/kernels/binary_ops.py":111:40)
#loc17 = loc("examples/kernels/binary_ops.py":111:52)
#loc18 = loc("examples/kernels/binary_ops.py":111:22)
#loc19 = loc("examples/kernels/binary_ops.py":112:40)
#loc20 = loc("examples/kernels/binary_ops.py":112:52)
#loc21 = loc("examples/kernels/binary_ops.py":112:22)
#loc22 = loc("examples/kernels/binary_ops.py":114:31)
#loc23 = loc("examples/kernels/binary_ops.py":114:55)
#loc24 = loc("examples/kernels/binary_ops.py":114:37)
#loc25 = loc("examples/kernels/binary_ops.py":116:16)
#loc26 = loc("examples/kernels/binary_ops.py":117:16)
#loc27 = loc("examples/kernels/binary_ops.py":118:12)
#loc28 = loc("examples/kernels/binary_ops.py":119:21)
#loc29 = loc("examples/kernels/binary_ops.py":119:4)


// -----// IR Dump Before TritonGPUAllocateWarpGroups (tritongpu-allocate-warp-groups) ('builtin.module' operation) //----- //
#blocked = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>
#loc = loc("examples/kernels/binary_ops.py":97:0)
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.target = "cuda:89", "ttg.threads-per-warp" = 32 : i32} {
  tt.func public @add_2d_kernel(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg1: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg2: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg3: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg4: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg5: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg6: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg7: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0)) attributes {noinline = false} {
    %cst = arith.constant dense<0.000000e+00> : tensor<32x32xf32, #blocked> loc(#loc1)
    %c32_i32 = arith.constant 32 : i32 loc(#loc1)
    %0 = tt.get_program_id x : i32 loc(#loc2)
    %1 = tt.get_program_id y : i32 loc(#loc3)
    %2 = arith.muli %0, %c32_i32 : i32 loc(#loc4)
    %3 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc5)
    %4 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc5)
    %5 = tt.splat %2 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc6)
    %6 = arith.addi %5, %3 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc6)
    %7 = tt.splat %arg3 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc7)
    %8 = arith.remsi %6, %7 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc7)
    %9 = arith.muli %1, %c32_i32 : i32 loc(#loc8)
    %10 = tt.splat %9 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc9)
    %11 = arith.addi %10, %4 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc9)
    %12 = tt.splat %arg4 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc10)
    %13 = arith.remsi %11, %12 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc10)
    %14 = tt.expand_dims %8 {axis = 1 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> -> tensor<32x1xi32, #blocked> loc(#loc11)
    %15 = tt.splat %arg5 : i32 -> tensor<32x1xi32, #blocked> loc(#loc12)
    %16 = arith.muli %14, %15 : tensor<32x1xi32, #blocked> loc(#loc12)
    %17 = tt.expand_dims %13 {axis = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> -> tensor<1x32xi32, #blocked> loc(#loc13)
    %18 = tt.broadcast %16 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %19 = tt.broadcast %17 : tensor<1x32xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %20 = arith.addi %18, %19 : tensor<32x32xi32, #blocked> loc(#loc14)
    %21 = tt.splat %arg0 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc15)
    %22 = tt.addptr %21, %20 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc15)
    %23 = tt.splat %arg6 : i32 -> tensor<32x1xi32, #blocked> loc(#loc16)
    %24 = arith.muli %14, %23 : tensor<32x1xi32, #blocked> loc(#loc16)
    %25 = tt.broadcast %24 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc17)
    %26 = arith.addi %25, %19 : tensor<32x32xi32, #blocked> loc(#loc17)
    %27 = tt.splat %arg1 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc18)
    %28 = tt.addptr %27, %26 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc18)
    %29 = tt.splat %arg7 : i32 -> tensor<32x1xi32, #blocked> loc(#loc19)
    %30 = arith.muli %14, %29 : tensor<32x1xi32, #blocked> loc(#loc19)
    %31 = tt.broadcast %30 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc20)
    %32 = arith.addi %31, %19 : tensor<32x32xi32, #blocked> loc(#loc20)
    %33 = tt.splat %arg2 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc21)
    %34 = tt.addptr %33, %32 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc21)
    %35 = tt.splat %arg3 : i32 -> tensor<32x1xi32, #blocked> loc(#loc22)
    %36 = arith.cmpi slt, %14, %35 : tensor<32x1xi32, #blocked> loc(#loc22)
    %37 = tt.splat %arg4 : i32 -> tensor<1x32xi32, #blocked> loc(#loc23)
    %38 = arith.cmpi slt, %17, %37 : tensor<1x32xi32, #blocked> loc(#loc23)
    %39 = tt.broadcast %36 : tensor<32x1xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %40 = tt.broadcast %38 : tensor<1x32xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %41 = arith.andi %39, %40 : tensor<32x32xi1, #blocked> loc(#loc24)
    %42 = tt.load %22, %41, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc25)
    %43 = tt.load %28, %41, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc26)
    %44 = arith.addf %42, %43 : tensor<32x32xf32, #blocked> loc(#loc27)
    tt.store %34, %44, %41 : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc28)
    tt.return loc(#loc29)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("examples/kernels/binary_ops.py":106:26)
#loc3 = loc("examples/kernels/binary_ops.py":107:26)
#loc4 = loc("examples/kernels/binary_ops.py":108:22)
#loc5 = loc("examples/kernels/binary_ops.py":108:50)
#loc6 = loc("examples/kernels/binary_ops.py":108:37)
#loc7 = loc("examples/kernels/binary_ops.py":108:67)
#loc8 = loc("examples/kernels/binary_ops.py":109:22)
#loc9 = loc("examples/kernels/binary_ops.py":109:37)
#loc10 = loc("examples/kernels/binary_ops.py":109:67)
#loc11 = loc("examples/kernels/binary_ops.py":110:29)
#loc12 = loc("examples/kernels/binary_ops.py":110:40)
#loc13 = loc("examples/kernels/binary_ops.py":110:59)
#loc14 = loc("examples/kernels/binary_ops.py":110:52)
#loc15 = loc("examples/kernels/binary_ops.py":110:22)
#loc16 = loc("examples/kernels/binary_ops.py":111:40)
#loc17 = loc("examples/kernels/binary_ops.py":111:52)
#loc18 = loc("examples/kernels/binary_ops.py":111:22)
#loc19 = loc("examples/kernels/binary_ops.py":112:40)
#loc20 = loc("examples/kernels/binary_ops.py":112:52)
#loc21 = loc("examples/kernels/binary_ops.py":112:22)
#loc22 = loc("examples/kernels/binary_ops.py":114:31)
#loc23 = loc("examples/kernels/binary_ops.py":114:55)
#loc24 = loc("examples/kernels/binary_ops.py":114:37)
#loc25 = loc("examples/kernels/binary_ops.py":116:16)
#loc26 = loc("examples/kernels/binary_ops.py":117:16)
#loc27 = loc("examples/kernels/binary_ops.py":118:12)
#loc28 = loc("examples/kernels/binary_ops.py":119:21)
#loc29 = loc("examples/kernels/binary_ops.py":119:4)


// -----// IR Dump Before SCFToControlFlowPass (convert-scf-to-cf) ('builtin.module' operation) //----- //
#blocked = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>
#loc = loc("examples/kernels/binary_ops.py":97:0)
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.target = "cuda:89", "ttg.threads-per-warp" = 32 : i32, "ttg.total-num-warps" = 4 : i32} {
  tt.func public @add_2d_kernel(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg1: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg2: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg3: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg4: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg5: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg6: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg7: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0)) attributes {noinline = false} {
    %cst = arith.constant dense<0.000000e+00> : tensor<32x32xf32, #blocked> loc(#loc1)
    %c32_i32 = arith.constant 32 : i32 loc(#loc1)
    %0 = tt.get_program_id x : i32 loc(#loc2)
    %1 = tt.get_program_id y : i32 loc(#loc3)
    %2 = arith.muli %0, %c32_i32 : i32 loc(#loc4)
    %3 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc5)
    %4 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc5)
    %5 = tt.splat %2 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc6)
    %6 = arith.addi %5, %3 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc6)
    %7 = tt.splat %arg3 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc7)
    %8 = arith.remsi %6, %7 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc7)
    %9 = arith.muli %1, %c32_i32 : i32 loc(#loc8)
    %10 = tt.splat %9 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc9)
    %11 = arith.addi %10, %4 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc9)
    %12 = tt.splat %arg4 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc10)
    %13 = arith.remsi %11, %12 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc10)
    %14 = tt.expand_dims %8 {axis = 1 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> -> tensor<32x1xi32, #blocked> loc(#loc11)
    %15 = tt.splat %arg5 : i32 -> tensor<32x1xi32, #blocked> loc(#loc12)
    %16 = arith.muli %14, %15 : tensor<32x1xi32, #blocked> loc(#loc12)
    %17 = tt.expand_dims %13 {axis = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> -> tensor<1x32xi32, #blocked> loc(#loc13)
    %18 = tt.broadcast %16 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %19 = tt.broadcast %17 : tensor<1x32xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %20 = arith.addi %18, %19 : tensor<32x32xi32, #blocked> loc(#loc14)
    %21 = tt.splat %arg0 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc15)
    %22 = tt.addptr %21, %20 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc15)
    %23 = tt.splat %arg6 : i32 -> tensor<32x1xi32, #blocked> loc(#loc16)
    %24 = arith.muli %14, %23 : tensor<32x1xi32, #blocked> loc(#loc16)
    %25 = tt.broadcast %24 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc17)
    %26 = arith.addi %25, %19 : tensor<32x32xi32, #blocked> loc(#loc17)
    %27 = tt.splat %arg1 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc18)
    %28 = tt.addptr %27, %26 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc18)
    %29 = tt.splat %arg7 : i32 -> tensor<32x1xi32, #blocked> loc(#loc19)
    %30 = arith.muli %14, %29 : tensor<32x1xi32, #blocked> loc(#loc19)
    %31 = tt.broadcast %30 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc20)
    %32 = arith.addi %31, %19 : tensor<32x32xi32, #blocked> loc(#loc20)
    %33 = tt.splat %arg2 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc21)
    %34 = tt.addptr %33, %32 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc21)
    %35 = tt.splat %arg3 : i32 -> tensor<32x1xi32, #blocked> loc(#loc22)
    %36 = arith.cmpi slt, %14, %35 : tensor<32x1xi32, #blocked> loc(#loc22)
    %37 = tt.splat %arg4 : i32 -> tensor<1x32xi32, #blocked> loc(#loc23)
    %38 = arith.cmpi slt, %17, %37 : tensor<1x32xi32, #blocked> loc(#loc23)
    %39 = tt.broadcast %36 : tensor<32x1xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %40 = tt.broadcast %38 : tensor<1x32xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %41 = arith.andi %39, %40 : tensor<32x32xi1, #blocked> loc(#loc24)
    %42 = tt.load %22, %41, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc25)
    %43 = tt.load %28, %41, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc26)
    %44 = arith.addf %42, %43 : tensor<32x32xf32, #blocked> loc(#loc27)
    tt.store %34, %44, %41 : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc28)
    tt.return loc(#loc29)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("examples/kernels/binary_ops.py":106:26)
#loc3 = loc("examples/kernels/binary_ops.py":107:26)
#loc4 = loc("examples/kernels/binary_ops.py":108:22)
#loc5 = loc("examples/kernels/binary_ops.py":108:50)
#loc6 = loc("examples/kernels/binary_ops.py":108:37)
#loc7 = loc("examples/kernels/binary_ops.py":108:67)
#loc8 = loc("examples/kernels/binary_ops.py":109:22)
#loc9 = loc("examples/kernels/binary_ops.py":109:37)
#loc10 = loc("examples/kernels/binary_ops.py":109:67)
#loc11 = loc("examples/kernels/binary_ops.py":110:29)
#loc12 = loc("examples/kernels/binary_ops.py":110:40)
#loc13 = loc("examples/kernels/binary_ops.py":110:59)
#loc14 = loc("examples/kernels/binary_ops.py":110:52)
#loc15 = loc("examples/kernels/binary_ops.py":110:22)
#loc16 = loc("examples/kernels/binary_ops.py":111:40)
#loc17 = loc("examples/kernels/binary_ops.py":111:52)
#loc18 = loc("examples/kernels/binary_ops.py":111:22)
#loc19 = loc("examples/kernels/binary_ops.py":112:40)
#loc20 = loc("examples/kernels/binary_ops.py":112:52)
#loc21 = loc("examples/kernels/binary_ops.py":112:22)
#loc22 = loc("examples/kernels/binary_ops.py":114:31)
#loc23 = loc("examples/kernels/binary_ops.py":114:55)
#loc24 = loc("examples/kernels/binary_ops.py":114:37)
#loc25 = loc("examples/kernels/binary_ops.py":116:16)
#loc26 = loc("examples/kernels/binary_ops.py":117:16)
#loc27 = loc("examples/kernels/binary_ops.py":118:12)
#loc28 = loc("examples/kernels/binary_ops.py":119:21)
#loc29 = loc("examples/kernels/binary_ops.py":119:4)


// -----// IR Dump Before AllocateSharedMemory (allocate-shared-memory) ('builtin.module' operation) //----- //
#blocked = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>
#loc = loc("examples/kernels/binary_ops.py":97:0)
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.target = "cuda:89", "ttg.threads-per-warp" = 32 : i32, "ttg.total-num-warps" = 4 : i32} {
  tt.func public @add_2d_kernel(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg1: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg2: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg3: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg4: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg5: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg6: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg7: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0)) attributes {noinline = false} {
    %cst = arith.constant dense<0.000000e+00> : tensor<32x32xf32, #blocked> loc(#loc1)
    %c32_i32 = arith.constant 32 : i32 loc(#loc1)
    %0 = tt.get_program_id x : i32 loc(#loc2)
    %1 = tt.get_program_id y : i32 loc(#loc3)
    %2 = arith.muli %0, %c32_i32 : i32 loc(#loc4)
    %3 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc5)
    %4 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc5)
    %5 = tt.splat %2 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc6)
    %6 = arith.addi %5, %3 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc6)
    %7 = tt.splat %arg3 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc7)
    %8 = arith.remsi %6, %7 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc7)
    %9 = arith.muli %1, %c32_i32 : i32 loc(#loc8)
    %10 = tt.splat %9 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc9)
    %11 = arith.addi %10, %4 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc9)
    %12 = tt.splat %arg4 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc10)
    %13 = arith.remsi %11, %12 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc10)
    %14 = tt.expand_dims %8 {axis = 1 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> -> tensor<32x1xi32, #blocked> loc(#loc11)
    %15 = tt.splat %arg5 : i32 -> tensor<32x1xi32, #blocked> loc(#loc12)
    %16 = arith.muli %14, %15 : tensor<32x1xi32, #blocked> loc(#loc12)
    %17 = tt.expand_dims %13 {axis = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> -> tensor<1x32xi32, #blocked> loc(#loc13)
    %18 = tt.broadcast %16 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %19 = tt.broadcast %17 : tensor<1x32xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %20 = arith.addi %18, %19 : tensor<32x32xi32, #blocked> loc(#loc14)
    %21 = tt.splat %arg0 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc15)
    %22 = tt.addptr %21, %20 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc15)
    %23 = tt.splat %arg6 : i32 -> tensor<32x1xi32, #blocked> loc(#loc16)
    %24 = arith.muli %14, %23 : tensor<32x1xi32, #blocked> loc(#loc16)
    %25 = tt.broadcast %24 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc17)
    %26 = arith.addi %25, %19 : tensor<32x32xi32, #blocked> loc(#loc17)
    %27 = tt.splat %arg1 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc18)
    %28 = tt.addptr %27, %26 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc18)
    %29 = tt.splat %arg7 : i32 -> tensor<32x1xi32, #blocked> loc(#loc19)
    %30 = arith.muli %14, %29 : tensor<32x1xi32, #blocked> loc(#loc19)
    %31 = tt.broadcast %30 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc20)
    %32 = arith.addi %31, %19 : tensor<32x32xi32, #blocked> loc(#loc20)
    %33 = tt.splat %arg2 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc21)
    %34 = tt.addptr %33, %32 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc21)
    %35 = tt.splat %arg3 : i32 -> tensor<32x1xi32, #blocked> loc(#loc22)
    %36 = arith.cmpi slt, %14, %35 : tensor<32x1xi32, #blocked> loc(#loc22)
    %37 = tt.splat %arg4 : i32 -> tensor<1x32xi32, #blocked> loc(#loc23)
    %38 = arith.cmpi slt, %17, %37 : tensor<1x32xi32, #blocked> loc(#loc23)
    %39 = tt.broadcast %36 : tensor<32x1xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %40 = tt.broadcast %38 : tensor<1x32xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %41 = arith.andi %39, %40 : tensor<32x32xi1, #blocked> loc(#loc24)
    %42 = tt.load %22, %41, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc25)
    %43 = tt.load %28, %41, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc26)
    %44 = arith.addf %42, %43 : tensor<32x32xf32, #blocked> loc(#loc27)
    tt.store %34, %44, %41 : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc28)
    tt.return loc(#loc29)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("examples/kernels/binary_ops.py":106:26)
#loc3 = loc("examples/kernels/binary_ops.py":107:26)
#loc4 = loc("examples/kernels/binary_ops.py":108:22)
#loc5 = loc("examples/kernels/binary_ops.py":108:50)
#loc6 = loc("examples/kernels/binary_ops.py":108:37)
#loc7 = loc("examples/kernels/binary_ops.py":108:67)
#loc8 = loc("examples/kernels/binary_ops.py":109:22)
#loc9 = loc("examples/kernels/binary_ops.py":109:37)
#loc10 = loc("examples/kernels/binary_ops.py":109:67)
#loc11 = loc("examples/kernels/binary_ops.py":110:29)
#loc12 = loc("examples/kernels/binary_ops.py":110:40)
#loc13 = loc("examples/kernels/binary_ops.py":110:59)
#loc14 = loc("examples/kernels/binary_ops.py":110:52)
#loc15 = loc("examples/kernels/binary_ops.py":110:22)
#loc16 = loc("examples/kernels/binary_ops.py":111:40)
#loc17 = loc("examples/kernels/binary_ops.py":111:52)
#loc18 = loc("examples/kernels/binary_ops.py":111:22)
#loc19 = loc("examples/kernels/binary_ops.py":112:40)
#loc20 = loc("examples/kernels/binary_ops.py":112:52)
#loc21 = loc("examples/kernels/binary_ops.py":112:22)
#loc22 = loc("examples/kernels/binary_ops.py":114:31)
#loc23 = loc("examples/kernels/binary_ops.py":114:55)
#loc24 = loc("examples/kernels/binary_ops.py":114:37)
#loc25 = loc("examples/kernels/binary_ops.py":116:16)
#loc26 = loc("examples/kernels/binary_ops.py":117:16)
#loc27 = loc("examples/kernels/binary_ops.py":118:12)
#loc28 = loc("examples/kernels/binary_ops.py":119:21)
#loc29 = loc("examples/kernels/binary_ops.py":119:4)


// -----// IR Dump Before TritionTensorMemoryAllocationPass (triton-tensor-memory-allocation) ('builtin.module' operation) //----- //
#blocked = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>
#loc = loc("examples/kernels/binary_ops.py":97:0)
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.shared = 0 : i32, ttg.target = "cuda:89", "ttg.threads-per-warp" = 32 : i32, "ttg.total-num-warps" = 4 : i32} {
  tt.func public @add_2d_kernel(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg1: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg2: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg3: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg4: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg5: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg6: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg7: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0)) attributes {noinline = false} {
    %cst = arith.constant dense<0.000000e+00> : tensor<32x32xf32, #blocked> loc(#loc1)
    %c32_i32 = arith.constant 32 : i32 loc(#loc1)
    %0 = tt.get_program_id x : i32 loc(#loc2)
    %1 = tt.get_program_id y : i32 loc(#loc3)
    %2 = arith.muli %0, %c32_i32 : i32 loc(#loc4)
    %3 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc5)
    %4 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc5)
    %5 = tt.splat %2 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc6)
    %6 = arith.addi %5, %3 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc6)
    %7 = tt.splat %arg3 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc7)
    %8 = arith.remsi %6, %7 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc7)
    %9 = arith.muli %1, %c32_i32 : i32 loc(#loc8)
    %10 = tt.splat %9 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc9)
    %11 = arith.addi %10, %4 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc9)
    %12 = tt.splat %arg4 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc10)
    %13 = arith.remsi %11, %12 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc10)
    %14 = tt.expand_dims %8 {axis = 1 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> -> tensor<32x1xi32, #blocked> loc(#loc11)
    %15 = tt.splat %arg5 : i32 -> tensor<32x1xi32, #blocked> loc(#loc12)
    %16 = arith.muli %14, %15 : tensor<32x1xi32, #blocked> loc(#loc12)
    %17 = tt.expand_dims %13 {axis = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> -> tensor<1x32xi32, #blocked> loc(#loc13)
    %18 = tt.broadcast %16 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %19 = tt.broadcast %17 : tensor<1x32xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %20 = arith.addi %18, %19 : tensor<32x32xi32, #blocked> loc(#loc14)
    %21 = tt.splat %arg0 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc15)
    %22 = tt.addptr %21, %20 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc15)
    %23 = tt.splat %arg6 : i32 -> tensor<32x1xi32, #blocked> loc(#loc16)
    %24 = arith.muli %14, %23 : tensor<32x1xi32, #blocked> loc(#loc16)
    %25 = tt.broadcast %24 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc17)
    %26 = arith.addi %25, %19 : tensor<32x32xi32, #blocked> loc(#loc17)
    %27 = tt.splat %arg1 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc18)
    %28 = tt.addptr %27, %26 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc18)
    %29 = tt.splat %arg7 : i32 -> tensor<32x1xi32, #blocked> loc(#loc19)
    %30 = arith.muli %14, %29 : tensor<32x1xi32, #blocked> loc(#loc19)
    %31 = tt.broadcast %30 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc20)
    %32 = arith.addi %31, %19 : tensor<32x32xi32, #blocked> loc(#loc20)
    %33 = tt.splat %arg2 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc21)
    %34 = tt.addptr %33, %32 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc21)
    %35 = tt.splat %arg3 : i32 -> tensor<32x1xi32, #blocked> loc(#loc22)
    %36 = arith.cmpi slt, %14, %35 : tensor<32x1xi32, #blocked> loc(#loc22)
    %37 = tt.splat %arg4 : i32 -> tensor<1x32xi32, #blocked> loc(#loc23)
    %38 = arith.cmpi slt, %17, %37 : tensor<1x32xi32, #blocked> loc(#loc23)
    %39 = tt.broadcast %36 : tensor<32x1xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %40 = tt.broadcast %38 : tensor<1x32xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %41 = arith.andi %39, %40 : tensor<32x32xi1, #blocked> loc(#loc24)
    %42 = tt.load %22, %41, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc25)
    %43 = tt.load %28, %41, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc26)
    %44 = arith.addf %42, %43 : tensor<32x32xf32, #blocked> loc(#loc27)
    tt.store %34, %44, %41 : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc28)
    tt.return loc(#loc29)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("examples/kernels/binary_ops.py":106:26)
#loc3 = loc("examples/kernels/binary_ops.py":107:26)
#loc4 = loc("examples/kernels/binary_ops.py":108:22)
#loc5 = loc("examples/kernels/binary_ops.py":108:50)
#loc6 = loc("examples/kernels/binary_ops.py":108:37)
#loc7 = loc("examples/kernels/binary_ops.py":108:67)
#loc8 = loc("examples/kernels/binary_ops.py":109:22)
#loc9 = loc("examples/kernels/binary_ops.py":109:37)
#loc10 = loc("examples/kernels/binary_ops.py":109:67)
#loc11 = loc("examples/kernels/binary_ops.py":110:29)
#loc12 = loc("examples/kernels/binary_ops.py":110:40)
#loc13 = loc("examples/kernels/binary_ops.py":110:59)
#loc14 = loc("examples/kernels/binary_ops.py":110:52)
#loc15 = loc("examples/kernels/binary_ops.py":110:22)
#loc16 = loc("examples/kernels/binary_ops.py":111:40)
#loc17 = loc("examples/kernels/binary_ops.py":111:52)
#loc18 = loc("examples/kernels/binary_ops.py":111:22)
#loc19 = loc("examples/kernels/binary_ops.py":112:40)
#loc20 = loc("examples/kernels/binary_ops.py":112:52)
#loc21 = loc("examples/kernels/binary_ops.py":112:22)
#loc22 = loc("examples/kernels/binary_ops.py":114:31)
#loc23 = loc("examples/kernels/binary_ops.py":114:55)
#loc24 = loc("examples/kernels/binary_ops.py":114:37)
#loc25 = loc("examples/kernels/binary_ops.py":116:16)
#loc26 = loc("examples/kernels/binary_ops.py":117:16)
#loc27 = loc("examples/kernels/binary_ops.py":118:12)
#loc28 = loc("examples/kernels/binary_ops.py":119:21)
#loc29 = loc("examples/kernels/binary_ops.py":119:4)


// -----// IR Dump Before TritonGPUGlobalScratchAllocationPass (tritongpu-global-scratch-memory-allocation) ('builtin.module' operation) //----- //
#blocked = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>
#loc = loc("examples/kernels/binary_ops.py":97:0)
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.shared = 0 : i32, ttg.target = "cuda:89", ttg.tensor_memory_size = 0 : i32, "ttg.threads-per-warp" = 32 : i32, "ttg.total-num-warps" = 4 : i32} {
  tt.func public @add_2d_kernel(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg1: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg2: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg3: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg4: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg5: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg6: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg7: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0)) attributes {noinline = false} {
    %cst = arith.constant dense<0.000000e+00> : tensor<32x32xf32, #blocked> loc(#loc1)
    %c32_i32 = arith.constant 32 : i32 loc(#loc1)
    %0 = tt.get_program_id x : i32 loc(#loc2)
    %1 = tt.get_program_id y : i32 loc(#loc3)
    %2 = arith.muli %0, %c32_i32 : i32 loc(#loc4)
    %3 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc5)
    %4 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc5)
    %5 = tt.splat %2 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc6)
    %6 = arith.addi %5, %3 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc6)
    %7 = tt.splat %arg3 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc7)
    %8 = arith.remsi %6, %7 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc7)
    %9 = arith.muli %1, %c32_i32 : i32 loc(#loc8)
    %10 = tt.splat %9 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc9)
    %11 = arith.addi %10, %4 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc9)
    %12 = tt.splat %arg4 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc10)
    %13 = arith.remsi %11, %12 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc10)
    %14 = tt.expand_dims %8 {axis = 1 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> -> tensor<32x1xi32, #blocked> loc(#loc11)
    %15 = tt.splat %arg5 : i32 -> tensor<32x1xi32, #blocked> loc(#loc12)
    %16 = arith.muli %14, %15 : tensor<32x1xi32, #blocked> loc(#loc12)
    %17 = tt.expand_dims %13 {axis = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> -> tensor<1x32xi32, #blocked> loc(#loc13)
    %18 = tt.broadcast %16 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %19 = tt.broadcast %17 : tensor<1x32xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %20 = arith.addi %18, %19 : tensor<32x32xi32, #blocked> loc(#loc14)
    %21 = tt.splat %arg0 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc15)
    %22 = tt.addptr %21, %20 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc15)
    %23 = tt.splat %arg6 : i32 -> tensor<32x1xi32, #blocked> loc(#loc16)
    %24 = arith.muli %14, %23 : tensor<32x1xi32, #blocked> loc(#loc16)
    %25 = tt.broadcast %24 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc17)
    %26 = arith.addi %25, %19 : tensor<32x32xi32, #blocked> loc(#loc17)
    %27 = tt.splat %arg1 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc18)
    %28 = tt.addptr %27, %26 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc18)
    %29 = tt.splat %arg7 : i32 -> tensor<32x1xi32, #blocked> loc(#loc19)
    %30 = arith.muli %14, %29 : tensor<32x1xi32, #blocked> loc(#loc19)
    %31 = tt.broadcast %30 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc20)
    %32 = arith.addi %31, %19 : tensor<32x32xi32, #blocked> loc(#loc20)
    %33 = tt.splat %arg2 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc21)
    %34 = tt.addptr %33, %32 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc21)
    %35 = tt.splat %arg3 : i32 -> tensor<32x1xi32, #blocked> loc(#loc22)
    %36 = arith.cmpi slt, %14, %35 : tensor<32x1xi32, #blocked> loc(#loc22)
    %37 = tt.splat %arg4 : i32 -> tensor<1x32xi32, #blocked> loc(#loc23)
    %38 = arith.cmpi slt, %17, %37 : tensor<1x32xi32, #blocked> loc(#loc23)
    %39 = tt.broadcast %36 : tensor<32x1xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %40 = tt.broadcast %38 : tensor<1x32xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %41 = arith.andi %39, %40 : tensor<32x32xi1, #blocked> loc(#loc24)
    %42 = tt.load %22, %41, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc25)
    %43 = tt.load %28, %41, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc26)
    %44 = arith.addf %42, %43 : tensor<32x32xf32, #blocked> loc(#loc27)
    tt.store %34, %44, %41 : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc28)
    tt.return loc(#loc29)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("examples/kernels/binary_ops.py":106:26)
#loc3 = loc("examples/kernels/binary_ops.py":107:26)
#loc4 = loc("examples/kernels/binary_ops.py":108:22)
#loc5 = loc("examples/kernels/binary_ops.py":108:50)
#loc6 = loc("examples/kernels/binary_ops.py":108:37)
#loc7 = loc("examples/kernels/binary_ops.py":108:67)
#loc8 = loc("examples/kernels/binary_ops.py":109:22)
#loc9 = loc("examples/kernels/binary_ops.py":109:37)
#loc10 = loc("examples/kernels/binary_ops.py":109:67)
#loc11 = loc("examples/kernels/binary_ops.py":110:29)
#loc12 = loc("examples/kernels/binary_ops.py":110:40)
#loc13 = loc("examples/kernels/binary_ops.py":110:59)
#loc14 = loc("examples/kernels/binary_ops.py":110:52)
#loc15 = loc("examples/kernels/binary_ops.py":110:22)
#loc16 = loc("examples/kernels/binary_ops.py":111:40)
#loc17 = loc("examples/kernels/binary_ops.py":111:52)
#loc18 = loc("examples/kernels/binary_ops.py":111:22)
#loc19 = loc("examples/kernels/binary_ops.py":112:40)
#loc20 = loc("examples/kernels/binary_ops.py":112:52)
#loc21 = loc("examples/kernels/binary_ops.py":112:22)
#loc22 = loc("examples/kernels/binary_ops.py":114:31)
#loc23 = loc("examples/kernels/binary_ops.py":114:55)
#loc24 = loc("examples/kernels/binary_ops.py":114:37)
#loc25 = loc("examples/kernels/binary_ops.py":116:16)
#loc26 = loc("examples/kernels/binary_ops.py":117:16)
#loc27 = loc("examples/kernels/binary_ops.py":118:12)
#loc28 = loc("examples/kernels/binary_ops.py":119:21)
#loc29 = loc("examples/kernels/binary_ops.py":119:4)


// -----// IR Dump Before ConvertTritonGPUToLLVM (convert-triton-gpu-to-llvm) ('builtin.module' operation) //----- //
#blocked = #ttg.blocked<{sizePerThread = [1, 4], threadsPerWarp = [4, 8], warpsPerCTA = [4, 1], order = [1, 0]}>
#loc = loc("examples/kernels/binary_ops.py":97:0)
module attributes {ttg.global_scratch_memory_alignment = 1 : i32, ttg.global_scratch_memory_size = 0 : i32, "ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.shared = 0 : i32, ttg.target = "cuda:89", ttg.tensor_memory_size = 0 : i32, "ttg.threads-per-warp" = 32 : i32, "ttg.total-num-warps" = 4 : i32} {
  tt.func public @add_2d_kernel(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg1: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg2: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg3: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg4: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg5: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg6: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg7: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0)) attributes {noinline = false, ttg.global_scratch_memory_alignment = 1 : i32, ttg.global_scratch_memory_size = 0 : i32} {
    %cst = arith.constant dense<0.000000e+00> : tensor<32x32xf32, #blocked> loc(#loc1)
    %c32_i32 = arith.constant 32 : i32 loc(#loc1)
    %0 = tt.get_program_id x : i32 loc(#loc2)
    %1 = tt.get_program_id y : i32 loc(#loc3)
    %2 = arith.muli %0, %c32_i32 : i32 loc(#loc4)
    %3 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc5)
    %4 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc5)
    %5 = tt.splat %2 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc6)
    %6 = arith.addi %5, %3 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc6)
    %7 = tt.splat %arg3 : i32 -> tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc7)
    %8 = arith.remsi %6, %7 : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> loc(#loc7)
    %9 = arith.muli %1, %c32_i32 : i32 loc(#loc8)
    %10 = tt.splat %9 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc9)
    %11 = arith.addi %10, %4 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc9)
    %12 = tt.splat %arg4 : i32 -> tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc10)
    %13 = arith.remsi %11, %12 : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> loc(#loc10)
    %14 = tt.expand_dims %8 {axis = 1 : i32} : tensor<32xi32, #ttg.slice<{dim = 1, parent = #blocked}>> -> tensor<32x1xi32, #blocked> loc(#loc11)
    %15 = tt.splat %arg5 : i32 -> tensor<32x1xi32, #blocked> loc(#loc12)
    %16 = arith.muli %14, %15 : tensor<32x1xi32, #blocked> loc(#loc12)
    %17 = tt.expand_dims %13 {axis = 0 : i32} : tensor<32xi32, #ttg.slice<{dim = 0, parent = #blocked}>> -> tensor<1x32xi32, #blocked> loc(#loc13)
    %18 = tt.broadcast %16 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %19 = tt.broadcast %17 : tensor<1x32xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc14)
    %20 = arith.addi %18, %19 : tensor<32x32xi32, #blocked> loc(#loc14)
    %21 = tt.splat %arg0 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc15)
    %22 = tt.addptr %21, %20 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc15)
    %23 = tt.splat %arg6 : i32 -> tensor<32x1xi32, #blocked> loc(#loc16)
    %24 = arith.muli %14, %23 : tensor<32x1xi32, #blocked> loc(#loc16)
    %25 = tt.broadcast %24 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc17)
    %26 = arith.addi %25, %19 : tensor<32x32xi32, #blocked> loc(#loc17)
    %27 = tt.splat %arg1 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc18)
    %28 = tt.addptr %27, %26 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc18)
    %29 = tt.splat %arg7 : i32 -> tensor<32x1xi32, #blocked> loc(#loc19)
    %30 = arith.muli %14, %29 : tensor<32x1xi32, #blocked> loc(#loc19)
    %31 = tt.broadcast %30 : tensor<32x1xi32, #blocked> -> tensor<32x32xi32, #blocked> loc(#loc20)
    %32 = arith.addi %31, %19 : tensor<32x32xi32, #blocked> loc(#loc20)
    %33 = tt.splat %arg2 : !tt.ptr<f32> -> tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc21)
    %34 = tt.addptr %33, %32 : tensor<32x32x!tt.ptr<f32>, #blocked>, tensor<32x32xi32, #blocked> loc(#loc21)
    %35 = tt.splat %arg3 : i32 -> tensor<32x1xi32, #blocked> loc(#loc22)
    %36 = arith.cmpi slt, %14, %35 : tensor<32x1xi32, #blocked> loc(#loc22)
    %37 = tt.splat %arg4 : i32 -> tensor<1x32xi32, #blocked> loc(#loc23)
    %38 = arith.cmpi slt, %17, %37 : tensor<1x32xi32, #blocked> loc(#loc23)
    %39 = tt.broadcast %36 : tensor<32x1xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %40 = tt.broadcast %38 : tensor<1x32xi1, #blocked> -> tensor<32x32xi1, #blocked> loc(#loc24)
    %41 = arith.andi %39, %40 : tensor<32x32xi1, #blocked> loc(#loc24)
    %42 = tt.load %22, %41, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc25)
    %43 = tt.load %28, %41, %cst : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc26)
    %44 = arith.addf %42, %43 : tensor<32x32xf32, #blocked> loc(#loc27)
    tt.store %34, %44, %41 : tensor<32x32x!tt.ptr<f32>, #blocked> loc(#loc28)
    tt.return loc(#loc29)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("examples/kernels/binary_ops.py":106:26)
#loc3 = loc("examples/kernels/binary_ops.py":107:26)
#loc4 = loc("examples/kernels/binary_ops.py":108:22)
#loc5 = loc("examples/kernels/binary_ops.py":108:50)
#loc6 = loc("examples/kernels/binary_ops.py":108:37)
#loc7 = loc("examples/kernels/binary_ops.py":108:67)
#loc8 = loc("examples/kernels/binary_ops.py":109:22)
#loc9 = loc("examples/kernels/binary_ops.py":109:37)
#loc10 = loc("examples/kernels/binary_ops.py":109:67)
#loc11 = loc("examples/kernels/binary_ops.py":110:29)
#loc12 = loc("examples/kernels/binary_ops.py":110:40)
#loc13 = loc("examples/kernels/binary_ops.py":110:59)
#loc14 = loc("examples/kernels/binary_ops.py":110:52)
#loc15 = loc("examples/kernels/binary_ops.py":110:22)
#loc16 = loc("examples/kernels/binary_ops.py":111:40)
#loc17 = loc("examples/kernels/binary_ops.py":111:52)
#loc18 = loc("examples/kernels/binary_ops.py":111:22)
#loc19 = loc("examples/kernels/binary_ops.py":112:40)
#loc20 = loc("examples/kernels/binary_ops.py":112:52)
#loc21 = loc("examples/kernels/binary_ops.py":112:22)
#loc22 = loc("examples/kernels/binary_ops.py":114:31)
#loc23 = loc("examples/kernels/binary_ops.py":114:55)
#loc24 = loc("examples/kernels/binary_ops.py":114:37)
#loc25 = loc("examples/kernels/binary_ops.py":116:16)
#loc26 = loc("examples/kernels/binary_ops.py":117:16)
#loc27 = loc("examples/kernels/binary_ops.py":118:12)
#loc28 = loc("examples/kernels/binary_ops.py":119:21)
#loc29 = loc("examples/kernels/binary_ops.py":119:4)


// -----// IR Dump Before Canonicalizer (canonicalize) ('builtin.module' operation) //----- //
#loc = loc("examples/kernels/binary_ops.py":97:0)
module attributes {ttg.global_scratch_memory_alignment = 1 : i32, ttg.global_scratch_memory_size = 0 : i32, "ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.shared = 0 : i32, ttg.target = "cuda:89", ttg.tensor_memory_size = 0 : i32, "ttg.threads-per-warp" = 32 : i32, "ttg.total-num-warps" = 4 : i32} {
  llvm.mlir.global external @global_smem() {addr_space = 3 : i32, alignment = 16 : i64} : !llvm.array<0 x i8> loc(#loc)
  llvm.func @add_2d_kernel(%arg0: !llvm.ptr<1> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg1: !llvm.ptr<1> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg2: !llvm.ptr<1> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg3: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg4: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg5: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg6: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg7: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg8: !llvm.ptr<1> loc("examples/kernels/binary_ops.py":97:0)) attributes {noinline = false, nvvm.kernel = 1 : ui1, nvvm.reqntid = array<i32: 128>, ttg.global_scratch_memory_alignment = 1 : i32, ttg.global_scratch_memory_size = 0 : i32} {
    %0 = llvm.mlir.constant(0.000000e+00 : f32) : f32 loc(#loc1)
    %1 = llvm.bitcast %0 : f32 to f32 loc(#loc1)
    %2 = llvm.mlir.undef : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> loc(#loc1)
    %3 = llvm.insertvalue %1, %2[0] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc1)
    %4 = llvm.insertvalue %1, %3[1] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc1)
    %5 = llvm.insertvalue %1, %4[2] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc1)
    %6 = llvm.insertvalue %1, %5[3] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc1)
    %7 = llvm.insertvalue %1, %6[4] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc1)
    %8 = llvm.insertvalue %1, %7[5] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc1)
    %9 = llvm.insertvalue %1, %8[6] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc1)
    %10 = llvm.insertvalue %1, %9[7] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc1)
    %11 = llvm.mlir.constant(32 : i32) : i32 loc(#loc1)
    %12 = llvm.call_intrinsic "llvm.nvvm.read.ptx.sreg.ctaid.x"() : () -> i32 loc(#loc2)
    %13 = llvm.call_intrinsic "llvm.nvvm.read.ptx.sreg.ctaid.y"() : () -> i32 loc(#loc3)
    %14 = llvm.mul %12, %11 : i32 loc(#loc4)
    %15 = llvm.mlir.constant(0 : index) : i32 loc(#loc5)
    %16 = nvvm.read.ptx.sreg.tid.x : i32 loc(#loc5)
    %17 = llvm.mlir.constant(32 : i32) : i32 loc(#loc5)
    %18 = llvm.urem %16, %17 : i32 loc(#loc5)
    %19 = llvm.udiv %16, %17 : i32 loc(#loc5)
    %20 = llvm.mlir.constant(0 : i32) : i32 loc(#loc5)
    %21 = nvgpu.cluster_id loc(#loc5)
    %22 = llvm.mlir.constant(0 : i32) : i32 loc(#loc5)
    %23 = llvm.mlir.constant(0 : i32) : i32 loc(#loc5)
    %24 = llvm.mlir.constant(1 : i32) : i32 loc(#loc5)
    %25 = llvm.and %18, %24 : i32 loc(#loc5)
    %26 = llvm.icmp "eq" %25, %23 : i32 loc(#loc5)
    %27 = llvm.mlir.constant(2 : i32) : i32 loc(#loc5)
    %28 = llvm.and %18, %27 : i32 loc(#loc5)
    %29 = llvm.icmp "eq" %28, %23 : i32 loc(#loc5)
    %30 = llvm.mlir.constant(4 : i32) : i32 loc(#loc5)
    %31 = llvm.and %18, %30 : i32 loc(#loc5)
    %32 = llvm.icmp "eq" %31, %23 : i32 loc(#loc5)
    %33 = llvm.mlir.constant(8 : i32) : i32 loc(#loc5)
    %34 = llvm.and %18, %33 : i32 loc(#loc5)
    %35 = llvm.icmp "eq" %34, %23 : i32 loc(#loc5)
    %36 = llvm.mlir.constant(1 : i32) : i32 loc(#loc5)
    %37 = llvm.select %35, %23, %36 : i1, i32 loc(#loc5)
    %38 = llvm.xor %23, %37 : i32 loc(#loc5)
    %39 = llvm.mlir.constant(16 : i32) : i32 loc(#loc5)
    %40 = llvm.and %18, %39 : i32 loc(#loc5)
    %41 = llvm.icmp "eq" %40, %23 : i32 loc(#loc5)
    %42 = llvm.mlir.constant(2 : i32) : i32 loc(#loc5)
    %43 = llvm.select %41, %23, %42 : i1, i32 loc(#loc5)
    %44 = llvm.xor %38, %43 : i32 loc(#loc5)
    %45 = llvm.mlir.constant(1 : i32) : i32 loc(#loc5)
    %46 = llvm.and %19, %45 : i32 loc(#loc5)
    %47 = llvm.icmp "eq" %46, %23 : i32 loc(#loc5)
    %48 = llvm.mlir.constant(4 : i32) : i32 loc(#loc5)
    %49 = llvm.select %47, %23, %48 : i1, i32 loc(#loc5)
    %50 = llvm.xor %44, %49 : i32 loc(#loc5)
    %51 = llvm.mlir.constant(2 : i32) : i32 loc(#loc5)
    %52 = llvm.and %19, %51 : i32 loc(#loc5)
    %53 = llvm.icmp "eq" %52, %23 : i32 loc(#loc5)
    %54 = llvm.mlir.constant(8 : i32) : i32 loc(#loc5)
    %55 = llvm.select %53, %23, %54 : i1, i32 loc(#loc5)
    %56 = llvm.xor %50, %55 : i32 loc(#loc5)
    %57 = llvm.mlir.constant(0 : i32) : i32 loc(#loc5)
    %58 = llvm.xor %56, %57 : i32 loc(#loc5)
    %59 = llvm.mlir.constant(16 : i32) : i32 loc(#loc5)
    %60 = llvm.xor %56, %59 : i32 loc(#loc5)
    %61 = llvm.add %58, %15 : i32 loc(#loc5)
    %62 = llvm.add %60, %15 : i32 loc(#loc5)
    %63 = llvm.mlir.undef : !llvm.struct<(i32, i32)> loc(#loc5)
    %64 = llvm.insertvalue %61, %63[0] : !llvm.struct<(i32, i32)>  loc(#loc5)
    %65 = llvm.insertvalue %62, %64[1] : !llvm.struct<(i32, i32)>  loc(#loc5)
    %66 = llvm.mlir.constant(0 : index) : i32 loc(#loc5)
    %67 = nvvm.read.ptx.sreg.tid.x : i32 loc(#loc5)
    %68 = llvm.mlir.constant(32 : i32) : i32 loc(#loc5)
    %69 = llvm.urem %67, %68 : i32 loc(#loc5)
    %70 = llvm.udiv %67, %68 : i32 loc(#loc5)
    %71 = llvm.mlir.constant(0 : i32) : i32 loc(#loc5)
    %72 = nvgpu.cluster_id loc(#loc5)
    %73 = llvm.mlir.constant(0 : i32) : i32 loc(#loc5)
    %74 = llvm.mlir.constant(0 : i32) : i32 loc(#loc5)
    %75 = llvm.mlir.constant(1 : i32) : i32 loc(#loc5)
    %76 = llvm.and %69, %75 : i32 loc(#loc5)
    %77 = llvm.icmp "eq" %76, %74 : i32 loc(#loc5)
    %78 = llvm.mlir.constant(4 : i32) : i32 loc(#loc5)
    %79 = llvm.select %77, %74, %78 : i1, i32 loc(#loc5)
    %80 = llvm.xor %74, %79 : i32 loc(#loc5)
    %81 = llvm.mlir.constant(2 : i32) : i32 loc(#loc5)
    %82 = llvm.and %69, %81 : i32 loc(#loc5)
    %83 = llvm.icmp "eq" %82, %74 : i32 loc(#loc5)
    %84 = llvm.mlir.constant(8 : i32) : i32 loc(#loc5)
    %85 = llvm.select %83, %74, %84 : i1, i32 loc(#loc5)
    %86 = llvm.xor %80, %85 : i32 loc(#loc5)
    %87 = llvm.mlir.constant(4 : i32) : i32 loc(#loc5)
    %88 = llvm.and %69, %87 : i32 loc(#loc5)
    %89 = llvm.icmp "eq" %88, %74 : i32 loc(#loc5)
    %90 = llvm.mlir.constant(16 : i32) : i32 loc(#loc5)
    %91 = llvm.select %89, %74, %90 : i1, i32 loc(#loc5)
    %92 = llvm.xor %86, %91 : i32 loc(#loc5)
    %93 = llvm.mlir.constant(8 : i32) : i32 loc(#loc5)
    %94 = llvm.and %69, %93 : i32 loc(#loc5)
    %95 = llvm.icmp "eq" %94, %74 : i32 loc(#loc5)
    %96 = llvm.mlir.constant(16 : i32) : i32 loc(#loc5)
    %97 = llvm.and %69, %96 : i32 loc(#loc5)
    %98 = llvm.icmp "eq" %97, %74 : i32 loc(#loc5)
    %99 = llvm.mlir.constant(1 : i32) : i32 loc(#loc5)
    %100 = llvm.and %70, %99 : i32 loc(#loc5)
    %101 = llvm.icmp "eq" %100, %74 : i32 loc(#loc5)
    %102 = llvm.mlir.constant(2 : i32) : i32 loc(#loc5)
    %103 = llvm.and %70, %102 : i32 loc(#loc5)
    %104 = llvm.icmp "eq" %103, %74 : i32 loc(#loc5)
    %105 = llvm.mlir.constant(0 : i32) : i32 loc(#loc5)
    %106 = llvm.xor %92, %105 : i32 loc(#loc5)
    %107 = llvm.mlir.constant(1 : i32) : i32 loc(#loc5)
    %108 = llvm.xor %92, %107 : i32 loc(#loc5)
    %109 = llvm.mlir.constant(2 : i32) : i32 loc(#loc5)
    %110 = llvm.xor %92, %109 : i32 loc(#loc5)
    %111 = llvm.mlir.constant(3 : i32) : i32 loc(#loc5)
    %112 = llvm.xor %92, %111 : i32 loc(#loc5)
    %113 = llvm.add %106, %66 : i32 loc(#loc5)
    %114 = llvm.add %108, %66 : i32 loc(#loc5)
    %115 = llvm.add %110, %66 : i32 loc(#loc5)
    %116 = llvm.add %112, %66 : i32 loc(#loc5)
    %117 = llvm.mlir.undef : !llvm.struct<(i32, i32, i32, i32)> loc(#loc5)
    %118 = llvm.insertvalue %113, %117[0] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc5)
    %119 = llvm.insertvalue %114, %118[1] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc5)
    %120 = llvm.insertvalue %115, %119[2] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc5)
    %121 = llvm.insertvalue %116, %120[3] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc5)
    %122 = llvm.bitcast %14 : i32 to i32 loc(#loc6)
    %123 = llvm.mlir.undef : !llvm.struct<(i32, i32)> loc(#loc6)
    %124 = llvm.insertvalue %122, %123[0] : !llvm.struct<(i32, i32)>  loc(#loc6)
    %125 = llvm.insertvalue %122, %124[1] : !llvm.struct<(i32, i32)>  loc(#loc6)
    %126 = llvm.extractvalue %125[0] : !llvm.struct<(i32, i32)>  loc(#loc6)
    %127 = llvm.extractvalue %125[1] : !llvm.struct<(i32, i32)>  loc(#loc6)
    %128 = llvm.extractvalue %65[0] : !llvm.struct<(i32, i32)>  loc(#loc6)
    %129 = llvm.extractvalue %65[1] : !llvm.struct<(i32, i32)>  loc(#loc6)
    %130 = llvm.add %126, %128 : i32 loc(#loc6)
    %131 = llvm.add %127, %129 : i32 loc(#loc6)
    %132 = llvm.mlir.undef : !llvm.struct<(i32, i32)> loc(#loc6)
    %133 = llvm.insertvalue %130, %132[0] : !llvm.struct<(i32, i32)>  loc(#loc6)
    %134 = llvm.insertvalue %131, %133[1] : !llvm.struct<(i32, i32)>  loc(#loc6)
    %135 = llvm.bitcast %arg3 : i32 to i32 loc(#loc7)
    %136 = llvm.mlir.undef : !llvm.struct<(i32, i32)> loc(#loc7)
    %137 = llvm.insertvalue %135, %136[0] : !llvm.struct<(i32, i32)>  loc(#loc7)
    %138 = llvm.insertvalue %135, %137[1] : !llvm.struct<(i32, i32)>  loc(#loc7)
    %139 = llvm.extractvalue %134[0] : !llvm.struct<(i32, i32)>  loc(#loc7)
    %140 = llvm.extractvalue %134[1] : !llvm.struct<(i32, i32)>  loc(#loc7)
    %141 = llvm.extractvalue %138[0] : !llvm.struct<(i32, i32)>  loc(#loc7)
    %142 = llvm.extractvalue %138[1] : !llvm.struct<(i32, i32)>  loc(#loc7)
    %143 = llvm.srem %139, %141 : i32 loc(#loc7)
    %144 = llvm.srem %140, %142 : i32 loc(#loc7)
    %145 = llvm.mlir.undef : !llvm.struct<(i32, i32)> loc(#loc7)
    %146 = llvm.insertvalue %143, %145[0] : !llvm.struct<(i32, i32)>  loc(#loc7)
    %147 = llvm.insertvalue %144, %146[1] : !llvm.struct<(i32, i32)>  loc(#loc7)
    %148 = llvm.mul %13, %11 : i32 loc(#loc8)
    %149 = llvm.bitcast %148 : i32 to i32 loc(#loc9)
    %150 = llvm.mlir.undef : !llvm.struct<(i32, i32, i32, i32)> loc(#loc9)
    %151 = llvm.insertvalue %149, %150[0] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc9)
    %152 = llvm.insertvalue %149, %151[1] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc9)
    %153 = llvm.insertvalue %149, %152[2] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc9)
    %154 = llvm.insertvalue %149, %153[3] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc9)
    %155 = llvm.extractvalue %154[0] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc9)
    %156 = llvm.extractvalue %154[1] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc9)
    %157 = llvm.extractvalue %154[2] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc9)
    %158 = llvm.extractvalue %154[3] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc9)
    %159 = llvm.extractvalue %121[0] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc9)
    %160 = llvm.extractvalue %121[1] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc9)
    %161 = llvm.extractvalue %121[2] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc9)
    %162 = llvm.extractvalue %121[3] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc9)
    %163 = llvm.add %155, %159 : i32 loc(#loc9)
    %164 = llvm.add %156, %160 : i32 loc(#loc9)
    %165 = llvm.add %157, %161 : i32 loc(#loc9)
    %166 = llvm.add %158, %162 : i32 loc(#loc9)
    %167 = llvm.mlir.undef : !llvm.struct<(i32, i32, i32, i32)> loc(#loc9)
    %168 = llvm.insertvalue %163, %167[0] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc9)
    %169 = llvm.insertvalue %164, %168[1] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc9)
    %170 = llvm.insertvalue %165, %169[2] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc9)
    %171 = llvm.insertvalue %166, %170[3] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc9)
    %172 = llvm.bitcast %arg4 : i32 to i32 loc(#loc10)
    %173 = llvm.mlir.undef : !llvm.struct<(i32, i32, i32, i32)> loc(#loc10)
    %174 = llvm.insertvalue %172, %173[0] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc10)
    %175 = llvm.insertvalue %172, %174[1] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc10)
    %176 = llvm.insertvalue %172, %175[2] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc10)
    %177 = llvm.insertvalue %172, %176[3] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc10)
    %178 = llvm.extractvalue %171[0] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc10)
    %179 = llvm.extractvalue %171[1] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc10)
    %180 = llvm.extractvalue %171[2] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc10)
    %181 = llvm.extractvalue %171[3] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc10)
    %182 = llvm.extractvalue %177[0] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc10)
    %183 = llvm.extractvalue %177[1] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc10)
    %184 = llvm.extractvalue %177[2] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc10)
    %185 = llvm.extractvalue %177[3] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc10)
    %186 = llvm.srem %178, %182 : i32 loc(#loc10)
    %187 = llvm.srem %179, %183 : i32 loc(#loc10)
    %188 = llvm.srem %180, %184 : i32 loc(#loc10)
    %189 = llvm.srem %181, %185 : i32 loc(#loc10)
    %190 = llvm.mlir.undef : !llvm.struct<(i32, i32, i32, i32)> loc(#loc10)
    %191 = llvm.insertvalue %186, %190[0] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc10)
    %192 = llvm.insertvalue %187, %191[1] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc10)
    %193 = llvm.insertvalue %188, %192[2] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc10)
    %194 = llvm.insertvalue %189, %193[3] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc10)
    %195 = llvm.extractvalue %147[0] : !llvm.struct<(i32, i32)>  loc(#loc11)
    %196 = llvm.extractvalue %147[1] : !llvm.struct<(i32, i32)>  loc(#loc11)
    %197 = llvm.mlir.undef : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> loc(#loc11)
    %198 = llvm.insertvalue %195, %197[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc11)
    %199 = llvm.insertvalue %195, %198[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc11)
    %200 = llvm.insertvalue %195, %199[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc11)
    %201 = llvm.insertvalue %195, %200[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc11)
    %202 = llvm.insertvalue %196, %201[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc11)
    %203 = llvm.insertvalue %196, %202[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc11)
    %204 = llvm.insertvalue %196, %203[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc11)
    %205 = llvm.insertvalue %196, %204[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc11)
    %206 = llvm.bitcast %arg5 : i32 to i32 loc(#loc12)
    %207 = llvm.mlir.undef : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> loc(#loc12)
    %208 = llvm.insertvalue %206, %207[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc12)
    %209 = llvm.insertvalue %206, %208[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc12)
    %210 = llvm.insertvalue %206, %209[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc12)
    %211 = llvm.insertvalue %206, %210[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc12)
    %212 = llvm.insertvalue %206, %211[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc12)
    %213 = llvm.insertvalue %206, %212[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc12)
    %214 = llvm.insertvalue %206, %213[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc12)
    %215 = llvm.insertvalue %206, %214[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc12)
    %216 = llvm.extractvalue %205[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc12)
    %217 = llvm.extractvalue %205[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc12)
    %218 = llvm.extractvalue %205[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc12)
    %219 = llvm.extractvalue %205[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc12)
    %220 = llvm.extractvalue %205[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc12)
    %221 = llvm.extractvalue %205[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc12)
    %222 = llvm.extractvalue %205[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc12)
    %223 = llvm.extractvalue %205[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc12)
    %224 = llvm.extractvalue %215[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc12)
    %225 = llvm.extractvalue %215[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc12)
    %226 = llvm.extractvalue %215[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc12)
    %227 = llvm.extractvalue %215[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc12)
    %228 = llvm.extractvalue %215[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc12)
    %229 = llvm.extractvalue %215[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc12)
    %230 = llvm.extractvalue %215[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc12)
    %231 = llvm.extractvalue %215[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc12)
    %232 = llvm.mul %216, %224 : i32 loc(#loc12)
    %233 = llvm.mul %217, %225 : i32 loc(#loc12)
    %234 = llvm.mul %218, %226 : i32 loc(#loc12)
    %235 = llvm.mul %219, %227 : i32 loc(#loc12)
    %236 = llvm.mul %220, %228 : i32 loc(#loc12)
    %237 = llvm.mul %221, %229 : i32 loc(#loc12)
    %238 = llvm.mul %222, %230 : i32 loc(#loc12)
    %239 = llvm.mul %223, %231 : i32 loc(#loc12)
    %240 = llvm.mlir.undef : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> loc(#loc12)
    %241 = llvm.insertvalue %232, %240[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc12)
    %242 = llvm.insertvalue %233, %241[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc12)
    %243 = llvm.insertvalue %234, %242[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc12)
    %244 = llvm.insertvalue %235, %243[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc12)
    %245 = llvm.insertvalue %236, %244[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc12)
    %246 = llvm.insertvalue %237, %245[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc12)
    %247 = llvm.insertvalue %238, %246[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc12)
    %248 = llvm.insertvalue %239, %247[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc12)
    %249 = llvm.extractvalue %194[0] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc13)
    %250 = llvm.extractvalue %194[1] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc13)
    %251 = llvm.extractvalue %194[2] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc13)
    %252 = llvm.extractvalue %194[3] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc13)
    %253 = llvm.mlir.undef : !llvm.struct<(i32, i32, i32, i32)> loc(#loc13)
    %254 = llvm.insertvalue %249, %253[0] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc13)
    %255 = llvm.insertvalue %250, %254[1] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc13)
    %256 = llvm.insertvalue %251, %255[2] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc13)
    %257 = llvm.insertvalue %252, %256[3] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc13)
    %258 = llvm.extractvalue %248[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc14)
    %259 = llvm.extractvalue %248[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc14)
    %260 = llvm.extractvalue %248[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc14)
    %261 = llvm.extractvalue %248[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc14)
    %262 = llvm.extractvalue %248[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc14)
    %263 = llvm.extractvalue %248[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc14)
    %264 = llvm.extractvalue %248[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc14)
    %265 = llvm.extractvalue %248[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc14)
    %266 = llvm.mlir.undef : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> loc(#loc14)
    %267 = llvm.insertvalue %261, %266[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc14)
    %268 = llvm.insertvalue %261, %267[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc14)
    %269 = llvm.insertvalue %261, %268[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc14)
    %270 = llvm.insertvalue %261, %269[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc14)
    %271 = llvm.insertvalue %265, %270[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc14)
    %272 = llvm.insertvalue %265, %271[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc14)
    %273 = llvm.insertvalue %265, %272[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc14)
    %274 = llvm.insertvalue %265, %273[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc14)
    %275 = llvm.extractvalue %257[0] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc14)
    %276 = llvm.extractvalue %257[1] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc14)
    %277 = llvm.extractvalue %257[2] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc14)
    %278 = llvm.extractvalue %257[3] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc14)
    %279 = llvm.mlir.undef : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> loc(#loc14)
    %280 = llvm.insertvalue %275, %279[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc14)
    %281 = llvm.insertvalue %276, %280[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc14)
    %282 = llvm.insertvalue %277, %281[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc14)
    %283 = llvm.insertvalue %278, %282[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc14)
    %284 = llvm.insertvalue %275, %283[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc14)
    %285 = llvm.insertvalue %276, %284[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc14)
    %286 = llvm.insertvalue %277, %285[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc14)
    %287 = llvm.insertvalue %278, %286[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc14)
    %288 = llvm.extractvalue %274[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc14)
    %289 = llvm.extractvalue %274[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc14)
    %290 = llvm.extractvalue %274[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc14)
    %291 = llvm.extractvalue %274[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc14)
    %292 = llvm.extractvalue %274[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc14)
    %293 = llvm.extractvalue %274[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc14)
    %294 = llvm.extractvalue %274[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc14)
    %295 = llvm.extractvalue %274[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc14)
    %296 = llvm.extractvalue %287[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc14)
    %297 = llvm.extractvalue %287[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc14)
    %298 = llvm.extractvalue %287[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc14)
    %299 = llvm.extractvalue %287[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc14)
    %300 = llvm.extractvalue %287[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc14)
    %301 = llvm.extractvalue %287[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc14)
    %302 = llvm.extractvalue %287[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc14)
    %303 = llvm.extractvalue %287[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc14)
    %304 = llvm.add %288, %296 : i32 loc(#loc14)
    %305 = llvm.add %289, %297 : i32 loc(#loc14)
    %306 = llvm.add %290, %298 : i32 loc(#loc14)
    %307 = llvm.add %291, %299 : i32 loc(#loc14)
    %308 = llvm.add %292, %300 : i32 loc(#loc14)
    %309 = llvm.add %293, %301 : i32 loc(#loc14)
    %310 = llvm.add %294, %302 : i32 loc(#loc14)
    %311 = llvm.add %295, %303 : i32 loc(#loc14)
    %312 = llvm.mlir.undef : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> loc(#loc14)
    %313 = llvm.insertvalue %304, %312[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc14)
    %314 = llvm.insertvalue %305, %313[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc14)
    %315 = llvm.insertvalue %306, %314[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc14)
    %316 = llvm.insertvalue %307, %315[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc14)
    %317 = llvm.insertvalue %308, %316[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc14)
    %318 = llvm.insertvalue %309, %317[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc14)
    %319 = llvm.insertvalue %310, %318[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc14)
    %320 = llvm.insertvalue %311, %319[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc14)
    %321 = llvm.bitcast %arg0 : !llvm.ptr<1> to !llvm.ptr<1> loc(#loc15)
    %322 = llvm.mlir.undef : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> loc(#loc15)
    %323 = llvm.insertvalue %321, %322[0] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc15)
    %324 = llvm.insertvalue %321, %323[1] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc15)
    %325 = llvm.insertvalue %321, %324[2] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc15)
    %326 = llvm.insertvalue %321, %325[3] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc15)
    %327 = llvm.insertvalue %321, %326[4] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc15)
    %328 = llvm.insertvalue %321, %327[5] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc15)
    %329 = llvm.insertvalue %321, %328[6] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc15)
    %330 = llvm.insertvalue %321, %329[7] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc15)
    %331 = llvm.extractvalue %330[0] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc15)
    %332 = llvm.extractvalue %330[1] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc15)
    %333 = llvm.extractvalue %330[2] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc15)
    %334 = llvm.extractvalue %330[3] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc15)
    %335 = llvm.extractvalue %330[4] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc15)
    %336 = llvm.extractvalue %330[5] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc15)
    %337 = llvm.extractvalue %330[6] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc15)
    %338 = llvm.extractvalue %330[7] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc15)
    %339 = llvm.extractvalue %320[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc15)
    %340 = llvm.extractvalue %320[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc15)
    %341 = llvm.extractvalue %320[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc15)
    %342 = llvm.extractvalue %320[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc15)
    %343 = llvm.extractvalue %320[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc15)
    %344 = llvm.extractvalue %320[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc15)
    %345 = llvm.extractvalue %320[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc15)
    %346 = llvm.extractvalue %320[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc15)
    %347 = llvm.getelementptr %331[%339] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc15)
    %348 = llvm.getelementptr %332[%340] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc15)
    %349 = llvm.getelementptr %333[%341] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc15)
    %350 = llvm.getelementptr %334[%342] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc15)
    %351 = llvm.getelementptr %335[%343] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc15)
    %352 = llvm.getelementptr %336[%344] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc15)
    %353 = llvm.getelementptr %337[%345] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc15)
    %354 = llvm.getelementptr %338[%346] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc15)
    %355 = llvm.mlir.undef : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> loc(#loc15)
    %356 = llvm.insertvalue %347, %355[0] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc15)
    %357 = llvm.insertvalue %348, %356[1] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc15)
    %358 = llvm.insertvalue %349, %357[2] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc15)
    %359 = llvm.insertvalue %350, %358[3] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc15)
    %360 = llvm.insertvalue %351, %359[4] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc15)
    %361 = llvm.insertvalue %352, %360[5] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc15)
    %362 = llvm.insertvalue %353, %361[6] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc15)
    %363 = llvm.insertvalue %354, %362[7] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc15)
    %364 = llvm.bitcast %arg6 : i32 to i32 loc(#loc16)
    %365 = llvm.mlir.undef : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> loc(#loc16)
    %366 = llvm.insertvalue %364, %365[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc16)
    %367 = llvm.insertvalue %364, %366[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc16)
    %368 = llvm.insertvalue %364, %367[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc16)
    %369 = llvm.insertvalue %364, %368[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc16)
    %370 = llvm.insertvalue %364, %369[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc16)
    %371 = llvm.insertvalue %364, %370[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc16)
    %372 = llvm.insertvalue %364, %371[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc16)
    %373 = llvm.insertvalue %364, %372[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc16)
    %374 = llvm.extractvalue %205[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc16)
    %375 = llvm.extractvalue %205[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc16)
    %376 = llvm.extractvalue %205[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc16)
    %377 = llvm.extractvalue %205[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc16)
    %378 = llvm.extractvalue %205[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc16)
    %379 = llvm.extractvalue %205[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc16)
    %380 = llvm.extractvalue %205[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc16)
    %381 = llvm.extractvalue %205[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc16)
    %382 = llvm.extractvalue %373[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc16)
    %383 = llvm.extractvalue %373[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc16)
    %384 = llvm.extractvalue %373[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc16)
    %385 = llvm.extractvalue %373[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc16)
    %386 = llvm.extractvalue %373[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc16)
    %387 = llvm.extractvalue %373[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc16)
    %388 = llvm.extractvalue %373[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc16)
    %389 = llvm.extractvalue %373[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc16)
    %390 = llvm.mul %374, %382 : i32 loc(#loc16)
    %391 = llvm.mul %375, %383 : i32 loc(#loc16)
    %392 = llvm.mul %376, %384 : i32 loc(#loc16)
    %393 = llvm.mul %377, %385 : i32 loc(#loc16)
    %394 = llvm.mul %378, %386 : i32 loc(#loc16)
    %395 = llvm.mul %379, %387 : i32 loc(#loc16)
    %396 = llvm.mul %380, %388 : i32 loc(#loc16)
    %397 = llvm.mul %381, %389 : i32 loc(#loc16)
    %398 = llvm.mlir.undef : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> loc(#loc16)
    %399 = llvm.insertvalue %390, %398[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc16)
    %400 = llvm.insertvalue %391, %399[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc16)
    %401 = llvm.insertvalue %392, %400[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc16)
    %402 = llvm.insertvalue %393, %401[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc16)
    %403 = llvm.insertvalue %394, %402[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc16)
    %404 = llvm.insertvalue %395, %403[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc16)
    %405 = llvm.insertvalue %396, %404[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc16)
    %406 = llvm.insertvalue %397, %405[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc16)
    %407 = llvm.extractvalue %406[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc17)
    %408 = llvm.extractvalue %406[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc17)
    %409 = llvm.extractvalue %406[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc17)
    %410 = llvm.extractvalue %406[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc17)
    %411 = llvm.extractvalue %406[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc17)
    %412 = llvm.extractvalue %406[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc17)
    %413 = llvm.extractvalue %406[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc17)
    %414 = llvm.extractvalue %406[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc17)
    %415 = llvm.mlir.undef : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> loc(#loc17)
    %416 = llvm.insertvalue %410, %415[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc17)
    %417 = llvm.insertvalue %410, %416[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc17)
    %418 = llvm.insertvalue %410, %417[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc17)
    %419 = llvm.insertvalue %410, %418[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc17)
    %420 = llvm.insertvalue %414, %419[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc17)
    %421 = llvm.insertvalue %414, %420[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc17)
    %422 = llvm.insertvalue %414, %421[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc17)
    %423 = llvm.insertvalue %414, %422[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc17)
    %424 = llvm.extractvalue %423[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc17)
    %425 = llvm.extractvalue %423[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc17)
    %426 = llvm.extractvalue %423[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc17)
    %427 = llvm.extractvalue %423[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc17)
    %428 = llvm.extractvalue %423[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc17)
    %429 = llvm.extractvalue %423[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc17)
    %430 = llvm.extractvalue %423[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc17)
    %431 = llvm.extractvalue %423[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc17)
    %432 = llvm.extractvalue %287[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc17)
    %433 = llvm.extractvalue %287[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc17)
    %434 = llvm.extractvalue %287[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc17)
    %435 = llvm.extractvalue %287[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc17)
    %436 = llvm.extractvalue %287[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc17)
    %437 = llvm.extractvalue %287[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc17)
    %438 = llvm.extractvalue %287[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc17)
    %439 = llvm.extractvalue %287[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc17)
    %440 = llvm.add %424, %432 : i32 loc(#loc17)
    %441 = llvm.add %425, %433 : i32 loc(#loc17)
    %442 = llvm.add %426, %434 : i32 loc(#loc17)
    %443 = llvm.add %427, %435 : i32 loc(#loc17)
    %444 = llvm.add %428, %436 : i32 loc(#loc17)
    %445 = llvm.add %429, %437 : i32 loc(#loc17)
    %446 = llvm.add %430, %438 : i32 loc(#loc17)
    %447 = llvm.add %431, %439 : i32 loc(#loc17)
    %448 = llvm.mlir.undef : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> loc(#loc17)
    %449 = llvm.insertvalue %440, %448[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc17)
    %450 = llvm.insertvalue %441, %449[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc17)
    %451 = llvm.insertvalue %442, %450[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc17)
    %452 = llvm.insertvalue %443, %451[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc17)
    %453 = llvm.insertvalue %444, %452[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc17)
    %454 = llvm.insertvalue %445, %453[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc17)
    %455 = llvm.insertvalue %446, %454[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc17)
    %456 = llvm.insertvalue %447, %455[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc17)
    %457 = llvm.bitcast %arg1 : !llvm.ptr<1> to !llvm.ptr<1> loc(#loc18)
    %458 = llvm.mlir.undef : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> loc(#loc18)
    %459 = llvm.insertvalue %457, %458[0] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc18)
    %460 = llvm.insertvalue %457, %459[1] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc18)
    %461 = llvm.insertvalue %457, %460[2] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc18)
    %462 = llvm.insertvalue %457, %461[3] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc18)
    %463 = llvm.insertvalue %457, %462[4] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc18)
    %464 = llvm.insertvalue %457, %463[5] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc18)
    %465 = llvm.insertvalue %457, %464[6] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc18)
    %466 = llvm.insertvalue %457, %465[7] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc18)
    %467 = llvm.extractvalue %466[0] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc18)
    %468 = llvm.extractvalue %466[1] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc18)
    %469 = llvm.extractvalue %466[2] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc18)
    %470 = llvm.extractvalue %466[3] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc18)
    %471 = llvm.extractvalue %466[4] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc18)
    %472 = llvm.extractvalue %466[5] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc18)
    %473 = llvm.extractvalue %466[6] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc18)
    %474 = llvm.extractvalue %466[7] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc18)
    %475 = llvm.extractvalue %456[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc18)
    %476 = llvm.extractvalue %456[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc18)
    %477 = llvm.extractvalue %456[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc18)
    %478 = llvm.extractvalue %456[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc18)
    %479 = llvm.extractvalue %456[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc18)
    %480 = llvm.extractvalue %456[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc18)
    %481 = llvm.extractvalue %456[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc18)
    %482 = llvm.extractvalue %456[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc18)
    %483 = llvm.getelementptr %467[%475] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc18)
    %484 = llvm.getelementptr %468[%476] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc18)
    %485 = llvm.getelementptr %469[%477] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc18)
    %486 = llvm.getelementptr %470[%478] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc18)
    %487 = llvm.getelementptr %471[%479] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc18)
    %488 = llvm.getelementptr %472[%480] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc18)
    %489 = llvm.getelementptr %473[%481] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc18)
    %490 = llvm.getelementptr %474[%482] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc18)
    %491 = llvm.mlir.undef : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> loc(#loc18)
    %492 = llvm.insertvalue %483, %491[0] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc18)
    %493 = llvm.insertvalue %484, %492[1] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc18)
    %494 = llvm.insertvalue %485, %493[2] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc18)
    %495 = llvm.insertvalue %486, %494[3] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc18)
    %496 = llvm.insertvalue %487, %495[4] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc18)
    %497 = llvm.insertvalue %488, %496[5] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc18)
    %498 = llvm.insertvalue %489, %497[6] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc18)
    %499 = llvm.insertvalue %490, %498[7] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc18)
    %500 = llvm.bitcast %arg7 : i32 to i32 loc(#loc19)
    %501 = llvm.mlir.undef : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> loc(#loc19)
    %502 = llvm.insertvalue %500, %501[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc19)
    %503 = llvm.insertvalue %500, %502[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc19)
    %504 = llvm.insertvalue %500, %503[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc19)
    %505 = llvm.insertvalue %500, %504[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc19)
    %506 = llvm.insertvalue %500, %505[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc19)
    %507 = llvm.insertvalue %500, %506[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc19)
    %508 = llvm.insertvalue %500, %507[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc19)
    %509 = llvm.insertvalue %500, %508[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc19)
    %510 = llvm.extractvalue %205[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc19)
    %511 = llvm.extractvalue %205[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc19)
    %512 = llvm.extractvalue %205[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc19)
    %513 = llvm.extractvalue %205[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc19)
    %514 = llvm.extractvalue %205[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc19)
    %515 = llvm.extractvalue %205[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc19)
    %516 = llvm.extractvalue %205[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc19)
    %517 = llvm.extractvalue %205[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc19)
    %518 = llvm.extractvalue %509[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc19)
    %519 = llvm.extractvalue %509[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc19)
    %520 = llvm.extractvalue %509[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc19)
    %521 = llvm.extractvalue %509[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc19)
    %522 = llvm.extractvalue %509[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc19)
    %523 = llvm.extractvalue %509[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc19)
    %524 = llvm.extractvalue %509[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc19)
    %525 = llvm.extractvalue %509[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc19)
    %526 = llvm.mul %510, %518 : i32 loc(#loc19)
    %527 = llvm.mul %511, %519 : i32 loc(#loc19)
    %528 = llvm.mul %512, %520 : i32 loc(#loc19)
    %529 = llvm.mul %513, %521 : i32 loc(#loc19)
    %530 = llvm.mul %514, %522 : i32 loc(#loc19)
    %531 = llvm.mul %515, %523 : i32 loc(#loc19)
    %532 = llvm.mul %516, %524 : i32 loc(#loc19)
    %533 = llvm.mul %517, %525 : i32 loc(#loc19)
    %534 = llvm.mlir.undef : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> loc(#loc19)
    %535 = llvm.insertvalue %526, %534[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc19)
    %536 = llvm.insertvalue %527, %535[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc19)
    %537 = llvm.insertvalue %528, %536[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc19)
    %538 = llvm.insertvalue %529, %537[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc19)
    %539 = llvm.insertvalue %530, %538[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc19)
    %540 = llvm.insertvalue %531, %539[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc19)
    %541 = llvm.insertvalue %532, %540[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc19)
    %542 = llvm.insertvalue %533, %541[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc19)
    %543 = llvm.extractvalue %542[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc20)
    %544 = llvm.extractvalue %542[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc20)
    %545 = llvm.extractvalue %542[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc20)
    %546 = llvm.extractvalue %542[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc20)
    %547 = llvm.extractvalue %542[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc20)
    %548 = llvm.extractvalue %542[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc20)
    %549 = llvm.extractvalue %542[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc20)
    %550 = llvm.extractvalue %542[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc20)
    %551 = llvm.mlir.undef : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> loc(#loc20)
    %552 = llvm.insertvalue %546, %551[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc20)
    %553 = llvm.insertvalue %546, %552[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc20)
    %554 = llvm.insertvalue %546, %553[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc20)
    %555 = llvm.insertvalue %546, %554[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc20)
    %556 = llvm.insertvalue %550, %555[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc20)
    %557 = llvm.insertvalue %550, %556[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc20)
    %558 = llvm.insertvalue %550, %557[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc20)
    %559 = llvm.insertvalue %550, %558[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc20)
    %560 = llvm.extractvalue %559[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc20)
    %561 = llvm.extractvalue %559[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc20)
    %562 = llvm.extractvalue %559[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc20)
    %563 = llvm.extractvalue %559[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc20)
    %564 = llvm.extractvalue %559[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc20)
    %565 = llvm.extractvalue %559[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc20)
    %566 = llvm.extractvalue %559[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc20)
    %567 = llvm.extractvalue %559[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc20)
    %568 = llvm.extractvalue %287[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc20)
    %569 = llvm.extractvalue %287[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc20)
    %570 = llvm.extractvalue %287[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc20)
    %571 = llvm.extractvalue %287[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc20)
    %572 = llvm.extractvalue %287[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc20)
    %573 = llvm.extractvalue %287[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc20)
    %574 = llvm.extractvalue %287[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc20)
    %575 = llvm.extractvalue %287[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc20)
    %576 = llvm.add %560, %568 : i32 loc(#loc20)
    %577 = llvm.add %561, %569 : i32 loc(#loc20)
    %578 = llvm.add %562, %570 : i32 loc(#loc20)
    %579 = llvm.add %563, %571 : i32 loc(#loc20)
    %580 = llvm.add %564, %572 : i32 loc(#loc20)
    %581 = llvm.add %565, %573 : i32 loc(#loc20)
    %582 = llvm.add %566, %574 : i32 loc(#loc20)
    %583 = llvm.add %567, %575 : i32 loc(#loc20)
    %584 = llvm.mlir.undef : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> loc(#loc20)
    %585 = llvm.insertvalue %576, %584[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc20)
    %586 = llvm.insertvalue %577, %585[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc20)
    %587 = llvm.insertvalue %578, %586[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc20)
    %588 = llvm.insertvalue %579, %587[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc20)
    %589 = llvm.insertvalue %580, %588[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc20)
    %590 = llvm.insertvalue %581, %589[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc20)
    %591 = llvm.insertvalue %582, %590[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc20)
    %592 = llvm.insertvalue %583, %591[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc20)
    %593 = llvm.bitcast %arg2 : !llvm.ptr<1> to !llvm.ptr<1> loc(#loc21)
    %594 = llvm.mlir.undef : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> loc(#loc21)
    %595 = llvm.insertvalue %593, %594[0] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc21)
    %596 = llvm.insertvalue %593, %595[1] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc21)
    %597 = llvm.insertvalue %593, %596[2] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc21)
    %598 = llvm.insertvalue %593, %597[3] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc21)
    %599 = llvm.insertvalue %593, %598[4] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc21)
    %600 = llvm.insertvalue %593, %599[5] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc21)
    %601 = llvm.insertvalue %593, %600[6] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc21)
    %602 = llvm.insertvalue %593, %601[7] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc21)
    %603 = llvm.extractvalue %602[0] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc21)
    %604 = llvm.extractvalue %602[1] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc21)
    %605 = llvm.extractvalue %602[2] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc21)
    %606 = llvm.extractvalue %602[3] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc21)
    %607 = llvm.extractvalue %602[4] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc21)
    %608 = llvm.extractvalue %602[5] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc21)
    %609 = llvm.extractvalue %602[6] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc21)
    %610 = llvm.extractvalue %602[7] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc21)
    %611 = llvm.extractvalue %592[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc21)
    %612 = llvm.extractvalue %592[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc21)
    %613 = llvm.extractvalue %592[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc21)
    %614 = llvm.extractvalue %592[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc21)
    %615 = llvm.extractvalue %592[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc21)
    %616 = llvm.extractvalue %592[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc21)
    %617 = llvm.extractvalue %592[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc21)
    %618 = llvm.extractvalue %592[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc21)
    %619 = llvm.getelementptr %603[%611] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc21)
    %620 = llvm.getelementptr %604[%612] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc21)
    %621 = llvm.getelementptr %605[%613] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc21)
    %622 = llvm.getelementptr %606[%614] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc21)
    %623 = llvm.getelementptr %607[%615] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc21)
    %624 = llvm.getelementptr %608[%616] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc21)
    %625 = llvm.getelementptr %609[%617] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc21)
    %626 = llvm.getelementptr %610[%618] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc21)
    %627 = llvm.mlir.undef : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> loc(#loc21)
    %628 = llvm.insertvalue %619, %627[0] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc21)
    %629 = llvm.insertvalue %620, %628[1] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc21)
    %630 = llvm.insertvalue %621, %629[2] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc21)
    %631 = llvm.insertvalue %622, %630[3] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc21)
    %632 = llvm.insertvalue %623, %631[4] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc21)
    %633 = llvm.insertvalue %624, %632[5] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc21)
    %634 = llvm.insertvalue %625, %633[6] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc21)
    %635 = llvm.insertvalue %626, %634[7] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc21)
    %636 = llvm.bitcast %arg3 : i32 to i32 loc(#loc22)
    %637 = llvm.mlir.undef : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> loc(#loc22)
    %638 = llvm.insertvalue %636, %637[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %639 = llvm.insertvalue %636, %638[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %640 = llvm.insertvalue %636, %639[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %641 = llvm.insertvalue %636, %640[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %642 = llvm.insertvalue %636, %641[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %643 = llvm.insertvalue %636, %642[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %644 = llvm.insertvalue %636, %643[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %645 = llvm.insertvalue %636, %644[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %646 = llvm.extractvalue %205[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %647 = llvm.extractvalue %205[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %648 = llvm.extractvalue %205[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %649 = llvm.extractvalue %205[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %650 = llvm.extractvalue %205[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %651 = llvm.extractvalue %205[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %652 = llvm.extractvalue %205[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %653 = llvm.extractvalue %205[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %654 = llvm.extractvalue %645[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %655 = llvm.extractvalue %645[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %656 = llvm.extractvalue %645[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %657 = llvm.extractvalue %645[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %658 = llvm.extractvalue %645[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %659 = llvm.extractvalue %645[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %660 = llvm.extractvalue %645[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %661 = llvm.extractvalue %645[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %662 = llvm.icmp "slt" %646, %654 : i32 loc(#loc22)
    %663 = llvm.icmp "slt" %647, %655 : i32 loc(#loc22)
    %664 = llvm.icmp "slt" %648, %656 : i32 loc(#loc22)
    %665 = llvm.icmp "slt" %649, %657 : i32 loc(#loc22)
    %666 = llvm.icmp "slt" %650, %658 : i32 loc(#loc22)
    %667 = llvm.icmp "slt" %651, %659 : i32 loc(#loc22)
    %668 = llvm.icmp "slt" %652, %660 : i32 loc(#loc22)
    %669 = llvm.icmp "slt" %653, %661 : i32 loc(#loc22)
    %670 = llvm.mlir.undef : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)> loc(#loc22)
    %671 = llvm.insertvalue %662, %670[0] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc22)
    %672 = llvm.insertvalue %663, %671[1] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc22)
    %673 = llvm.insertvalue %664, %672[2] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc22)
    %674 = llvm.insertvalue %665, %673[3] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc22)
    %675 = llvm.insertvalue %666, %674[4] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc22)
    %676 = llvm.insertvalue %667, %675[5] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc22)
    %677 = llvm.insertvalue %668, %676[6] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc22)
    %678 = llvm.insertvalue %669, %677[7] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc22)
    %679 = llvm.bitcast %arg4 : i32 to i32 loc(#loc23)
    %680 = llvm.mlir.undef : !llvm.struct<(i32, i32, i32, i32)> loc(#loc23)
    %681 = llvm.insertvalue %679, %680[0] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc23)
    %682 = llvm.insertvalue %679, %681[1] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc23)
    %683 = llvm.insertvalue %679, %682[2] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc23)
    %684 = llvm.insertvalue %679, %683[3] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc23)
    %685 = llvm.extractvalue %257[0] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc23)
    %686 = llvm.extractvalue %257[1] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc23)
    %687 = llvm.extractvalue %257[2] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc23)
    %688 = llvm.extractvalue %257[3] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc23)
    %689 = llvm.extractvalue %684[0] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc23)
    %690 = llvm.extractvalue %684[1] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc23)
    %691 = llvm.extractvalue %684[2] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc23)
    %692 = llvm.extractvalue %684[3] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc23)
    %693 = llvm.icmp "slt" %685, %689 : i32 loc(#loc23)
    %694 = llvm.icmp "slt" %686, %690 : i32 loc(#loc23)
    %695 = llvm.icmp "slt" %687, %691 : i32 loc(#loc23)
    %696 = llvm.icmp "slt" %688, %692 : i32 loc(#loc23)
    %697 = llvm.mlir.undef : !llvm.struct<(i1, i1, i1, i1)> loc(#loc23)
    %698 = llvm.insertvalue %693, %697[0] : !llvm.struct<(i1, i1, i1, i1)>  loc(#loc23)
    %699 = llvm.insertvalue %693, %698[1] : !llvm.struct<(i1, i1, i1, i1)>  loc(#loc23)
    %700 = llvm.insertvalue %693, %699[2] : !llvm.struct<(i1, i1, i1, i1)>  loc(#loc23)
    %701 = llvm.insertvalue %693, %700[3] : !llvm.struct<(i1, i1, i1, i1)>  loc(#loc23)
    %702 = llvm.extractvalue %678[0] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc24)
    %703 = llvm.extractvalue %678[1] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc24)
    %704 = llvm.extractvalue %678[2] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc24)
    %705 = llvm.extractvalue %678[3] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc24)
    %706 = llvm.extractvalue %678[4] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc24)
    %707 = llvm.extractvalue %678[5] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc24)
    %708 = llvm.extractvalue %678[6] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc24)
    %709 = llvm.extractvalue %678[7] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc24)
    %710 = llvm.mlir.undef : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)> loc(#loc24)
    %711 = llvm.insertvalue %705, %710[0] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc24)
    %712 = llvm.insertvalue %705, %711[1] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc24)
    %713 = llvm.insertvalue %705, %712[2] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc24)
    %714 = llvm.insertvalue %705, %713[3] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc24)
    %715 = llvm.insertvalue %709, %714[4] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc24)
    %716 = llvm.insertvalue %709, %715[5] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc24)
    %717 = llvm.insertvalue %709, %716[6] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc24)
    %718 = llvm.insertvalue %709, %717[7] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc24)
    %719 = llvm.extractvalue %701[0] : !llvm.struct<(i1, i1, i1, i1)>  loc(#loc24)
    %720 = llvm.extractvalue %701[1] : !llvm.struct<(i1, i1, i1, i1)>  loc(#loc24)
    %721 = llvm.extractvalue %701[2] : !llvm.struct<(i1, i1, i1, i1)>  loc(#loc24)
    %722 = llvm.extractvalue %701[3] : !llvm.struct<(i1, i1, i1, i1)>  loc(#loc24)
    %723 = llvm.mlir.undef : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)> loc(#loc24)
    %724 = llvm.insertvalue %719, %723[0] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc24)
    %725 = llvm.insertvalue %720, %724[1] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc24)
    %726 = llvm.insertvalue %721, %725[2] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc24)
    %727 = llvm.insertvalue %722, %726[3] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc24)
    %728 = llvm.insertvalue %719, %727[4] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc24)
    %729 = llvm.insertvalue %720, %728[5] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc24)
    %730 = llvm.insertvalue %721, %729[6] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc24)
    %731 = llvm.insertvalue %722, %730[7] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc24)
    %732 = llvm.extractvalue %718[0] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc24)
    %733 = llvm.extractvalue %718[1] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc24)
    %734 = llvm.extractvalue %718[2] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc24)
    %735 = llvm.extractvalue %718[3] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc24)
    %736 = llvm.extractvalue %718[4] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc24)
    %737 = llvm.extractvalue %718[5] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc24)
    %738 = llvm.extractvalue %718[6] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc24)
    %739 = llvm.extractvalue %718[7] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc24)
    %740 = llvm.extractvalue %731[0] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc24)
    %741 = llvm.extractvalue %731[1] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc24)
    %742 = llvm.extractvalue %731[2] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc24)
    %743 = llvm.extractvalue %731[3] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc24)
    %744 = llvm.extractvalue %731[4] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc24)
    %745 = llvm.extractvalue %731[5] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc24)
    %746 = llvm.extractvalue %731[6] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc24)
    %747 = llvm.extractvalue %731[7] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc24)
    %748 = llvm.and %732, %740 : i1 loc(#loc24)
    %749 = llvm.and %733, %741 : i1 loc(#loc24)
    %750 = llvm.and %734, %742 : i1 loc(#loc24)
    %751 = llvm.and %735, %743 : i1 loc(#loc24)
    %752 = llvm.and %736, %744 : i1 loc(#loc24)
    %753 = llvm.and %737, %745 : i1 loc(#loc24)
    %754 = llvm.and %738, %746 : i1 loc(#loc24)
    %755 = llvm.and %739, %747 : i1 loc(#loc24)
    %756 = llvm.mlir.undef : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)> loc(#loc24)
    %757 = llvm.insertvalue %748, %756[0] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc24)
    %758 = llvm.insertvalue %748, %757[1] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc24)
    %759 = llvm.insertvalue %748, %758[2] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc24)
    %760 = llvm.insertvalue %748, %759[3] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc24)
    %761 = llvm.insertvalue %752, %760[4] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc24)
    %762 = llvm.insertvalue %752, %761[5] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc24)
    %763 = llvm.insertvalue %752, %762[6] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc24)
    %764 = llvm.insertvalue %752, %763[7] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc24)
    %765 = llvm.extractvalue %363[0] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc25)
    %766 = llvm.extractvalue %363[1] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc25)
    %767 = llvm.extractvalue %363[2] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc25)
    %768 = llvm.extractvalue %363[3] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc25)
    %769 = llvm.extractvalue %363[4] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc25)
    %770 = llvm.extractvalue %363[5] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc25)
    %771 = llvm.extractvalue %363[6] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc25)
    %772 = llvm.extractvalue %363[7] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc25)
    %773 = llvm.extractvalue %764[0] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc25)
    %774 = llvm.extractvalue %764[1] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc25)
    %775 = llvm.extractvalue %764[2] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc25)
    %776 = llvm.extractvalue %764[3] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc25)
    %777 = llvm.extractvalue %764[4] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc25)
    %778 = llvm.extractvalue %764[5] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc25)
    %779 = llvm.extractvalue %764[6] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc25)
    %780 = llvm.extractvalue %764[7] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc25)
    %781 = llvm.extractvalue %10[0] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc25)
    %782 = llvm.extractvalue %10[1] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc25)
    %783 = llvm.extractvalue %10[2] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc25)
    %784 = llvm.extractvalue %10[3] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc25)
    %785 = llvm.extractvalue %10[4] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc25)
    %786 = llvm.extractvalue %10[5] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc25)
    %787 = llvm.extractvalue %10[6] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc25)
    %788 = llvm.extractvalue %10[7] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc25)
    %789 = llvm.mlir.undef : vector<1xf32> loc(#loc25)
    %790 = llvm.mlir.constant(0 : index) : i32 loc(#loc25)
    %791 = llvm.insertelement %781, %789[%790 : i32] : vector<1xf32> loc(#loc25)
    %792 = llvm.bitcast %791 : vector<1xf32> to i32 loc(#loc25)
    %793 = llvm.mlir.undef : vector<1xf32> loc(#loc25)
    %794 = llvm.mlir.constant(0 : index) : i32 loc(#loc25)
    %795 = llvm.insertelement %782, %793[%794 : i32] : vector<1xf32> loc(#loc25)
    %796 = llvm.bitcast %795 : vector<1xf32> to i32 loc(#loc25)
    %797 = llvm.mlir.undef : vector<1xf32> loc(#loc25)
    %798 = llvm.mlir.constant(0 : index) : i32 loc(#loc25)
    %799 = llvm.insertelement %783, %797[%798 : i32] : vector<1xf32> loc(#loc25)
    %800 = llvm.bitcast %799 : vector<1xf32> to i32 loc(#loc25)
    %801 = llvm.mlir.undef : vector<1xf32> loc(#loc25)
    %802 = llvm.mlir.constant(0 : index) : i32 loc(#loc25)
    %803 = llvm.insertelement %784, %801[%802 : i32] : vector<1xf32> loc(#loc25)
    %804 = llvm.bitcast %803 : vector<1xf32> to i32 loc(#loc25)
    %805 = llvm.inline_asm has_side_effects asm_dialect = att operand_attrs = [] "mov.u32 $0, $4;\0A\09mov.u32 $1, $5;\0A\09mov.u32 $2, $6;\0A\09mov.u32 $3, $7;\0A\09@$9 ld.global.v4.b32 { $0, $1, $2, $3 }, [ $8 + 0 ];", "=r,=r,=r,=r,r,r,r,r,l,b" %792, %796, %800, %804, %765, %773 : (i32, i32, i32, i32, !llvm.ptr<1>, i1) -> !llvm.struct<(i32, i32, i32, i32)> loc(#loc25)
    %806 = llvm.extractvalue %805[0] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc25)
    %807 = llvm.bitcast %806 : i32 to vector<1xf32> loc(#loc25)
    %808 = llvm.extractvalue %805[1] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc25)
    %809 = llvm.bitcast %808 : i32 to vector<1xf32> loc(#loc25)
    %810 = llvm.extractvalue %805[2] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc25)
    %811 = llvm.bitcast %810 : i32 to vector<1xf32> loc(#loc25)
    %812 = llvm.extractvalue %805[3] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc25)
    %813 = llvm.bitcast %812 : i32 to vector<1xf32> loc(#loc25)
    %814 = llvm.mlir.constant(0 : index) : i32 loc(#loc25)
    %815 = llvm.extractelement %807[%814 : i32] : vector<1xf32> loc(#loc25)
    %816 = llvm.mlir.constant(0 : index) : i32 loc(#loc25)
    %817 = llvm.extractelement %809[%816 : i32] : vector<1xf32> loc(#loc25)
    %818 = llvm.mlir.constant(0 : index) : i32 loc(#loc25)
    %819 = llvm.extractelement %811[%818 : i32] : vector<1xf32> loc(#loc25)
    %820 = llvm.mlir.constant(0 : index) : i32 loc(#loc25)
    %821 = llvm.extractelement %813[%820 : i32] : vector<1xf32> loc(#loc25)
    %822 = llvm.mlir.undef : vector<1xf32> loc(#loc25)
    %823 = llvm.mlir.constant(0 : index) : i32 loc(#loc25)
    %824 = llvm.insertelement %785, %822[%823 : i32] : vector<1xf32> loc(#loc25)
    %825 = llvm.bitcast %824 : vector<1xf32> to i32 loc(#loc25)
    %826 = llvm.mlir.undef : vector<1xf32> loc(#loc25)
    %827 = llvm.mlir.constant(0 : index) : i32 loc(#loc25)
    %828 = llvm.insertelement %786, %826[%827 : i32] : vector<1xf32> loc(#loc25)
    %829 = llvm.bitcast %828 : vector<1xf32> to i32 loc(#loc25)
    %830 = llvm.mlir.undef : vector<1xf32> loc(#loc25)
    %831 = llvm.mlir.constant(0 : index) : i32 loc(#loc25)
    %832 = llvm.insertelement %787, %830[%831 : i32] : vector<1xf32> loc(#loc25)
    %833 = llvm.bitcast %832 : vector<1xf32> to i32 loc(#loc25)
    %834 = llvm.mlir.undef : vector<1xf32> loc(#loc25)
    %835 = llvm.mlir.constant(0 : index) : i32 loc(#loc25)
    %836 = llvm.insertelement %788, %834[%835 : i32] : vector<1xf32> loc(#loc25)
    %837 = llvm.bitcast %836 : vector<1xf32> to i32 loc(#loc25)
    %838 = llvm.inline_asm has_side_effects asm_dialect = att operand_attrs = [] "mov.u32 $0, $4;\0A\09mov.u32 $1, $5;\0A\09mov.u32 $2, $6;\0A\09mov.u32 $3, $7;\0A\09@$9 ld.global.v4.b32 { $0, $1, $2, $3 }, [ $8 + 0 ];", "=r,=r,=r,=r,r,r,r,r,l,b" %825, %829, %833, %837, %769, %777 : (i32, i32, i32, i32, !llvm.ptr<1>, i1) -> !llvm.struct<(i32, i32, i32, i32)> loc(#loc25)
    %839 = llvm.extractvalue %838[0] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc25)
    %840 = llvm.bitcast %839 : i32 to vector<1xf32> loc(#loc25)
    %841 = llvm.extractvalue %838[1] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc25)
    %842 = llvm.bitcast %841 : i32 to vector<1xf32> loc(#loc25)
    %843 = llvm.extractvalue %838[2] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc25)
    %844 = llvm.bitcast %843 : i32 to vector<1xf32> loc(#loc25)
    %845 = llvm.extractvalue %838[3] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc25)
    %846 = llvm.bitcast %845 : i32 to vector<1xf32> loc(#loc25)
    %847 = llvm.mlir.constant(0 : index) : i32 loc(#loc25)
    %848 = llvm.extractelement %840[%847 : i32] : vector<1xf32> loc(#loc25)
    %849 = llvm.mlir.constant(0 : index) : i32 loc(#loc25)
    %850 = llvm.extractelement %842[%849 : i32] : vector<1xf32> loc(#loc25)
    %851 = llvm.mlir.constant(0 : index) : i32 loc(#loc25)
    %852 = llvm.extractelement %844[%851 : i32] : vector<1xf32> loc(#loc25)
    %853 = llvm.mlir.constant(0 : index) : i32 loc(#loc25)
    %854 = llvm.extractelement %846[%853 : i32] : vector<1xf32> loc(#loc25)
    %855 = llvm.mlir.undef : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> loc(#loc25)
    %856 = llvm.insertvalue %815, %855[0] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc25)
    %857 = llvm.insertvalue %817, %856[1] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc25)
    %858 = llvm.insertvalue %819, %857[2] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc25)
    %859 = llvm.insertvalue %821, %858[3] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc25)
    %860 = llvm.insertvalue %848, %859[4] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc25)
    %861 = llvm.insertvalue %850, %860[5] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc25)
    %862 = llvm.insertvalue %852, %861[6] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc25)
    %863 = llvm.insertvalue %854, %862[7] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc25)
    %864 = llvm.extractvalue %499[0] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc26)
    %865 = llvm.extractvalue %499[1] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc26)
    %866 = llvm.extractvalue %499[2] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc26)
    %867 = llvm.extractvalue %499[3] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc26)
    %868 = llvm.extractvalue %499[4] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc26)
    %869 = llvm.extractvalue %499[5] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc26)
    %870 = llvm.extractvalue %499[6] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc26)
    %871 = llvm.extractvalue %499[7] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc26)
    %872 = llvm.extractvalue %764[0] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc26)
    %873 = llvm.extractvalue %764[1] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc26)
    %874 = llvm.extractvalue %764[2] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc26)
    %875 = llvm.extractvalue %764[3] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc26)
    %876 = llvm.extractvalue %764[4] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc26)
    %877 = llvm.extractvalue %764[5] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc26)
    %878 = llvm.extractvalue %764[6] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc26)
    %879 = llvm.extractvalue %764[7] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc26)
    %880 = llvm.extractvalue %10[0] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc26)
    %881 = llvm.extractvalue %10[1] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc26)
    %882 = llvm.extractvalue %10[2] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc26)
    %883 = llvm.extractvalue %10[3] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc26)
    %884 = llvm.extractvalue %10[4] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc26)
    %885 = llvm.extractvalue %10[5] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc26)
    %886 = llvm.extractvalue %10[6] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc26)
    %887 = llvm.extractvalue %10[7] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc26)
    %888 = llvm.mlir.undef : vector<1xf32> loc(#loc26)
    %889 = llvm.mlir.constant(0 : index) : i32 loc(#loc26)
    %890 = llvm.insertelement %880, %888[%889 : i32] : vector<1xf32> loc(#loc26)
    %891 = llvm.bitcast %890 : vector<1xf32> to i32 loc(#loc26)
    %892 = llvm.mlir.undef : vector<1xf32> loc(#loc26)
    %893 = llvm.mlir.constant(0 : index) : i32 loc(#loc26)
    %894 = llvm.insertelement %881, %892[%893 : i32] : vector<1xf32> loc(#loc26)
    %895 = llvm.bitcast %894 : vector<1xf32> to i32 loc(#loc26)
    %896 = llvm.mlir.undef : vector<1xf32> loc(#loc26)
    %897 = llvm.mlir.constant(0 : index) : i32 loc(#loc26)
    %898 = llvm.insertelement %882, %896[%897 : i32] : vector<1xf32> loc(#loc26)
    %899 = llvm.bitcast %898 : vector<1xf32> to i32 loc(#loc26)
    %900 = llvm.mlir.undef : vector<1xf32> loc(#loc26)
    %901 = llvm.mlir.constant(0 : index) : i32 loc(#loc26)
    %902 = llvm.insertelement %883, %900[%901 : i32] : vector<1xf32> loc(#loc26)
    %903 = llvm.bitcast %902 : vector<1xf32> to i32 loc(#loc26)
    %904 = llvm.inline_asm has_side_effects asm_dialect = att operand_attrs = [] "mov.u32 $0, $4;\0A\09mov.u32 $1, $5;\0A\09mov.u32 $2, $6;\0A\09mov.u32 $3, $7;\0A\09@$9 ld.global.v4.b32 { $0, $1, $2, $3 }, [ $8 + 0 ];", "=r,=r,=r,=r,r,r,r,r,l,b" %891, %895, %899, %903, %864, %872 : (i32, i32, i32, i32, !llvm.ptr<1>, i1) -> !llvm.struct<(i32, i32, i32, i32)> loc(#loc26)
    %905 = llvm.extractvalue %904[0] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc26)
    %906 = llvm.bitcast %905 : i32 to vector<1xf32> loc(#loc26)
    %907 = llvm.extractvalue %904[1] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc26)
    %908 = llvm.bitcast %907 : i32 to vector<1xf32> loc(#loc26)
    %909 = llvm.extractvalue %904[2] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc26)
    %910 = llvm.bitcast %909 : i32 to vector<1xf32> loc(#loc26)
    %911 = llvm.extractvalue %904[3] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc26)
    %912 = llvm.bitcast %911 : i32 to vector<1xf32> loc(#loc26)
    %913 = llvm.mlir.constant(0 : index) : i32 loc(#loc26)
    %914 = llvm.extractelement %906[%913 : i32] : vector<1xf32> loc(#loc26)
    %915 = llvm.mlir.constant(0 : index) : i32 loc(#loc26)
    %916 = llvm.extractelement %908[%915 : i32] : vector<1xf32> loc(#loc26)
    %917 = llvm.mlir.constant(0 : index) : i32 loc(#loc26)
    %918 = llvm.extractelement %910[%917 : i32] : vector<1xf32> loc(#loc26)
    %919 = llvm.mlir.constant(0 : index) : i32 loc(#loc26)
    %920 = llvm.extractelement %912[%919 : i32] : vector<1xf32> loc(#loc26)
    %921 = llvm.mlir.undef : vector<1xf32> loc(#loc26)
    %922 = llvm.mlir.constant(0 : index) : i32 loc(#loc26)
    %923 = llvm.insertelement %884, %921[%922 : i32] : vector<1xf32> loc(#loc26)
    %924 = llvm.bitcast %923 : vector<1xf32> to i32 loc(#loc26)
    %925 = llvm.mlir.undef : vector<1xf32> loc(#loc26)
    %926 = llvm.mlir.constant(0 : index) : i32 loc(#loc26)
    %927 = llvm.insertelement %885, %925[%926 : i32] : vector<1xf32> loc(#loc26)
    %928 = llvm.bitcast %927 : vector<1xf32> to i32 loc(#loc26)
    %929 = llvm.mlir.undef : vector<1xf32> loc(#loc26)
    %930 = llvm.mlir.constant(0 : index) : i32 loc(#loc26)
    %931 = llvm.insertelement %886, %929[%930 : i32] : vector<1xf32> loc(#loc26)
    %932 = llvm.bitcast %931 : vector<1xf32> to i32 loc(#loc26)
    %933 = llvm.mlir.undef : vector<1xf32> loc(#loc26)
    %934 = llvm.mlir.constant(0 : index) : i32 loc(#loc26)
    %935 = llvm.insertelement %887, %933[%934 : i32] : vector<1xf32> loc(#loc26)
    %936 = llvm.bitcast %935 : vector<1xf32> to i32 loc(#loc26)
    %937 = llvm.inline_asm has_side_effects asm_dialect = att operand_attrs = [] "mov.u32 $0, $4;\0A\09mov.u32 $1, $5;\0A\09mov.u32 $2, $6;\0A\09mov.u32 $3, $7;\0A\09@$9 ld.global.v4.b32 { $0, $1, $2, $3 }, [ $8 + 0 ];", "=r,=r,=r,=r,r,r,r,r,l,b" %924, %928, %932, %936, %868, %876 : (i32, i32, i32, i32, !llvm.ptr<1>, i1) -> !llvm.struct<(i32, i32, i32, i32)> loc(#loc26)
    %938 = llvm.extractvalue %937[0] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc26)
    %939 = llvm.bitcast %938 : i32 to vector<1xf32> loc(#loc26)
    %940 = llvm.extractvalue %937[1] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc26)
    %941 = llvm.bitcast %940 : i32 to vector<1xf32> loc(#loc26)
    %942 = llvm.extractvalue %937[2] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc26)
    %943 = llvm.bitcast %942 : i32 to vector<1xf32> loc(#loc26)
    %944 = llvm.extractvalue %937[3] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc26)
    %945 = llvm.bitcast %944 : i32 to vector<1xf32> loc(#loc26)
    %946 = llvm.mlir.constant(0 : index) : i32 loc(#loc26)
    %947 = llvm.extractelement %939[%946 : i32] : vector<1xf32> loc(#loc26)
    %948 = llvm.mlir.constant(0 : index) : i32 loc(#loc26)
    %949 = llvm.extractelement %941[%948 : i32] : vector<1xf32> loc(#loc26)
    %950 = llvm.mlir.constant(0 : index) : i32 loc(#loc26)
    %951 = llvm.extractelement %943[%950 : i32] : vector<1xf32> loc(#loc26)
    %952 = llvm.mlir.constant(0 : index) : i32 loc(#loc26)
    %953 = llvm.extractelement %945[%952 : i32] : vector<1xf32> loc(#loc26)
    %954 = llvm.mlir.undef : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> loc(#loc26)
    %955 = llvm.insertvalue %914, %954[0] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc26)
    %956 = llvm.insertvalue %916, %955[1] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc26)
    %957 = llvm.insertvalue %918, %956[2] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc26)
    %958 = llvm.insertvalue %920, %957[3] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc26)
    %959 = llvm.insertvalue %947, %958[4] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc26)
    %960 = llvm.insertvalue %949, %959[5] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc26)
    %961 = llvm.insertvalue %951, %960[6] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc26)
    %962 = llvm.insertvalue %953, %961[7] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc26)
    %963 = llvm.extractvalue %863[0] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc27)
    %964 = llvm.extractvalue %863[1] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc27)
    %965 = llvm.extractvalue %863[2] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc27)
    %966 = llvm.extractvalue %863[3] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc27)
    %967 = llvm.extractvalue %863[4] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc27)
    %968 = llvm.extractvalue %863[5] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc27)
    %969 = llvm.extractvalue %863[6] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc27)
    %970 = llvm.extractvalue %863[7] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc27)
    %971 = llvm.extractvalue %962[0] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc27)
    %972 = llvm.extractvalue %962[1] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc27)
    %973 = llvm.extractvalue %962[2] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc27)
    %974 = llvm.extractvalue %962[3] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc27)
    %975 = llvm.extractvalue %962[4] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc27)
    %976 = llvm.extractvalue %962[5] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc27)
    %977 = llvm.extractvalue %962[6] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc27)
    %978 = llvm.extractvalue %962[7] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc27)
    %979 = llvm.fadd %963, %971 : f32 loc(#loc27)
    %980 = llvm.fadd %964, %972 : f32 loc(#loc27)
    %981 = llvm.fadd %965, %973 : f32 loc(#loc27)
    %982 = llvm.fadd %966, %974 : f32 loc(#loc27)
    %983 = llvm.fadd %967, %975 : f32 loc(#loc27)
    %984 = llvm.fadd %968, %976 : f32 loc(#loc27)
    %985 = llvm.fadd %969, %977 : f32 loc(#loc27)
    %986 = llvm.fadd %970, %978 : f32 loc(#loc27)
    %987 = llvm.mlir.undef : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> loc(#loc27)
    %988 = llvm.insertvalue %979, %987[0] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc27)
    %989 = llvm.insertvalue %980, %988[1] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc27)
    %990 = llvm.insertvalue %981, %989[2] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc27)
    %991 = llvm.insertvalue %982, %990[3] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc27)
    %992 = llvm.insertvalue %983, %991[4] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc27)
    %993 = llvm.insertvalue %984, %992[5] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc27)
    %994 = llvm.insertvalue %985, %993[6] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc27)
    %995 = llvm.insertvalue %986, %994[7] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc27)
    %996 = llvm.extractvalue %635[0] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc28)
    %997 = llvm.extractvalue %635[1] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc28)
    %998 = llvm.extractvalue %635[2] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc28)
    %999 = llvm.extractvalue %635[3] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc28)
    %1000 = llvm.extractvalue %635[4] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc28)
    %1001 = llvm.extractvalue %635[5] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc28)
    %1002 = llvm.extractvalue %635[6] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc28)
    %1003 = llvm.extractvalue %635[7] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc28)
    %1004 = llvm.extractvalue %995[0] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc28)
    %1005 = llvm.extractvalue %995[1] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc28)
    %1006 = llvm.extractvalue %995[2] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc28)
    %1007 = llvm.extractvalue %995[3] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc28)
    %1008 = llvm.extractvalue %995[4] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc28)
    %1009 = llvm.extractvalue %995[5] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc28)
    %1010 = llvm.extractvalue %995[6] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc28)
    %1011 = llvm.extractvalue %995[7] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc28)
    %1012 = llvm.extractvalue %764[0] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc28)
    %1013 = llvm.extractvalue %764[1] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc28)
    %1014 = llvm.extractvalue %764[2] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc28)
    %1015 = llvm.extractvalue %764[3] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc28)
    %1016 = llvm.extractvalue %764[4] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc28)
    %1017 = llvm.extractvalue %764[5] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc28)
    %1018 = llvm.extractvalue %764[6] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc28)
    %1019 = llvm.extractvalue %764[7] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc28)
    %1020 = llvm.mlir.constant(0 : i32) : i32 loc(#loc28)
    %1021 = nvvm.read.ptx.sreg.tid.x : i32 loc(#loc28)
    %1022 = llvm.mlir.constant(32 : i32) : i32 loc(#loc28)
    %1023 = llvm.urem %1021, %1022 : i32 loc(#loc28)
    %1024 = llvm.udiv %1021, %1022 : i32 loc(#loc28)
    %1025 = llvm.mlir.undef : vector<1xf32> loc(#loc28)
    %1026 = llvm.bitcast %1004 : f32 to f32 loc(#loc28)
    %1027 = llvm.mlir.constant(0 : i32) : i32 loc(#loc28)
    %1028 = llvm.insertelement %1026, %1025[%1027 : i32] : vector<1xf32> loc(#loc28)
    %1029 = llvm.bitcast %1028 : vector<1xf32> to i32 loc(#loc28)
    %1030 = llvm.mlir.undef : vector<1xf32> loc(#loc28)
    %1031 = llvm.bitcast %1005 : f32 to f32 loc(#loc28)
    %1032 = llvm.mlir.constant(0 : i32) : i32 loc(#loc28)
    %1033 = llvm.insertelement %1031, %1030[%1032 : i32] : vector<1xf32> loc(#loc28)
    %1034 = llvm.bitcast %1033 : vector<1xf32> to i32 loc(#loc28)
    %1035 = llvm.mlir.undef : vector<1xf32> loc(#loc28)
    %1036 = llvm.bitcast %1006 : f32 to f32 loc(#loc28)
    %1037 = llvm.mlir.constant(0 : i32) : i32 loc(#loc28)
    %1038 = llvm.insertelement %1036, %1035[%1037 : i32] : vector<1xf32> loc(#loc28)
    %1039 = llvm.bitcast %1038 : vector<1xf32> to i32 loc(#loc28)
    %1040 = llvm.mlir.undef : vector<1xf32> loc(#loc28)
    %1041 = llvm.bitcast %1007 : f32 to f32 loc(#loc28)
    %1042 = llvm.mlir.constant(0 : i32) : i32 loc(#loc28)
    %1043 = llvm.insertelement %1041, %1040[%1042 : i32] : vector<1xf32> loc(#loc28)
    %1044 = llvm.bitcast %1043 : vector<1xf32> to i32 loc(#loc28)
    %1045 = llvm.inline_asm has_side_effects asm_dialect = att operand_attrs = [] "@$5 st.global.v4.b32 [ $4 + 0 ], { $0, $1, $2, $3 };", "r,r,r,r,l,b" %1029, %1034, %1039, %1044, %996, %1012 : (i32, i32, i32, i32, !llvm.ptr<1>, i1) -> !llvm.void loc(#loc28)
    %1046 = llvm.mlir.undef : vector<1xf32> loc(#loc28)
    %1047 = llvm.bitcast %1008 : f32 to f32 loc(#loc28)
    %1048 = llvm.mlir.constant(0 : i32) : i32 loc(#loc28)
    %1049 = llvm.insertelement %1047, %1046[%1048 : i32] : vector<1xf32> loc(#loc28)
    %1050 = llvm.bitcast %1049 : vector<1xf32> to i32 loc(#loc28)
    %1051 = llvm.mlir.undef : vector<1xf32> loc(#loc28)
    %1052 = llvm.bitcast %1009 : f32 to f32 loc(#loc28)
    %1053 = llvm.mlir.constant(0 : i32) : i32 loc(#loc28)
    %1054 = llvm.insertelement %1052, %1051[%1053 : i32] : vector<1xf32> loc(#loc28)
    %1055 = llvm.bitcast %1054 : vector<1xf32> to i32 loc(#loc28)
    %1056 = llvm.mlir.undef : vector<1xf32> loc(#loc28)
    %1057 = llvm.bitcast %1010 : f32 to f32 loc(#loc28)
    %1058 = llvm.mlir.constant(0 : i32) : i32 loc(#loc28)
    %1059 = llvm.insertelement %1057, %1056[%1058 : i32] : vector<1xf32> loc(#loc28)
    %1060 = llvm.bitcast %1059 : vector<1xf32> to i32 loc(#loc28)
    %1061 = llvm.mlir.undef : vector<1xf32> loc(#loc28)
    %1062 = llvm.bitcast %1011 : f32 to f32 loc(#loc28)
    %1063 = llvm.mlir.constant(0 : i32) : i32 loc(#loc28)
    %1064 = llvm.insertelement %1062, %1061[%1063 : i32] : vector<1xf32> loc(#loc28)
    %1065 = llvm.bitcast %1064 : vector<1xf32> to i32 loc(#loc28)
    %1066 = llvm.inline_asm has_side_effects asm_dialect = att operand_attrs = [] "@$5 st.global.v4.b32 [ $4 + 0 ], { $0, $1, $2, $3 };", "r,r,r,r,l,b" %1050, %1055, %1060, %1065, %1000, %1016 : (i32, i32, i32, i32, !llvm.ptr<1>, i1) -> !llvm.void loc(#loc28)
    llvm.return loc(#loc29)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("examples/kernels/binary_ops.py":106:26)
#loc3 = loc("examples/kernels/binary_ops.py":107:26)
#loc4 = loc("examples/kernels/binary_ops.py":108:22)
#loc5 = loc("examples/kernels/binary_ops.py":108:50)
#loc6 = loc("examples/kernels/binary_ops.py":108:37)
#loc7 = loc("examples/kernels/binary_ops.py":108:67)
#loc8 = loc("examples/kernels/binary_ops.py":109:22)
#loc9 = loc("examples/kernels/binary_ops.py":109:37)
#loc10 = loc("examples/kernels/binary_ops.py":109:67)
#loc11 = loc("examples/kernels/binary_ops.py":110:29)
#loc12 = loc("examples/kernels/binary_ops.py":110:40)
#loc13 = loc("examples/kernels/binary_ops.py":110:59)
#loc14 = loc("examples/kernels/binary_ops.py":110:52)
#loc15 = loc("examples/kernels/binary_ops.py":110:22)
#loc16 = loc("examples/kernels/binary_ops.py":111:40)
#loc17 = loc("examples/kernels/binary_ops.py":111:52)
#loc18 = loc("examples/kernels/binary_ops.py":111:22)
#loc19 = loc("examples/kernels/binary_ops.py":112:40)
#loc20 = loc("examples/kernels/binary_ops.py":112:52)
#loc21 = loc("examples/kernels/binary_ops.py":112:22)
#loc22 = loc("examples/kernels/binary_ops.py":114:31)
#loc23 = loc("examples/kernels/binary_ops.py":114:55)
#loc24 = loc("examples/kernels/binary_ops.py":114:37)
#loc25 = loc("examples/kernels/binary_ops.py":116:16)
#loc26 = loc("examples/kernels/binary_ops.py":117:16)
#loc27 = loc("examples/kernels/binary_ops.py":118:12)
#loc28 = loc("examples/kernels/binary_ops.py":119:21)
#loc29 = loc("examples/kernels/binary_ops.py":119:4)


// -----// IR Dump Before CSE (cse) ('builtin.module' operation) //----- //
#loc = loc("examples/kernels/binary_ops.py":97:0)
module attributes {ttg.global_scratch_memory_alignment = 1 : i32, ttg.global_scratch_memory_size = 0 : i32, "ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.shared = 0 : i32, ttg.target = "cuda:89", ttg.tensor_memory_size = 0 : i32, "ttg.threads-per-warp" = 32 : i32, "ttg.total-num-warps" = 4 : i32} {
  llvm.mlir.global external @global_smem() {addr_space = 3 : i32, alignment = 16 : i64} : !llvm.array<0 x i8> loc(#loc)
  llvm.func @add_2d_kernel(%arg0: !llvm.ptr<1> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg1: !llvm.ptr<1> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg2: !llvm.ptr<1> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg3: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg4: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg5: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg6: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg7: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg8: !llvm.ptr<1> loc("examples/kernels/binary_ops.py":97:0)) attributes {noinline = false, nvvm.kernel = 1 : ui1, nvvm.reqntid = array<i32: 128>, ttg.global_scratch_memory_alignment = 1 : i32, ttg.global_scratch_memory_size = 0 : i32} {
    %0 = llvm.mlir.undef : vector<1xf32> loc(#loc1)
    %1 = llvm.mlir.constant(16 : i32) : i32 loc(#loc1)
    %2 = llvm.mlir.constant(8 : i32) : i32 loc(#loc1)
    %3 = llvm.mlir.constant(4 : i32) : i32 loc(#loc1)
    %4 = llvm.mlir.constant(2 : i32) : i32 loc(#loc1)
    %5 = llvm.mlir.constant(1 : i32) : i32 loc(#loc1)
    %6 = llvm.mlir.constant(0 : i32) : i32 loc(#loc1)
    %7 = llvm.mlir.constant(0 : index) : i32 loc(#loc1)
    %8 = llvm.mlir.constant(32 : i32) : i32 loc(#loc1)
    %9 = llvm.mlir.constant(0.000000e+00 : f32) : f32 loc(#loc1)
    %10 = llvm.call_intrinsic "llvm.nvvm.read.ptx.sreg.ctaid.x"() : () -> i32 loc(#loc2)
    %11 = llvm.call_intrinsic "llvm.nvvm.read.ptx.sreg.ctaid.y"() : () -> i32 loc(#loc3)
    %12 = llvm.mul %10, %8 : i32 loc(#loc4)
    %13 = nvvm.read.ptx.sreg.tid.x : i32 loc(#loc5)
    %14 = llvm.urem %13, %8 : i32 loc(#loc5)
    %15 = llvm.udiv %13, %8 : i32 loc(#loc5)
    %16 = llvm.and %14, %2 : i32 loc(#loc5)
    %17 = llvm.icmp "eq" %16, %6 : i32 loc(#loc5)
    %18 = llvm.select %17, %6, %5 : i1, i32 loc(#loc5)
    %19 = llvm.xor %6, %18 : i32 loc(#loc5)
    %20 = llvm.and %14, %1 : i32 loc(#loc5)
    %21 = llvm.icmp "eq" %20, %6 : i32 loc(#loc5)
    %22 = llvm.select %21, %6, %4 : i1, i32 loc(#loc5)
    %23 = llvm.xor %19, %22 : i32 loc(#loc5)
    %24 = llvm.and %15, %5 : i32 loc(#loc5)
    %25 = llvm.icmp "eq" %24, %6 : i32 loc(#loc5)
    %26 = llvm.select %25, %6, %3 : i1, i32 loc(#loc5)
    %27 = llvm.xor %23, %26 : i32 loc(#loc5)
    %28 = llvm.and %15, %4 : i32 loc(#loc5)
    %29 = llvm.icmp "eq" %28, %6 : i32 loc(#loc5)
    %30 = llvm.select %29, %6, %2 : i1, i32 loc(#loc5)
    %31 = llvm.xor %27, %30 : i32 loc(#loc5)
    %32 = llvm.xor %31, %6 : i32 loc(#loc5)
    %33 = llvm.xor %31, %1 : i32 loc(#loc5)
    %34 = llvm.add %32, %7 : i32 loc(#loc5)
    %35 = llvm.add %33, %7 : i32 loc(#loc5)
    %36 = nvvm.read.ptx.sreg.tid.x : i32 loc(#loc5)
    %37 = llvm.urem %36, %8 : i32 loc(#loc5)
    %38 = llvm.and %37, %5 : i32 loc(#loc5)
    %39 = llvm.icmp "eq" %38, %6 : i32 loc(#loc5)
    %40 = llvm.select %39, %6, %3 : i1, i32 loc(#loc5)
    %41 = llvm.xor %6, %40 : i32 loc(#loc5)
    %42 = llvm.and %37, %4 : i32 loc(#loc5)
    %43 = llvm.icmp "eq" %42, %6 : i32 loc(#loc5)
    %44 = llvm.select %43, %6, %2 : i1, i32 loc(#loc5)
    %45 = llvm.xor %41, %44 : i32 loc(#loc5)
    %46 = llvm.and %37, %3 : i32 loc(#loc5)
    %47 = llvm.icmp "eq" %46, %6 : i32 loc(#loc5)
    %48 = llvm.select %47, %6, %1 : i1, i32 loc(#loc5)
    %49 = llvm.xor %45, %48 : i32 loc(#loc5)
    %50 = llvm.xor %49, %6 : i32 loc(#loc5)
    %51 = llvm.add %50, %7 : i32 loc(#loc5)
    %52 = llvm.add %12, %34 : i32 loc(#loc6)
    %53 = llvm.add %12, %35 : i32 loc(#loc6)
    %54 = llvm.srem %52, %arg3 : i32 loc(#loc7)
    %55 = llvm.srem %53, %arg3 : i32 loc(#loc7)
    %56 = llvm.mul %11, %8 : i32 loc(#loc8)
    %57 = llvm.add %56, %51 : i32 loc(#loc9)
    %58 = llvm.srem %57, %arg4 : i32 loc(#loc10)
    %59 = llvm.mul %54, %arg5 : i32 loc(#loc11)
    %60 = llvm.mul %55, %arg5 : i32 loc(#loc11)
    %61 = llvm.add %59, %58 : i32 loc(#loc12)
    %62 = llvm.add %60, %58 : i32 loc(#loc12)
    %63 = llvm.getelementptr %arg0[%61] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc13)
    %64 = llvm.getelementptr %arg0[%62] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc13)
    %65 = llvm.mul %54, %arg6 : i32 loc(#loc14)
    %66 = llvm.mul %55, %arg6 : i32 loc(#loc14)
    %67 = llvm.add %65, %58 : i32 loc(#loc15)
    %68 = llvm.add %66, %58 : i32 loc(#loc15)
    %69 = llvm.getelementptr %arg1[%67] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc16)
    %70 = llvm.getelementptr %arg1[%68] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc16)
    %71 = llvm.mul %54, %arg7 : i32 loc(#loc17)
    %72 = llvm.mul %55, %arg7 : i32 loc(#loc17)
    %73 = llvm.add %71, %58 : i32 loc(#loc18)
    %74 = llvm.add %72, %58 : i32 loc(#loc18)
    %75 = llvm.getelementptr %arg2[%73] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc19)
    %76 = llvm.getelementptr %arg2[%74] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc19)
    %77 = llvm.icmp "slt" %54, %arg3 : i32 loc(#loc20)
    %78 = llvm.icmp "slt" %55, %arg3 : i32 loc(#loc20)
    %79 = llvm.icmp "slt" %58, %arg4 : i32 loc(#loc21)
    %80 = llvm.and %77, %79 : i1 loc(#loc22)
    %81 = llvm.and %78, %79 : i1 loc(#loc22)
    %82 = llvm.insertelement %9, %0[%7 : i32] : vector<1xf32> loc(#loc23)
    %83 = llvm.bitcast %82 : vector<1xf32> to i32 loc(#loc23)
    %84 = llvm.insertelement %9, %0[%7 : i32] : vector<1xf32> loc(#loc23)
    %85 = llvm.bitcast %84 : vector<1xf32> to i32 loc(#loc23)
    %86 = llvm.insertelement %9, %0[%7 : i32] : vector<1xf32> loc(#loc23)
    %87 = llvm.bitcast %86 : vector<1xf32> to i32 loc(#loc23)
    %88 = llvm.insertelement %9, %0[%7 : i32] : vector<1xf32> loc(#loc23)
    %89 = llvm.bitcast %88 : vector<1xf32> to i32 loc(#loc23)
    %90 = llvm.inline_asm has_side_effects asm_dialect = att operand_attrs = [] "mov.u32 $0, $4;\0A\09mov.u32 $1, $5;\0A\09mov.u32 $2, $6;\0A\09mov.u32 $3, $7;\0A\09@$9 ld.global.v4.b32 { $0, $1, $2, $3 }, [ $8 + 0 ];", "=r,=r,=r,=r,r,r,r,r,l,b" %83, %85, %87, %89, %63, %80 : (i32, i32, i32, i32, !llvm.ptr<1>, i1) -> !llvm.struct<(i32, i32, i32, i32)> loc(#loc23)
    %91 = llvm.extractvalue %90[0] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc23)
    %92 = llvm.bitcast %91 : i32 to vector<1xf32> loc(#loc23)
    %93 = llvm.extractvalue %90[1] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc23)
    %94 = llvm.bitcast %93 : i32 to vector<1xf32> loc(#loc23)
    %95 = llvm.extractvalue %90[2] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc23)
    %96 = llvm.bitcast %95 : i32 to vector<1xf32> loc(#loc23)
    %97 = llvm.extractvalue %90[3] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc23)
    %98 = llvm.bitcast %97 : i32 to vector<1xf32> loc(#loc23)
    %99 = llvm.extractelement %92[%7 : i32] : vector<1xf32> loc(#loc23)
    %100 = llvm.extractelement %94[%7 : i32] : vector<1xf32> loc(#loc23)
    %101 = llvm.extractelement %96[%7 : i32] : vector<1xf32> loc(#loc23)
    %102 = llvm.extractelement %98[%7 : i32] : vector<1xf32> loc(#loc23)
    %103 = llvm.insertelement %9, %0[%7 : i32] : vector<1xf32> loc(#loc23)
    %104 = llvm.bitcast %103 : vector<1xf32> to i32 loc(#loc23)
    %105 = llvm.insertelement %9, %0[%7 : i32] : vector<1xf32> loc(#loc23)
    %106 = llvm.bitcast %105 : vector<1xf32> to i32 loc(#loc23)
    %107 = llvm.insertelement %9, %0[%7 : i32] : vector<1xf32> loc(#loc23)
    %108 = llvm.bitcast %107 : vector<1xf32> to i32 loc(#loc23)
    %109 = llvm.insertelement %9, %0[%7 : i32] : vector<1xf32> loc(#loc23)
    %110 = llvm.bitcast %109 : vector<1xf32> to i32 loc(#loc23)
    %111 = llvm.inline_asm has_side_effects asm_dialect = att operand_attrs = [] "mov.u32 $0, $4;\0A\09mov.u32 $1, $5;\0A\09mov.u32 $2, $6;\0A\09mov.u32 $3, $7;\0A\09@$9 ld.global.v4.b32 { $0, $1, $2, $3 }, [ $8 + 0 ];", "=r,=r,=r,=r,r,r,r,r,l,b" %104, %106, %108, %110, %64, %81 : (i32, i32, i32, i32, !llvm.ptr<1>, i1) -> !llvm.struct<(i32, i32, i32, i32)> loc(#loc23)
    %112 = llvm.extractvalue %111[0] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc23)
    %113 = llvm.bitcast %112 : i32 to vector<1xf32> loc(#loc23)
    %114 = llvm.extractvalue %111[1] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc23)
    %115 = llvm.bitcast %114 : i32 to vector<1xf32> loc(#loc23)
    %116 = llvm.extractvalue %111[2] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc23)
    %117 = llvm.bitcast %116 : i32 to vector<1xf32> loc(#loc23)
    %118 = llvm.extractvalue %111[3] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc23)
    %119 = llvm.bitcast %118 : i32 to vector<1xf32> loc(#loc23)
    %120 = llvm.extractelement %113[%7 : i32] : vector<1xf32> loc(#loc23)
    %121 = llvm.extractelement %115[%7 : i32] : vector<1xf32> loc(#loc23)
    %122 = llvm.extractelement %117[%7 : i32] : vector<1xf32> loc(#loc23)
    %123 = llvm.extractelement %119[%7 : i32] : vector<1xf32> loc(#loc23)
    %124 = llvm.insertelement %9, %0[%7 : i32] : vector<1xf32> loc(#loc24)
    %125 = llvm.bitcast %124 : vector<1xf32> to i32 loc(#loc24)
    %126 = llvm.insertelement %9, %0[%7 : i32] : vector<1xf32> loc(#loc24)
    %127 = llvm.bitcast %126 : vector<1xf32> to i32 loc(#loc24)
    %128 = llvm.insertelement %9, %0[%7 : i32] : vector<1xf32> loc(#loc24)
    %129 = llvm.bitcast %128 : vector<1xf32> to i32 loc(#loc24)
    %130 = llvm.insertelement %9, %0[%7 : i32] : vector<1xf32> loc(#loc24)
    %131 = llvm.bitcast %130 : vector<1xf32> to i32 loc(#loc24)
    %132 = llvm.inline_asm has_side_effects asm_dialect = att operand_attrs = [] "mov.u32 $0, $4;\0A\09mov.u32 $1, $5;\0A\09mov.u32 $2, $6;\0A\09mov.u32 $3, $7;\0A\09@$9 ld.global.v4.b32 { $0, $1, $2, $3 }, [ $8 + 0 ];", "=r,=r,=r,=r,r,r,r,r,l,b" %125, %127, %129, %131, %69, %80 : (i32, i32, i32, i32, !llvm.ptr<1>, i1) -> !llvm.struct<(i32, i32, i32, i32)> loc(#loc24)
    %133 = llvm.extractvalue %132[0] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc24)
    %134 = llvm.bitcast %133 : i32 to vector<1xf32> loc(#loc24)
    %135 = llvm.extractvalue %132[1] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc24)
    %136 = llvm.bitcast %135 : i32 to vector<1xf32> loc(#loc24)
    %137 = llvm.extractvalue %132[2] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc24)
    %138 = llvm.bitcast %137 : i32 to vector<1xf32> loc(#loc24)
    %139 = llvm.extractvalue %132[3] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc24)
    %140 = llvm.bitcast %139 : i32 to vector<1xf32> loc(#loc24)
    %141 = llvm.extractelement %134[%7 : i32] : vector<1xf32> loc(#loc24)
    %142 = llvm.extractelement %136[%7 : i32] : vector<1xf32> loc(#loc24)
    %143 = llvm.extractelement %138[%7 : i32] : vector<1xf32> loc(#loc24)
    %144 = llvm.extractelement %140[%7 : i32] : vector<1xf32> loc(#loc24)
    %145 = llvm.insertelement %9, %0[%7 : i32] : vector<1xf32> loc(#loc24)
    %146 = llvm.bitcast %145 : vector<1xf32> to i32 loc(#loc24)
    %147 = llvm.insertelement %9, %0[%7 : i32] : vector<1xf32> loc(#loc24)
    %148 = llvm.bitcast %147 : vector<1xf32> to i32 loc(#loc24)
    %149 = llvm.insertelement %9, %0[%7 : i32] : vector<1xf32> loc(#loc24)
    %150 = llvm.bitcast %149 : vector<1xf32> to i32 loc(#loc24)
    %151 = llvm.insertelement %9, %0[%7 : i32] : vector<1xf32> loc(#loc24)
    %152 = llvm.bitcast %151 : vector<1xf32> to i32 loc(#loc24)
    %153 = llvm.inline_asm has_side_effects asm_dialect = att operand_attrs = [] "mov.u32 $0, $4;\0A\09mov.u32 $1, $5;\0A\09mov.u32 $2, $6;\0A\09mov.u32 $3, $7;\0A\09@$9 ld.global.v4.b32 { $0, $1, $2, $3 }, [ $8 + 0 ];", "=r,=r,=r,=r,r,r,r,r,l,b" %146, %148, %150, %152, %70, %81 : (i32, i32, i32, i32, !llvm.ptr<1>, i1) -> !llvm.struct<(i32, i32, i32, i32)> loc(#loc24)
    %154 = llvm.extractvalue %153[0] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc24)
    %155 = llvm.bitcast %154 : i32 to vector<1xf32> loc(#loc24)
    %156 = llvm.extractvalue %153[1] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc24)
    %157 = llvm.bitcast %156 : i32 to vector<1xf32> loc(#loc24)
    %158 = llvm.extractvalue %153[2] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc24)
    %159 = llvm.bitcast %158 : i32 to vector<1xf32> loc(#loc24)
    %160 = llvm.extractvalue %153[3] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc24)
    %161 = llvm.bitcast %160 : i32 to vector<1xf32> loc(#loc24)
    %162 = llvm.extractelement %155[%7 : i32] : vector<1xf32> loc(#loc24)
    %163 = llvm.extractelement %157[%7 : i32] : vector<1xf32> loc(#loc24)
    %164 = llvm.extractelement %159[%7 : i32] : vector<1xf32> loc(#loc24)
    %165 = llvm.extractelement %161[%7 : i32] : vector<1xf32> loc(#loc24)
    %166 = llvm.fadd %99, %141 : f32 loc(#loc25)
    %167 = llvm.fadd %100, %142 : f32 loc(#loc25)
    %168 = llvm.fadd %101, %143 : f32 loc(#loc25)
    %169 = llvm.fadd %102, %144 : f32 loc(#loc25)
    %170 = llvm.fadd %120, %162 : f32 loc(#loc25)
    %171 = llvm.fadd %121, %163 : f32 loc(#loc25)
    %172 = llvm.fadd %122, %164 : f32 loc(#loc25)
    %173 = llvm.fadd %123, %165 : f32 loc(#loc25)
    %174 = llvm.insertelement %166, %0[%6 : i32] : vector<1xf32> loc(#loc26)
    %175 = llvm.bitcast %174 : vector<1xf32> to i32 loc(#loc26)
    %176 = llvm.insertelement %167, %0[%6 : i32] : vector<1xf32> loc(#loc26)
    %177 = llvm.bitcast %176 : vector<1xf32> to i32 loc(#loc26)
    %178 = llvm.insertelement %168, %0[%6 : i32] : vector<1xf32> loc(#loc26)
    %179 = llvm.bitcast %178 : vector<1xf32> to i32 loc(#loc26)
    %180 = llvm.insertelement %169, %0[%6 : i32] : vector<1xf32> loc(#loc26)
    %181 = llvm.bitcast %180 : vector<1xf32> to i32 loc(#loc26)
    %182 = llvm.inline_asm has_side_effects asm_dialect = att operand_attrs = [] "@$5 st.global.v4.b32 [ $4 + 0 ], { $0, $1, $2, $3 };", "r,r,r,r,l,b" %175, %177, %179, %181, %75, %80 : (i32, i32, i32, i32, !llvm.ptr<1>, i1) -> !llvm.void loc(#loc26)
    %183 = llvm.insertelement %170, %0[%6 : i32] : vector<1xf32> loc(#loc26)
    %184 = llvm.bitcast %183 : vector<1xf32> to i32 loc(#loc26)
    %185 = llvm.insertelement %171, %0[%6 : i32] : vector<1xf32> loc(#loc26)
    %186 = llvm.bitcast %185 : vector<1xf32> to i32 loc(#loc26)
    %187 = llvm.insertelement %172, %0[%6 : i32] : vector<1xf32> loc(#loc26)
    %188 = llvm.bitcast %187 : vector<1xf32> to i32 loc(#loc26)
    %189 = llvm.insertelement %173, %0[%6 : i32] : vector<1xf32> loc(#loc26)
    %190 = llvm.bitcast %189 : vector<1xf32> to i32 loc(#loc26)
    %191 = llvm.inline_asm has_side_effects asm_dialect = att operand_attrs = [] "@$5 st.global.v4.b32 [ $4 + 0 ], { $0, $1, $2, $3 };", "r,r,r,r,l,b" %184, %186, %188, %190, %76, %81 : (i32, i32, i32, i32, !llvm.ptr<1>, i1) -> !llvm.void loc(#loc26)
    llvm.return loc(#loc27)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("examples/kernels/binary_ops.py":106:26)
#loc3 = loc("examples/kernels/binary_ops.py":107:26)
#loc4 = loc("examples/kernels/binary_ops.py":108:22)
#loc5 = loc("examples/kernels/binary_ops.py":108:50)
#loc6 = loc("examples/kernels/binary_ops.py":108:37)
#loc7 = loc("examples/kernels/binary_ops.py":108:67)
#loc8 = loc("examples/kernels/binary_ops.py":109:22)
#loc9 = loc("examples/kernels/binary_ops.py":109:37)
#loc10 = loc("examples/kernels/binary_ops.py":109:67)
#loc11 = loc("examples/kernels/binary_ops.py":110:40)
#loc12 = loc("examples/kernels/binary_ops.py":110:52)
#loc13 = loc("examples/kernels/binary_ops.py":110:22)
#loc14 = loc("examples/kernels/binary_ops.py":111:40)
#loc15 = loc("examples/kernels/binary_ops.py":111:52)
#loc16 = loc("examples/kernels/binary_ops.py":111:22)
#loc17 = loc("examples/kernels/binary_ops.py":112:40)
#loc18 = loc("examples/kernels/binary_ops.py":112:52)
#loc19 = loc("examples/kernels/binary_ops.py":112:22)
#loc20 = loc("examples/kernels/binary_ops.py":114:31)
#loc21 = loc("examples/kernels/binary_ops.py":114:55)
#loc22 = loc("examples/kernels/binary_ops.py":114:37)
#loc23 = loc("examples/kernels/binary_ops.py":116:16)
#loc24 = loc("examples/kernels/binary_ops.py":117:16)
#loc25 = loc("examples/kernels/binary_ops.py":118:12)
#loc26 = loc("examples/kernels/binary_ops.py":119:21)
#loc27 = loc("examples/kernels/binary_ops.py":119:4)


// -----// IR Dump Before ConvertNVGPUToLLVM (convert-nv-gpu-to-llvm) ('builtin.module' operation) //----- //
#loc = loc("examples/kernels/binary_ops.py":97:0)
module attributes {ttg.global_scratch_memory_alignment = 1 : i32, ttg.global_scratch_memory_size = 0 : i32, "ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.shared = 0 : i32, ttg.target = "cuda:89", ttg.tensor_memory_size = 0 : i32, "ttg.threads-per-warp" = 32 : i32, "ttg.total-num-warps" = 4 : i32} {
  llvm.mlir.global external @global_smem() {addr_space = 3 : i32, alignment = 16 : i64} : !llvm.array<0 x i8> loc(#loc)
  llvm.func @add_2d_kernel(%arg0: !llvm.ptr<1> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg1: !llvm.ptr<1> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg2: !llvm.ptr<1> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg3: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg4: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg5: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg6: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg7: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg8: !llvm.ptr<1> loc("examples/kernels/binary_ops.py":97:0)) attributes {noinline = false, nvvm.kernel = 1 : ui1, nvvm.reqntid = array<i32: 128>, ttg.global_scratch_memory_alignment = 1 : i32, ttg.global_scratch_memory_size = 0 : i32} {
    %0 = llvm.mlir.undef : vector<1xf32> loc(#loc1)
    %1 = llvm.mlir.constant(16 : i32) : i32 loc(#loc1)
    %2 = llvm.mlir.constant(8 : i32) : i32 loc(#loc1)
    %3 = llvm.mlir.constant(4 : i32) : i32 loc(#loc1)
    %4 = llvm.mlir.constant(2 : i32) : i32 loc(#loc1)
    %5 = llvm.mlir.constant(1 : i32) : i32 loc(#loc1)
    %6 = llvm.mlir.constant(0 : i32) : i32 loc(#loc1)
    %7 = llvm.mlir.constant(0 : index) : i32 loc(#loc1)
    %8 = llvm.mlir.constant(32 : i32) : i32 loc(#loc1)
    %9 = llvm.mlir.constant(0.000000e+00 : f32) : f32 loc(#loc1)
    %10 = llvm.call_intrinsic "llvm.nvvm.read.ptx.sreg.ctaid.x"() : () -> i32 loc(#loc2)
    %11 = llvm.call_intrinsic "llvm.nvvm.read.ptx.sreg.ctaid.y"() : () -> i32 loc(#loc3)
    %12 = llvm.mul %10, %8 : i32 loc(#loc4)
    %13 = nvvm.read.ptx.sreg.tid.x : i32 loc(#loc5)
    %14 = llvm.urem %13, %8 : i32 loc(#loc5)
    %15 = llvm.udiv %13, %8 : i32 loc(#loc5)
    %16 = llvm.and %14, %2 : i32 loc(#loc5)
    %17 = llvm.icmp "eq" %16, %6 : i32 loc(#loc5)
    %18 = llvm.select %17, %6, %5 : i1, i32 loc(#loc5)
    %19 = llvm.xor %6, %18 : i32 loc(#loc5)
    %20 = llvm.and %14, %1 : i32 loc(#loc5)
    %21 = llvm.icmp "eq" %20, %6 : i32 loc(#loc5)
    %22 = llvm.select %21, %6, %4 : i1, i32 loc(#loc5)
    %23 = llvm.xor %19, %22 : i32 loc(#loc5)
    %24 = llvm.and %15, %5 : i32 loc(#loc5)
    %25 = llvm.icmp "eq" %24, %6 : i32 loc(#loc5)
    %26 = llvm.select %25, %6, %3 : i1, i32 loc(#loc5)
    %27 = llvm.xor %23, %26 : i32 loc(#loc5)
    %28 = llvm.and %15, %4 : i32 loc(#loc5)
    %29 = llvm.icmp "eq" %28, %6 : i32 loc(#loc5)
    %30 = llvm.select %29, %6, %2 : i1, i32 loc(#loc5)
    %31 = llvm.xor %27, %30 : i32 loc(#loc5)
    %32 = llvm.xor %31, %6 : i32 loc(#loc5)
    %33 = llvm.xor %31, %1 : i32 loc(#loc5)
    %34 = llvm.add %32, %7 : i32 loc(#loc5)
    %35 = llvm.add %33, %7 : i32 loc(#loc5)
    %36 = llvm.and %14, %5 : i32 loc(#loc5)
    %37 = llvm.icmp "eq" %36, %6 : i32 loc(#loc5)
    %38 = llvm.select %37, %6, %3 : i1, i32 loc(#loc5)
    %39 = llvm.xor %6, %38 : i32 loc(#loc5)
    %40 = llvm.and %14, %4 : i32 loc(#loc5)
    %41 = llvm.icmp "eq" %40, %6 : i32 loc(#loc5)
    %42 = llvm.select %41, %6, %2 : i1, i32 loc(#loc5)
    %43 = llvm.xor %39, %42 : i32 loc(#loc5)
    %44 = llvm.and %14, %3 : i32 loc(#loc5)
    %45 = llvm.icmp "eq" %44, %6 : i32 loc(#loc5)
    %46 = llvm.select %45, %6, %1 : i1, i32 loc(#loc5)
    %47 = llvm.xor %43, %46 : i32 loc(#loc5)
    %48 = llvm.xor %47, %6 : i32 loc(#loc5)
    %49 = llvm.add %48, %7 : i32 loc(#loc5)
    %50 = llvm.add %12, %34 : i32 loc(#loc6)
    %51 = llvm.add %12, %35 : i32 loc(#loc6)
    %52 = llvm.srem %50, %arg3 : i32 loc(#loc7)
    %53 = llvm.srem %51, %arg3 : i32 loc(#loc7)
    %54 = llvm.mul %11, %8 : i32 loc(#loc8)
    %55 = llvm.add %54, %49 : i32 loc(#loc9)
    %56 = llvm.srem %55, %arg4 : i32 loc(#loc10)
    %57 = llvm.mul %52, %arg5 : i32 loc(#loc11)
    %58 = llvm.mul %53, %arg5 : i32 loc(#loc11)
    %59 = llvm.add %57, %56 : i32 loc(#loc12)
    %60 = llvm.add %58, %56 : i32 loc(#loc12)
    %61 = llvm.getelementptr %arg0[%59] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc13)
    %62 = llvm.getelementptr %arg0[%60] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc13)
    %63 = llvm.mul %52, %arg6 : i32 loc(#loc14)
    %64 = llvm.mul %53, %arg6 : i32 loc(#loc14)
    %65 = llvm.add %63, %56 : i32 loc(#loc15)
    %66 = llvm.add %64, %56 : i32 loc(#loc15)
    %67 = llvm.getelementptr %arg1[%65] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc16)
    %68 = llvm.getelementptr %arg1[%66] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc16)
    %69 = llvm.mul %52, %arg7 : i32 loc(#loc17)
    %70 = llvm.mul %53, %arg7 : i32 loc(#loc17)
    %71 = llvm.add %69, %56 : i32 loc(#loc18)
    %72 = llvm.add %70, %56 : i32 loc(#loc18)
    %73 = llvm.getelementptr %arg2[%71] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc19)
    %74 = llvm.getelementptr %arg2[%72] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc19)
    %75 = llvm.icmp "slt" %52, %arg3 : i32 loc(#loc20)
    %76 = llvm.icmp "slt" %53, %arg3 : i32 loc(#loc20)
    %77 = llvm.icmp "slt" %56, %arg4 : i32 loc(#loc21)
    %78 = llvm.and %75, %77 : i1 loc(#loc22)
    %79 = llvm.and %76, %77 : i1 loc(#loc22)
    %80 = llvm.insertelement %9, %0[%7 : i32] : vector<1xf32> loc(#loc23)
    %81 = llvm.bitcast %80 : vector<1xf32> to i32 loc(#loc23)
    %82 = llvm.inline_asm has_side_effects asm_dialect = att operand_attrs = [] "mov.u32 $0, $4;\0A\09mov.u32 $1, $5;\0A\09mov.u32 $2, $6;\0A\09mov.u32 $3, $7;\0A\09@$9 ld.global.v4.b32 { $0, $1, $2, $3 }, [ $8 + 0 ];", "=r,=r,=r,=r,r,r,r,r,l,b" %81, %81, %81, %81, %61, %78 : (i32, i32, i32, i32, !llvm.ptr<1>, i1) -> !llvm.struct<(i32, i32, i32, i32)> loc(#loc23)
    %83 = llvm.extractvalue %82[0] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc23)
    %84 = llvm.bitcast %83 : i32 to vector<1xf32> loc(#loc23)
    %85 = llvm.extractvalue %82[1] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc23)
    %86 = llvm.bitcast %85 : i32 to vector<1xf32> loc(#loc23)
    %87 = llvm.extractvalue %82[2] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc23)
    %88 = llvm.bitcast %87 : i32 to vector<1xf32> loc(#loc23)
    %89 = llvm.extractvalue %82[3] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc23)
    %90 = llvm.bitcast %89 : i32 to vector<1xf32> loc(#loc23)
    %91 = llvm.extractelement %84[%7 : i32] : vector<1xf32> loc(#loc23)
    %92 = llvm.extractelement %86[%7 : i32] : vector<1xf32> loc(#loc23)
    %93 = llvm.extractelement %88[%7 : i32] : vector<1xf32> loc(#loc23)
    %94 = llvm.extractelement %90[%7 : i32] : vector<1xf32> loc(#loc23)
    %95 = llvm.inline_asm has_side_effects asm_dialect = att operand_attrs = [] "mov.u32 $0, $4;\0A\09mov.u32 $1, $5;\0A\09mov.u32 $2, $6;\0A\09mov.u32 $3, $7;\0A\09@$9 ld.global.v4.b32 { $0, $1, $2, $3 }, [ $8 + 0 ];", "=r,=r,=r,=r,r,r,r,r,l,b" %81, %81, %81, %81, %62, %79 : (i32, i32, i32, i32, !llvm.ptr<1>, i1) -> !llvm.struct<(i32, i32, i32, i32)> loc(#loc23)
    %96 = llvm.extractvalue %95[0] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc23)
    %97 = llvm.bitcast %96 : i32 to vector<1xf32> loc(#loc23)
    %98 = llvm.extractvalue %95[1] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc23)
    %99 = llvm.bitcast %98 : i32 to vector<1xf32> loc(#loc23)
    %100 = llvm.extractvalue %95[2] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc23)
    %101 = llvm.bitcast %100 : i32 to vector<1xf32> loc(#loc23)
    %102 = llvm.extractvalue %95[3] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc23)
    %103 = llvm.bitcast %102 : i32 to vector<1xf32> loc(#loc23)
    %104 = llvm.extractelement %97[%7 : i32] : vector<1xf32> loc(#loc23)
    %105 = llvm.extractelement %99[%7 : i32] : vector<1xf32> loc(#loc23)
    %106 = llvm.extractelement %101[%7 : i32] : vector<1xf32> loc(#loc23)
    %107 = llvm.extractelement %103[%7 : i32] : vector<1xf32> loc(#loc23)
    %108 = llvm.inline_asm has_side_effects asm_dialect = att operand_attrs = [] "mov.u32 $0, $4;\0A\09mov.u32 $1, $5;\0A\09mov.u32 $2, $6;\0A\09mov.u32 $3, $7;\0A\09@$9 ld.global.v4.b32 { $0, $1, $2, $3 }, [ $8 + 0 ];", "=r,=r,=r,=r,r,r,r,r,l,b" %81, %81, %81, %81, %67, %78 : (i32, i32, i32, i32, !llvm.ptr<1>, i1) -> !llvm.struct<(i32, i32, i32, i32)> loc(#loc24)
    %109 = llvm.extractvalue %108[0] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc24)
    %110 = llvm.bitcast %109 : i32 to vector<1xf32> loc(#loc24)
    %111 = llvm.extractvalue %108[1] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc24)
    %112 = llvm.bitcast %111 : i32 to vector<1xf32> loc(#loc24)
    %113 = llvm.extractvalue %108[2] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc24)
    %114 = llvm.bitcast %113 : i32 to vector<1xf32> loc(#loc24)
    %115 = llvm.extractvalue %108[3] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc24)
    %116 = llvm.bitcast %115 : i32 to vector<1xf32> loc(#loc24)
    %117 = llvm.extractelement %110[%7 : i32] : vector<1xf32> loc(#loc24)
    %118 = llvm.extractelement %112[%7 : i32] : vector<1xf32> loc(#loc24)
    %119 = llvm.extractelement %114[%7 : i32] : vector<1xf32> loc(#loc24)
    %120 = llvm.extractelement %116[%7 : i32] : vector<1xf32> loc(#loc24)
    %121 = llvm.inline_asm has_side_effects asm_dialect = att operand_attrs = [] "mov.u32 $0, $4;\0A\09mov.u32 $1, $5;\0A\09mov.u32 $2, $6;\0A\09mov.u32 $3, $7;\0A\09@$9 ld.global.v4.b32 { $0, $1, $2, $3 }, [ $8 + 0 ];", "=r,=r,=r,=r,r,r,r,r,l,b" %81, %81, %81, %81, %68, %79 : (i32, i32, i32, i32, !llvm.ptr<1>, i1) -> !llvm.struct<(i32, i32, i32, i32)> loc(#loc24)
    %122 = llvm.extractvalue %121[0] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc24)
    %123 = llvm.bitcast %122 : i32 to vector<1xf32> loc(#loc24)
    %124 = llvm.extractvalue %121[1] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc24)
    %125 = llvm.bitcast %124 : i32 to vector<1xf32> loc(#loc24)
    %126 = llvm.extractvalue %121[2] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc24)
    %127 = llvm.bitcast %126 : i32 to vector<1xf32> loc(#loc24)
    %128 = llvm.extractvalue %121[3] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc24)
    %129 = llvm.bitcast %128 : i32 to vector<1xf32> loc(#loc24)
    %130 = llvm.extractelement %123[%7 : i32] : vector<1xf32> loc(#loc24)
    %131 = llvm.extractelement %125[%7 : i32] : vector<1xf32> loc(#loc24)
    %132 = llvm.extractelement %127[%7 : i32] : vector<1xf32> loc(#loc24)
    %133 = llvm.extractelement %129[%7 : i32] : vector<1xf32> loc(#loc24)
    %134 = llvm.fadd %91, %117 : f32 loc(#loc25)
    %135 = llvm.fadd %92, %118 : f32 loc(#loc25)
    %136 = llvm.fadd %93, %119 : f32 loc(#loc25)
    %137 = llvm.fadd %94, %120 : f32 loc(#loc25)
    %138 = llvm.fadd %104, %130 : f32 loc(#loc25)
    %139 = llvm.fadd %105, %131 : f32 loc(#loc25)
    %140 = llvm.fadd %106, %132 : f32 loc(#loc25)
    %141 = llvm.fadd %107, %133 : f32 loc(#loc25)
    %142 = llvm.insertelement %134, %0[%6 : i32] : vector<1xf32> loc(#loc26)
    %143 = llvm.bitcast %142 : vector<1xf32> to i32 loc(#loc26)
    %144 = llvm.insertelement %135, %0[%6 : i32] : vector<1xf32> loc(#loc26)
    %145 = llvm.bitcast %144 : vector<1xf32> to i32 loc(#loc26)
    %146 = llvm.insertelement %136, %0[%6 : i32] : vector<1xf32> loc(#loc26)
    %147 = llvm.bitcast %146 : vector<1xf32> to i32 loc(#loc26)
    %148 = llvm.insertelement %137, %0[%6 : i32] : vector<1xf32> loc(#loc26)
    %149 = llvm.bitcast %148 : vector<1xf32> to i32 loc(#loc26)
    %150 = llvm.inline_asm has_side_effects asm_dialect = att operand_attrs = [] "@$5 st.global.v4.b32 [ $4 + 0 ], { $0, $1, $2, $3 };", "r,r,r,r,l,b" %143, %145, %147, %149, %73, %78 : (i32, i32, i32, i32, !llvm.ptr<1>, i1) -> !llvm.void loc(#loc26)
    %151 = llvm.insertelement %138, %0[%6 : i32] : vector<1xf32> loc(#loc26)
    %152 = llvm.bitcast %151 : vector<1xf32> to i32 loc(#loc26)
    %153 = llvm.insertelement %139, %0[%6 : i32] : vector<1xf32> loc(#loc26)
    %154 = llvm.bitcast %153 : vector<1xf32> to i32 loc(#loc26)
    %155 = llvm.insertelement %140, %0[%6 : i32] : vector<1xf32> loc(#loc26)
    %156 = llvm.bitcast %155 : vector<1xf32> to i32 loc(#loc26)
    %157 = llvm.insertelement %141, %0[%6 : i32] : vector<1xf32> loc(#loc26)
    %158 = llvm.bitcast %157 : vector<1xf32> to i32 loc(#loc26)
    %159 = llvm.inline_asm has_side_effects asm_dialect = att operand_attrs = [] "@$5 st.global.v4.b32 [ $4 + 0 ], { $0, $1, $2, $3 };", "r,r,r,r,l,b" %152, %154, %156, %158, %74, %79 : (i32, i32, i32, i32, !llvm.ptr<1>, i1) -> !llvm.void loc(#loc26)
    llvm.return loc(#loc27)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("examples/kernels/binary_ops.py":106:26)
#loc3 = loc("examples/kernels/binary_ops.py":107:26)
#loc4 = loc("examples/kernels/binary_ops.py":108:22)
#loc5 = loc("examples/kernels/binary_ops.py":108:50)
#loc6 = loc("examples/kernels/binary_ops.py":108:37)
#loc7 = loc("examples/kernels/binary_ops.py":108:67)
#loc8 = loc("examples/kernels/binary_ops.py":109:22)
#loc9 = loc("examples/kernels/binary_ops.py":109:37)
#loc10 = loc("examples/kernels/binary_ops.py":109:67)
#loc11 = loc("examples/kernels/binary_ops.py":110:40)
#loc12 = loc("examples/kernels/binary_ops.py":110:52)
#loc13 = loc("examples/kernels/binary_ops.py":110:22)
#loc14 = loc("examples/kernels/binary_ops.py":111:40)
#loc15 = loc("examples/kernels/binary_ops.py":111:52)
#loc16 = loc("examples/kernels/binary_ops.py":111:22)
#loc17 = loc("examples/kernels/binary_ops.py":112:40)
#loc18 = loc("examples/kernels/binary_ops.py":112:52)
#loc19 = loc("examples/kernels/binary_ops.py":112:22)
#loc20 = loc("examples/kernels/binary_ops.py":114:31)
#loc21 = loc("examples/kernels/binary_ops.py":114:55)
#loc22 = loc("examples/kernels/binary_ops.py":114:37)
#loc23 = loc("examples/kernels/binary_ops.py":116:16)
#loc24 = loc("examples/kernels/binary_ops.py":117:16)
#loc25 = loc("examples/kernels/binary_ops.py":118:12)
#loc26 = loc("examples/kernels/binary_ops.py":119:21)
#loc27 = loc("examples/kernels/binary_ops.py":119:4)


// -----// IR Dump Before ConvertWarpSpecializeToLLVM (convert-warp-specialize-to-llvm) ('builtin.module' operation) //----- //
#loc = loc("examples/kernels/binary_ops.py":97:0)
module attributes {ttg.global_scratch_memory_alignment = 1 : i32, ttg.global_scratch_memory_size = 0 : i32, "ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.shared = 0 : i32, ttg.target = "cuda:89", ttg.tensor_memory_size = 0 : i32, "ttg.threads-per-warp" = 32 : i32, "ttg.total-num-warps" = 4 : i32} {
  llvm.mlir.global external @global_smem() {addr_space = 3 : i32, alignment = 16 : i64} : !llvm.array<0 x i8> loc(#loc)
  llvm.func @add_2d_kernel(%arg0: !llvm.ptr<1> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg1: !llvm.ptr<1> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg2: !llvm.ptr<1> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg3: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg4: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg5: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg6: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg7: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg8: !llvm.ptr<1> loc("examples/kernels/binary_ops.py":97:0)) attributes {noinline = false, nvvm.kernel = 1 : ui1, nvvm.reqntid = array<i32: 128>, ttg.global_scratch_memory_alignment = 1 : i32, ttg.global_scratch_memory_size = 0 : i32} {
    %0 = llvm.mlir.undef : vector<1xf32> loc(#loc1)
    %1 = llvm.mlir.constant(16 : i32) : i32 loc(#loc1)
    %2 = llvm.mlir.constant(8 : i32) : i32 loc(#loc1)
    %3 = llvm.mlir.constant(4 : i32) : i32 loc(#loc1)
    %4 = llvm.mlir.constant(2 : i32) : i32 loc(#loc1)
    %5 = llvm.mlir.constant(1 : i32) : i32 loc(#loc1)
    %6 = llvm.mlir.constant(0 : i32) : i32 loc(#loc1)
    %7 = llvm.mlir.constant(0 : index) : i32 loc(#loc1)
    %8 = llvm.mlir.constant(32 : i32) : i32 loc(#loc1)
    %9 = llvm.mlir.constant(0.000000e+00 : f32) : f32 loc(#loc1)
    %10 = llvm.call_intrinsic "llvm.nvvm.read.ptx.sreg.ctaid.x"() : () -> i32 loc(#loc2)
    %11 = llvm.call_intrinsic "llvm.nvvm.read.ptx.sreg.ctaid.y"() : () -> i32 loc(#loc3)
    %12 = llvm.mul %10, %8 : i32 loc(#loc4)
    %13 = nvvm.read.ptx.sreg.tid.x : i32 loc(#loc5)
    %14 = llvm.urem %13, %8 : i32 loc(#loc5)
    %15 = llvm.udiv %13, %8 : i32 loc(#loc5)
    %16 = llvm.and %14, %2 : i32 loc(#loc5)
    %17 = llvm.icmp "eq" %16, %6 : i32 loc(#loc5)
    %18 = llvm.select %17, %6, %5 : i1, i32 loc(#loc5)
    %19 = llvm.xor %6, %18 : i32 loc(#loc5)
    %20 = llvm.and %14, %1 : i32 loc(#loc5)
    %21 = llvm.icmp "eq" %20, %6 : i32 loc(#loc5)
    %22 = llvm.select %21, %6, %4 : i1, i32 loc(#loc5)
    %23 = llvm.xor %19, %22 : i32 loc(#loc5)
    %24 = llvm.and %15, %5 : i32 loc(#loc5)
    %25 = llvm.icmp "eq" %24, %6 : i32 loc(#loc5)
    %26 = llvm.select %25, %6, %3 : i1, i32 loc(#loc5)
    %27 = llvm.xor %23, %26 : i32 loc(#loc5)
    %28 = llvm.and %15, %4 : i32 loc(#loc5)
    %29 = llvm.icmp "eq" %28, %6 : i32 loc(#loc5)
    %30 = llvm.select %29, %6, %2 : i1, i32 loc(#loc5)
    %31 = llvm.xor %27, %30 : i32 loc(#loc5)
    %32 = llvm.xor %31, %6 : i32 loc(#loc5)
    %33 = llvm.xor %31, %1 : i32 loc(#loc5)
    %34 = llvm.add %32, %7 : i32 loc(#loc5)
    %35 = llvm.add %33, %7 : i32 loc(#loc5)
    %36 = llvm.and %14, %5 : i32 loc(#loc5)
    %37 = llvm.icmp "eq" %36, %6 : i32 loc(#loc5)
    %38 = llvm.select %37, %6, %3 : i1, i32 loc(#loc5)
    %39 = llvm.xor %6, %38 : i32 loc(#loc5)
    %40 = llvm.and %14, %4 : i32 loc(#loc5)
    %41 = llvm.icmp "eq" %40, %6 : i32 loc(#loc5)
    %42 = llvm.select %41, %6, %2 : i1, i32 loc(#loc5)
    %43 = llvm.xor %39, %42 : i32 loc(#loc5)
    %44 = llvm.and %14, %3 : i32 loc(#loc5)
    %45 = llvm.icmp "eq" %44, %6 : i32 loc(#loc5)
    %46 = llvm.select %45, %6, %1 : i1, i32 loc(#loc5)
    %47 = llvm.xor %43, %46 : i32 loc(#loc5)
    %48 = llvm.xor %47, %6 : i32 loc(#loc5)
    %49 = llvm.add %48, %7 : i32 loc(#loc5)
    %50 = llvm.add %12, %34 : i32 loc(#loc6)
    %51 = llvm.add %12, %35 : i32 loc(#loc6)
    %52 = llvm.srem %50, %arg3 : i32 loc(#loc7)
    %53 = llvm.srem %51, %arg3 : i32 loc(#loc7)
    %54 = llvm.mul %11, %8 : i32 loc(#loc8)
    %55 = llvm.add %54, %49 : i32 loc(#loc9)
    %56 = llvm.srem %55, %arg4 : i32 loc(#loc10)
    %57 = llvm.mul %52, %arg5 : i32 loc(#loc11)
    %58 = llvm.mul %53, %arg5 : i32 loc(#loc11)
    %59 = llvm.add %57, %56 : i32 loc(#loc12)
    %60 = llvm.add %58, %56 : i32 loc(#loc12)
    %61 = llvm.getelementptr %arg0[%59] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc13)
    %62 = llvm.getelementptr %arg0[%60] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc13)
    %63 = llvm.mul %52, %arg6 : i32 loc(#loc14)
    %64 = llvm.mul %53, %arg6 : i32 loc(#loc14)
    %65 = llvm.add %63, %56 : i32 loc(#loc15)
    %66 = llvm.add %64, %56 : i32 loc(#loc15)
    %67 = llvm.getelementptr %arg1[%65] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc16)
    %68 = llvm.getelementptr %arg1[%66] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc16)
    %69 = llvm.mul %52, %arg7 : i32 loc(#loc17)
    %70 = llvm.mul %53, %arg7 : i32 loc(#loc17)
    %71 = llvm.add %69, %56 : i32 loc(#loc18)
    %72 = llvm.add %70, %56 : i32 loc(#loc18)
    %73 = llvm.getelementptr %arg2[%71] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc19)
    %74 = llvm.getelementptr %arg2[%72] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc19)
    %75 = llvm.icmp "slt" %52, %arg3 : i32 loc(#loc20)
    %76 = llvm.icmp "slt" %53, %arg3 : i32 loc(#loc20)
    %77 = llvm.icmp "slt" %56, %arg4 : i32 loc(#loc21)
    %78 = llvm.and %75, %77 : i1 loc(#loc22)
    %79 = llvm.and %76, %77 : i1 loc(#loc22)
    %80 = llvm.insertelement %9, %0[%7 : i32] : vector<1xf32> loc(#loc23)
    %81 = llvm.bitcast %80 : vector<1xf32> to i32 loc(#loc23)
    %82 = llvm.inline_asm has_side_effects asm_dialect = att operand_attrs = [] "mov.u32 $0, $4;\0A\09mov.u32 $1, $5;\0A\09mov.u32 $2, $6;\0A\09mov.u32 $3, $7;\0A\09@$9 ld.global.v4.b32 { $0, $1, $2, $3 }, [ $8 + 0 ];", "=r,=r,=r,=r,r,r,r,r,l,b" %81, %81, %81, %81, %61, %78 : (i32, i32, i32, i32, !llvm.ptr<1>, i1) -> !llvm.struct<(i32, i32, i32, i32)> loc(#loc23)
    %83 = llvm.extractvalue %82[0] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc23)
    %84 = llvm.bitcast %83 : i32 to vector<1xf32> loc(#loc23)
    %85 = llvm.extractvalue %82[1] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc23)
    %86 = llvm.bitcast %85 : i32 to vector<1xf32> loc(#loc23)
    %87 = llvm.extractvalue %82[2] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc23)
    %88 = llvm.bitcast %87 : i32 to vector<1xf32> loc(#loc23)
    %89 = llvm.extractvalue %82[3] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc23)
    %90 = llvm.bitcast %89 : i32 to vector<1xf32> loc(#loc23)
    %91 = llvm.extractelement %84[%7 : i32] : vector<1xf32> loc(#loc23)
    %92 = llvm.extractelement %86[%7 : i32] : vector<1xf32> loc(#loc23)
    %93 = llvm.extractelement %88[%7 : i32] : vector<1xf32> loc(#loc23)
    %94 = llvm.extractelement %90[%7 : i32] : vector<1xf32> loc(#loc23)
    %95 = llvm.inline_asm has_side_effects asm_dialect = att operand_attrs = [] "mov.u32 $0, $4;\0A\09mov.u32 $1, $5;\0A\09mov.u32 $2, $6;\0A\09mov.u32 $3, $7;\0A\09@$9 ld.global.v4.b32 { $0, $1, $2, $3 }, [ $8 + 0 ];", "=r,=r,=r,=r,r,r,r,r,l,b" %81, %81, %81, %81, %62, %79 : (i32, i32, i32, i32, !llvm.ptr<1>, i1) -> !llvm.struct<(i32, i32, i32, i32)> loc(#loc23)
    %96 = llvm.extractvalue %95[0] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc23)
    %97 = llvm.bitcast %96 : i32 to vector<1xf32> loc(#loc23)
    %98 = llvm.extractvalue %95[1] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc23)
    %99 = llvm.bitcast %98 : i32 to vector<1xf32> loc(#loc23)
    %100 = llvm.extractvalue %95[2] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc23)
    %101 = llvm.bitcast %100 : i32 to vector<1xf32> loc(#loc23)
    %102 = llvm.extractvalue %95[3] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc23)
    %103 = llvm.bitcast %102 : i32 to vector<1xf32> loc(#loc23)
    %104 = llvm.extractelement %97[%7 : i32] : vector<1xf32> loc(#loc23)
    %105 = llvm.extractelement %99[%7 : i32] : vector<1xf32> loc(#loc23)
    %106 = llvm.extractelement %101[%7 : i32] : vector<1xf32> loc(#loc23)
    %107 = llvm.extractelement %103[%7 : i32] : vector<1xf32> loc(#loc23)
    %108 = llvm.inline_asm has_side_effects asm_dialect = att operand_attrs = [] "mov.u32 $0, $4;\0A\09mov.u32 $1, $5;\0A\09mov.u32 $2, $6;\0A\09mov.u32 $3, $7;\0A\09@$9 ld.global.v4.b32 { $0, $1, $2, $3 }, [ $8 + 0 ];", "=r,=r,=r,=r,r,r,r,r,l,b" %81, %81, %81, %81, %67, %78 : (i32, i32, i32, i32, !llvm.ptr<1>, i1) -> !llvm.struct<(i32, i32, i32, i32)> loc(#loc24)
    %109 = llvm.extractvalue %108[0] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc24)
    %110 = llvm.bitcast %109 : i32 to vector<1xf32> loc(#loc24)
    %111 = llvm.extractvalue %108[1] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc24)
    %112 = llvm.bitcast %111 : i32 to vector<1xf32> loc(#loc24)
    %113 = llvm.extractvalue %108[2] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc24)
    %114 = llvm.bitcast %113 : i32 to vector<1xf32> loc(#loc24)
    %115 = llvm.extractvalue %108[3] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc24)
    %116 = llvm.bitcast %115 : i32 to vector<1xf32> loc(#loc24)
    %117 = llvm.extractelement %110[%7 : i32] : vector<1xf32> loc(#loc24)
    %118 = llvm.extractelement %112[%7 : i32] : vector<1xf32> loc(#loc24)
    %119 = llvm.extractelement %114[%7 : i32] : vector<1xf32> loc(#loc24)
    %120 = llvm.extractelement %116[%7 : i32] : vector<1xf32> loc(#loc24)
    %121 = llvm.inline_asm has_side_effects asm_dialect = att operand_attrs = [] "mov.u32 $0, $4;\0A\09mov.u32 $1, $5;\0A\09mov.u32 $2, $6;\0A\09mov.u32 $3, $7;\0A\09@$9 ld.global.v4.b32 { $0, $1, $2, $3 }, [ $8 + 0 ];", "=r,=r,=r,=r,r,r,r,r,l,b" %81, %81, %81, %81, %68, %79 : (i32, i32, i32, i32, !llvm.ptr<1>, i1) -> !llvm.struct<(i32, i32, i32, i32)> loc(#loc24)
    %122 = llvm.extractvalue %121[0] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc24)
    %123 = llvm.bitcast %122 : i32 to vector<1xf32> loc(#loc24)
    %124 = llvm.extractvalue %121[1] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc24)
    %125 = llvm.bitcast %124 : i32 to vector<1xf32> loc(#loc24)
    %126 = llvm.extractvalue %121[2] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc24)
    %127 = llvm.bitcast %126 : i32 to vector<1xf32> loc(#loc24)
    %128 = llvm.extractvalue %121[3] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc24)
    %129 = llvm.bitcast %128 : i32 to vector<1xf32> loc(#loc24)
    %130 = llvm.extractelement %123[%7 : i32] : vector<1xf32> loc(#loc24)
    %131 = llvm.extractelement %125[%7 : i32] : vector<1xf32> loc(#loc24)
    %132 = llvm.extractelement %127[%7 : i32] : vector<1xf32> loc(#loc24)
    %133 = llvm.extractelement %129[%7 : i32] : vector<1xf32> loc(#loc24)
    %134 = llvm.fadd %91, %117 : f32 loc(#loc25)
    %135 = llvm.fadd %92, %118 : f32 loc(#loc25)
    %136 = llvm.fadd %93, %119 : f32 loc(#loc25)
    %137 = llvm.fadd %94, %120 : f32 loc(#loc25)
    %138 = llvm.fadd %104, %130 : f32 loc(#loc25)
    %139 = llvm.fadd %105, %131 : f32 loc(#loc25)
    %140 = llvm.fadd %106, %132 : f32 loc(#loc25)
    %141 = llvm.fadd %107, %133 : f32 loc(#loc25)
    %142 = llvm.insertelement %134, %0[%6 : i32] : vector<1xf32> loc(#loc26)
    %143 = llvm.bitcast %142 : vector<1xf32> to i32 loc(#loc26)
    %144 = llvm.insertelement %135, %0[%6 : i32] : vector<1xf32> loc(#loc26)
    %145 = llvm.bitcast %144 : vector<1xf32> to i32 loc(#loc26)
    %146 = llvm.insertelement %136, %0[%6 : i32] : vector<1xf32> loc(#loc26)
    %147 = llvm.bitcast %146 : vector<1xf32> to i32 loc(#loc26)
    %148 = llvm.insertelement %137, %0[%6 : i32] : vector<1xf32> loc(#loc26)
    %149 = llvm.bitcast %148 : vector<1xf32> to i32 loc(#loc26)
    %150 = llvm.inline_asm has_side_effects asm_dialect = att operand_attrs = [] "@$5 st.global.v4.b32 [ $4 + 0 ], { $0, $1, $2, $3 };", "r,r,r,r,l,b" %143, %145, %147, %149, %73, %78 : (i32, i32, i32, i32, !llvm.ptr<1>, i1) -> !llvm.void loc(#loc26)
    %151 = llvm.insertelement %138, %0[%6 : i32] : vector<1xf32> loc(#loc26)
    %152 = llvm.bitcast %151 : vector<1xf32> to i32 loc(#loc26)
    %153 = llvm.insertelement %139, %0[%6 : i32] : vector<1xf32> loc(#loc26)
    %154 = llvm.bitcast %153 : vector<1xf32> to i32 loc(#loc26)
    %155 = llvm.insertelement %140, %0[%6 : i32] : vector<1xf32> loc(#loc26)
    %156 = llvm.bitcast %155 : vector<1xf32> to i32 loc(#loc26)
    %157 = llvm.insertelement %141, %0[%6 : i32] : vector<1xf32> loc(#loc26)
    %158 = llvm.bitcast %157 : vector<1xf32> to i32 loc(#loc26)
    %159 = llvm.inline_asm has_side_effects asm_dialect = att operand_attrs = [] "@$5 st.global.v4.b32 [ $4 + 0 ], { $0, $1, $2, $3 };", "r,r,r,r,l,b" %152, %154, %156, %158, %74, %79 : (i32, i32, i32, i32, !llvm.ptr<1>, i1) -> !llvm.void loc(#loc26)
    llvm.return loc(#loc27)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("examples/kernels/binary_ops.py":106:26)
#loc3 = loc("examples/kernels/binary_ops.py":107:26)
#loc4 = loc("examples/kernels/binary_ops.py":108:22)
#loc5 = loc("examples/kernels/binary_ops.py":108:50)
#loc6 = loc("examples/kernels/binary_ops.py":108:37)
#loc7 = loc("examples/kernels/binary_ops.py":108:67)
#loc8 = loc("examples/kernels/binary_ops.py":109:22)
#loc9 = loc("examples/kernels/binary_ops.py":109:37)
#loc10 = loc("examples/kernels/binary_ops.py":109:67)
#loc11 = loc("examples/kernels/binary_ops.py":110:40)
#loc12 = loc("examples/kernels/binary_ops.py":110:52)
#loc13 = loc("examples/kernels/binary_ops.py":110:22)
#loc14 = loc("examples/kernels/binary_ops.py":111:40)
#loc15 = loc("examples/kernels/binary_ops.py":111:52)
#loc16 = loc("examples/kernels/binary_ops.py":111:22)
#loc17 = loc("examples/kernels/binary_ops.py":112:40)
#loc18 = loc("examples/kernels/binary_ops.py":112:52)
#loc19 = loc("examples/kernels/binary_ops.py":112:22)
#loc20 = loc("examples/kernels/binary_ops.py":114:31)
#loc21 = loc("examples/kernels/binary_ops.py":114:55)
#loc22 = loc("examples/kernels/binary_ops.py":114:37)
#loc23 = loc("examples/kernels/binary_ops.py":116:16)
#loc24 = loc("examples/kernels/binary_ops.py":117:16)
#loc25 = loc("examples/kernels/binary_ops.py":118:12)
#loc26 = loc("examples/kernels/binary_ops.py":119:21)
#loc27 = loc("examples/kernels/binary_ops.py":119:4)


// -----// IR Dump Before Canonicalizer (canonicalize) ('builtin.module' operation) //----- //
#loc = loc("examples/kernels/binary_ops.py":97:0)
module attributes {ttg.global_scratch_memory_alignment = 1 : i32, ttg.global_scratch_memory_size = 0 : i32, "ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.shared = 0 : i32, ttg.target = "cuda:89", ttg.tensor_memory_size = 0 : i32, "ttg.threads-per-warp" = 32 : i32, "ttg.total-num-warps" = 4 : i32} {
  llvm.mlir.global external @global_smem() {addr_space = 3 : i32, alignment = 16 : i64} : !llvm.array<0 x i8> loc(#loc)
  llvm.func @add_2d_kernel(%arg0: !llvm.ptr<1> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg1: !llvm.ptr<1> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg2: !llvm.ptr<1> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg3: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg4: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg5: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg6: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg7: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg8: !llvm.ptr<1> loc("examples/kernels/binary_ops.py":97:0)) attributes {noinline = false, nvvm.kernel = 1 : ui1, nvvm.reqntid = array<i32: 128>, ttg.global_scratch_memory_alignment = 1 : i32, ttg.global_scratch_memory_size = 0 : i32} {
    %0 = llvm.mlir.undef : vector<1xf32> loc(#loc1)
    %1 = llvm.mlir.constant(16 : i32) : i32 loc(#loc1)
    %2 = llvm.mlir.constant(8 : i32) : i32 loc(#loc1)
    %3 = llvm.mlir.constant(4 : i32) : i32 loc(#loc1)
    %4 = llvm.mlir.constant(2 : i32) : i32 loc(#loc1)
    %5 = llvm.mlir.constant(1 : i32) : i32 loc(#loc1)
    %6 = llvm.mlir.constant(0 : i32) : i32 loc(#loc1)
    %7 = llvm.mlir.constant(0 : index) : i32 loc(#loc1)
    %8 = llvm.mlir.constant(32 : i32) : i32 loc(#loc1)
    %9 = llvm.mlir.constant(0.000000e+00 : f32) : f32 loc(#loc1)
    %10 = llvm.call_intrinsic "llvm.nvvm.read.ptx.sreg.ctaid.x"() : () -> i32 loc(#loc2)
    %11 = llvm.call_intrinsic "llvm.nvvm.read.ptx.sreg.ctaid.y"() : () -> i32 loc(#loc3)
    %12 = llvm.mul %10, %8 : i32 loc(#loc4)
    %13 = nvvm.read.ptx.sreg.tid.x : i32 loc(#loc5)
    %14 = llvm.urem %13, %8 : i32 loc(#loc5)
    %15 = llvm.udiv %13, %8 : i32 loc(#loc5)
    %16 = llvm.and %14, %2 : i32 loc(#loc5)
    %17 = llvm.icmp "eq" %16, %6 : i32 loc(#loc5)
    %18 = llvm.select %17, %6, %5 : i1, i32 loc(#loc5)
    %19 = llvm.xor %6, %18 : i32 loc(#loc5)
    %20 = llvm.and %14, %1 : i32 loc(#loc5)
    %21 = llvm.icmp "eq" %20, %6 : i32 loc(#loc5)
    %22 = llvm.select %21, %6, %4 : i1, i32 loc(#loc5)
    %23 = llvm.xor %19, %22 : i32 loc(#loc5)
    %24 = llvm.and %15, %5 : i32 loc(#loc5)
    %25 = llvm.icmp "eq" %24, %6 : i32 loc(#loc5)
    %26 = llvm.select %25, %6, %3 : i1, i32 loc(#loc5)
    %27 = llvm.xor %23, %26 : i32 loc(#loc5)
    %28 = llvm.and %15, %4 : i32 loc(#loc5)
    %29 = llvm.icmp "eq" %28, %6 : i32 loc(#loc5)
    %30 = llvm.select %29, %6, %2 : i1, i32 loc(#loc5)
    %31 = llvm.xor %27, %30 : i32 loc(#loc5)
    %32 = llvm.xor %31, %6 : i32 loc(#loc5)
    %33 = llvm.xor %31, %1 : i32 loc(#loc5)
    %34 = llvm.add %32, %7 : i32 loc(#loc5)
    %35 = llvm.add %33, %7 : i32 loc(#loc5)
    %36 = llvm.and %14, %5 : i32 loc(#loc5)
    %37 = llvm.icmp "eq" %36, %6 : i32 loc(#loc5)
    %38 = llvm.select %37, %6, %3 : i1, i32 loc(#loc5)
    %39 = llvm.xor %6, %38 : i32 loc(#loc5)
    %40 = llvm.and %14, %4 : i32 loc(#loc5)
    %41 = llvm.icmp "eq" %40, %6 : i32 loc(#loc5)
    %42 = llvm.select %41, %6, %2 : i1, i32 loc(#loc5)
    %43 = llvm.xor %39, %42 : i32 loc(#loc5)
    %44 = llvm.and %14, %3 : i32 loc(#loc5)
    %45 = llvm.icmp "eq" %44, %6 : i32 loc(#loc5)
    %46 = llvm.select %45, %6, %1 : i1, i32 loc(#loc5)
    %47 = llvm.xor %43, %46 : i32 loc(#loc5)
    %48 = llvm.xor %47, %6 : i32 loc(#loc5)
    %49 = llvm.add %48, %7 : i32 loc(#loc5)
    %50 = llvm.add %12, %34 : i32 loc(#loc6)
    %51 = llvm.add %12, %35 : i32 loc(#loc6)
    %52 = llvm.srem %50, %arg3 : i32 loc(#loc7)
    %53 = llvm.srem %51, %arg3 : i32 loc(#loc7)
    %54 = llvm.mul %11, %8 : i32 loc(#loc8)
    %55 = llvm.add %54, %49 : i32 loc(#loc9)
    %56 = llvm.srem %55, %arg4 : i32 loc(#loc10)
    %57 = llvm.mul %52, %arg5 : i32 loc(#loc11)
    %58 = llvm.mul %53, %arg5 : i32 loc(#loc11)
    %59 = llvm.add %57, %56 : i32 loc(#loc12)
    %60 = llvm.add %58, %56 : i32 loc(#loc12)
    %61 = llvm.getelementptr %arg0[%59] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc13)
    %62 = llvm.getelementptr %arg0[%60] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc13)
    %63 = llvm.mul %52, %arg6 : i32 loc(#loc14)
    %64 = llvm.mul %53, %arg6 : i32 loc(#loc14)
    %65 = llvm.add %63, %56 : i32 loc(#loc15)
    %66 = llvm.add %64, %56 : i32 loc(#loc15)
    %67 = llvm.getelementptr %arg1[%65] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc16)
    %68 = llvm.getelementptr %arg1[%66] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc16)
    %69 = llvm.mul %52, %arg7 : i32 loc(#loc17)
    %70 = llvm.mul %53, %arg7 : i32 loc(#loc17)
    %71 = llvm.add %69, %56 : i32 loc(#loc18)
    %72 = llvm.add %70, %56 : i32 loc(#loc18)
    %73 = llvm.getelementptr %arg2[%71] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc19)
    %74 = llvm.getelementptr %arg2[%72] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc19)
    %75 = llvm.icmp "slt" %52, %arg3 : i32 loc(#loc20)
    %76 = llvm.icmp "slt" %53, %arg3 : i32 loc(#loc20)
    %77 = llvm.icmp "slt" %56, %arg4 : i32 loc(#loc21)
    %78 = llvm.and %75, %77 : i1 loc(#loc22)
    %79 = llvm.and %76, %77 : i1 loc(#loc22)
    %80 = llvm.insertelement %9, %0[%7 : i32] : vector<1xf32> loc(#loc23)
    %81 = llvm.bitcast %80 : vector<1xf32> to i32 loc(#loc23)
    %82 = llvm.inline_asm has_side_effects asm_dialect = att operand_attrs = [] "mov.u32 $0, $4;\0A\09mov.u32 $1, $5;\0A\09mov.u32 $2, $6;\0A\09mov.u32 $3, $7;\0A\09@$9 ld.global.v4.b32 { $0, $1, $2, $3 }, [ $8 + 0 ];", "=r,=r,=r,=r,r,r,r,r,l,b" %81, %81, %81, %81, %61, %78 : (i32, i32, i32, i32, !llvm.ptr<1>, i1) -> !llvm.struct<(i32, i32, i32, i32)> loc(#loc23)
    %83 = llvm.extractvalue %82[0] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc23)
    %84 = llvm.bitcast %83 : i32 to vector<1xf32> loc(#loc23)
    %85 = llvm.extractvalue %82[1] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc23)
    %86 = llvm.bitcast %85 : i32 to vector<1xf32> loc(#loc23)
    %87 = llvm.extractvalue %82[2] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc23)
    %88 = llvm.bitcast %87 : i32 to vector<1xf32> loc(#loc23)
    %89 = llvm.extractvalue %82[3] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc23)
    %90 = llvm.bitcast %89 : i32 to vector<1xf32> loc(#loc23)
    %91 = llvm.extractelement %84[%7 : i32] : vector<1xf32> loc(#loc23)
    %92 = llvm.extractelement %86[%7 : i32] : vector<1xf32> loc(#loc23)
    %93 = llvm.extractelement %88[%7 : i32] : vector<1xf32> loc(#loc23)
    %94 = llvm.extractelement %90[%7 : i32] : vector<1xf32> loc(#loc23)
    %95 = llvm.inline_asm has_side_effects asm_dialect = att operand_attrs = [] "mov.u32 $0, $4;\0A\09mov.u32 $1, $5;\0A\09mov.u32 $2, $6;\0A\09mov.u32 $3, $7;\0A\09@$9 ld.global.v4.b32 { $0, $1, $2, $3 }, [ $8 + 0 ];", "=r,=r,=r,=r,r,r,r,r,l,b" %81, %81, %81, %81, %62, %79 : (i32, i32, i32, i32, !llvm.ptr<1>, i1) -> !llvm.struct<(i32, i32, i32, i32)> loc(#loc23)
    %96 = llvm.extractvalue %95[0] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc23)
    %97 = llvm.bitcast %96 : i32 to vector<1xf32> loc(#loc23)
    %98 = llvm.extractvalue %95[1] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc23)
    %99 = llvm.bitcast %98 : i32 to vector<1xf32> loc(#loc23)
    %100 = llvm.extractvalue %95[2] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc23)
    %101 = llvm.bitcast %100 : i32 to vector<1xf32> loc(#loc23)
    %102 = llvm.extractvalue %95[3] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc23)
    %103 = llvm.bitcast %102 : i32 to vector<1xf32> loc(#loc23)
    %104 = llvm.extractelement %97[%7 : i32] : vector<1xf32> loc(#loc23)
    %105 = llvm.extractelement %99[%7 : i32] : vector<1xf32> loc(#loc23)
    %106 = llvm.extractelement %101[%7 : i32] : vector<1xf32> loc(#loc23)
    %107 = llvm.extractelement %103[%7 : i32] : vector<1xf32> loc(#loc23)
    %108 = llvm.inline_asm has_side_effects asm_dialect = att operand_attrs = [] "mov.u32 $0, $4;\0A\09mov.u32 $1, $5;\0A\09mov.u32 $2, $6;\0A\09mov.u32 $3, $7;\0A\09@$9 ld.global.v4.b32 { $0, $1, $2, $3 }, [ $8 + 0 ];", "=r,=r,=r,=r,r,r,r,r,l,b" %81, %81, %81, %81, %67, %78 : (i32, i32, i32, i32, !llvm.ptr<1>, i1) -> !llvm.struct<(i32, i32, i32, i32)> loc(#loc24)
    %109 = llvm.extractvalue %108[0] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc24)
    %110 = llvm.bitcast %109 : i32 to vector<1xf32> loc(#loc24)
    %111 = llvm.extractvalue %108[1] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc24)
    %112 = llvm.bitcast %111 : i32 to vector<1xf32> loc(#loc24)
    %113 = llvm.extractvalue %108[2] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc24)
    %114 = llvm.bitcast %113 : i32 to vector<1xf32> loc(#loc24)
    %115 = llvm.extractvalue %108[3] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc24)
    %116 = llvm.bitcast %115 : i32 to vector<1xf32> loc(#loc24)
    %117 = llvm.extractelement %110[%7 : i32] : vector<1xf32> loc(#loc24)
    %118 = llvm.extractelement %112[%7 : i32] : vector<1xf32> loc(#loc24)
    %119 = llvm.extractelement %114[%7 : i32] : vector<1xf32> loc(#loc24)
    %120 = llvm.extractelement %116[%7 : i32] : vector<1xf32> loc(#loc24)
    %121 = llvm.inline_asm has_side_effects asm_dialect = att operand_attrs = [] "mov.u32 $0, $4;\0A\09mov.u32 $1, $5;\0A\09mov.u32 $2, $6;\0A\09mov.u32 $3, $7;\0A\09@$9 ld.global.v4.b32 { $0, $1, $2, $3 }, [ $8 + 0 ];", "=r,=r,=r,=r,r,r,r,r,l,b" %81, %81, %81, %81, %68, %79 : (i32, i32, i32, i32, !llvm.ptr<1>, i1) -> !llvm.struct<(i32, i32, i32, i32)> loc(#loc24)
    %122 = llvm.extractvalue %121[0] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc24)
    %123 = llvm.bitcast %122 : i32 to vector<1xf32> loc(#loc24)
    %124 = llvm.extractvalue %121[1] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc24)
    %125 = llvm.bitcast %124 : i32 to vector<1xf32> loc(#loc24)
    %126 = llvm.extractvalue %121[2] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc24)
    %127 = llvm.bitcast %126 : i32 to vector<1xf32> loc(#loc24)
    %128 = llvm.extractvalue %121[3] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc24)
    %129 = llvm.bitcast %128 : i32 to vector<1xf32> loc(#loc24)
    %130 = llvm.extractelement %123[%7 : i32] : vector<1xf32> loc(#loc24)
    %131 = llvm.extractelement %125[%7 : i32] : vector<1xf32> loc(#loc24)
    %132 = llvm.extractelement %127[%7 : i32] : vector<1xf32> loc(#loc24)
    %133 = llvm.extractelement %129[%7 : i32] : vector<1xf32> loc(#loc24)
    %134 = llvm.fadd %91, %117 : f32 loc(#loc25)
    %135 = llvm.fadd %92, %118 : f32 loc(#loc25)
    %136 = llvm.fadd %93, %119 : f32 loc(#loc25)
    %137 = llvm.fadd %94, %120 : f32 loc(#loc25)
    %138 = llvm.fadd %104, %130 : f32 loc(#loc25)
    %139 = llvm.fadd %105, %131 : f32 loc(#loc25)
    %140 = llvm.fadd %106, %132 : f32 loc(#loc25)
    %141 = llvm.fadd %107, %133 : f32 loc(#loc25)
    %142 = llvm.insertelement %134, %0[%6 : i32] : vector<1xf32> loc(#loc26)
    %143 = llvm.bitcast %142 : vector<1xf32> to i32 loc(#loc26)
    %144 = llvm.insertelement %135, %0[%6 : i32] : vector<1xf32> loc(#loc26)
    %145 = llvm.bitcast %144 : vector<1xf32> to i32 loc(#loc26)
    %146 = llvm.insertelement %136, %0[%6 : i32] : vector<1xf32> loc(#loc26)
    %147 = llvm.bitcast %146 : vector<1xf32> to i32 loc(#loc26)
    %148 = llvm.insertelement %137, %0[%6 : i32] : vector<1xf32> loc(#loc26)
    %149 = llvm.bitcast %148 : vector<1xf32> to i32 loc(#loc26)
    %150 = llvm.inline_asm has_side_effects asm_dialect = att operand_attrs = [] "@$5 st.global.v4.b32 [ $4 + 0 ], { $0, $1, $2, $3 };", "r,r,r,r,l,b" %143, %145, %147, %149, %73, %78 : (i32, i32, i32, i32, !llvm.ptr<1>, i1) -> !llvm.void loc(#loc26)
    %151 = llvm.insertelement %138, %0[%6 : i32] : vector<1xf32> loc(#loc26)
    %152 = llvm.bitcast %151 : vector<1xf32> to i32 loc(#loc26)
    %153 = llvm.insertelement %139, %0[%6 : i32] : vector<1xf32> loc(#loc26)
    %154 = llvm.bitcast %153 : vector<1xf32> to i32 loc(#loc26)
    %155 = llvm.insertelement %140, %0[%6 : i32] : vector<1xf32> loc(#loc26)
    %156 = llvm.bitcast %155 : vector<1xf32> to i32 loc(#loc26)
    %157 = llvm.insertelement %141, %0[%6 : i32] : vector<1xf32> loc(#loc26)
    %158 = llvm.bitcast %157 : vector<1xf32> to i32 loc(#loc26)
    %159 = llvm.inline_asm has_side_effects asm_dialect = att operand_attrs = [] "@$5 st.global.v4.b32 [ $4 + 0 ], { $0, $1, $2, $3 };", "r,r,r,r,l,b" %152, %154, %156, %158, %74, %79 : (i32, i32, i32, i32, !llvm.ptr<1>, i1) -> !llvm.void loc(#loc26)
    llvm.return loc(#loc27)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("examples/kernels/binary_ops.py":106:26)
#loc3 = loc("examples/kernels/binary_ops.py":107:26)
#loc4 = loc("examples/kernels/binary_ops.py":108:22)
#loc5 = loc("examples/kernels/binary_ops.py":108:50)
#loc6 = loc("examples/kernels/binary_ops.py":108:37)
#loc7 = loc("examples/kernels/binary_ops.py":108:67)
#loc8 = loc("examples/kernels/binary_ops.py":109:22)
#loc9 = loc("examples/kernels/binary_ops.py":109:37)
#loc10 = loc("examples/kernels/binary_ops.py":109:67)
#loc11 = loc("examples/kernels/binary_ops.py":110:40)
#loc12 = loc("examples/kernels/binary_ops.py":110:52)
#loc13 = loc("examples/kernels/binary_ops.py":110:22)
#loc14 = loc("examples/kernels/binary_ops.py":111:40)
#loc15 = loc("examples/kernels/binary_ops.py":111:52)
#loc16 = loc("examples/kernels/binary_ops.py":111:22)
#loc17 = loc("examples/kernels/binary_ops.py":112:40)
#loc18 = loc("examples/kernels/binary_ops.py":112:52)
#loc19 = loc("examples/kernels/binary_ops.py":112:22)
#loc20 = loc("examples/kernels/binary_ops.py":114:31)
#loc21 = loc("examples/kernels/binary_ops.py":114:55)
#loc22 = loc("examples/kernels/binary_ops.py":114:37)
#loc23 = loc("examples/kernels/binary_ops.py":116:16)
#loc24 = loc("examples/kernels/binary_ops.py":117:16)
#loc25 = loc("examples/kernels/binary_ops.py":118:12)
#loc26 = loc("examples/kernels/binary_ops.py":119:21)
#loc27 = loc("examples/kernels/binary_ops.py":119:4)


// -----// IR Dump Before CSE (cse) ('builtin.module' operation) //----- //
#loc = loc("examples/kernels/binary_ops.py":97:0)
module attributes {ttg.global_scratch_memory_alignment = 1 : i32, ttg.global_scratch_memory_size = 0 : i32, "ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.shared = 0 : i32, ttg.target = "cuda:89", ttg.tensor_memory_size = 0 : i32, "ttg.threads-per-warp" = 32 : i32, "ttg.total-num-warps" = 4 : i32} {
  llvm.mlir.global external @global_smem() {addr_space = 3 : i32, alignment = 16 : i64} : !llvm.array<0 x i8> loc(#loc)
  llvm.func @add_2d_kernel(%arg0: !llvm.ptr<1> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg1: !llvm.ptr<1> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg2: !llvm.ptr<1> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg3: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg4: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg5: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg6: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg7: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg8: !llvm.ptr<1> loc("examples/kernels/binary_ops.py":97:0)) attributes {noinline = false, nvvm.kernel = 1 : ui1, nvvm.reqntid = array<i32: 128>, ttg.global_scratch_memory_alignment = 1 : i32, ttg.global_scratch_memory_size = 0 : i32} {
    %0 = llvm.mlir.undef : vector<1xf32> loc(#loc1)
    %1 = llvm.mlir.constant(16 : i32) : i32 loc(#loc1)
    %2 = llvm.mlir.constant(8 : i32) : i32 loc(#loc1)
    %3 = llvm.mlir.constant(4 : i32) : i32 loc(#loc1)
    %4 = llvm.mlir.constant(2 : i32) : i32 loc(#loc1)
    %5 = llvm.mlir.constant(1 : i32) : i32 loc(#loc1)
    %6 = llvm.mlir.constant(0 : i32) : i32 loc(#loc1)
    %7 = llvm.mlir.constant(0 : index) : i32 loc(#loc1)
    %8 = llvm.mlir.constant(32 : i32) : i32 loc(#loc1)
    %9 = llvm.mlir.constant(0.000000e+00 : f32) : f32 loc(#loc1)
    %10 = llvm.call_intrinsic "llvm.nvvm.read.ptx.sreg.ctaid.x"() : () -> i32 loc(#loc2)
    %11 = llvm.call_intrinsic "llvm.nvvm.read.ptx.sreg.ctaid.y"() : () -> i32 loc(#loc3)
    %12 = llvm.mul %10, %8 : i32 loc(#loc4)
    %13 = nvvm.read.ptx.sreg.tid.x : i32 loc(#loc5)
    %14 = llvm.urem %13, %8 : i32 loc(#loc5)
    %15 = llvm.udiv %13, %8 : i32 loc(#loc5)
    %16 = llvm.and %14, %2 : i32 loc(#loc5)
    %17 = llvm.icmp "eq" %16, %6 : i32 loc(#loc5)
    %18 = llvm.select %17, %6, %5 : i1, i32 loc(#loc5)
    %19 = llvm.xor %6, %18 : i32 loc(#loc5)
    %20 = llvm.and %14, %1 : i32 loc(#loc5)
    %21 = llvm.icmp "eq" %20, %6 : i32 loc(#loc5)
    %22 = llvm.select %21, %6, %4 : i1, i32 loc(#loc5)
    %23 = llvm.xor %19, %22 : i32 loc(#loc5)
    %24 = llvm.and %15, %5 : i32 loc(#loc5)
    %25 = llvm.icmp "eq" %24, %6 : i32 loc(#loc5)
    %26 = llvm.select %25, %6, %3 : i1, i32 loc(#loc5)
    %27 = llvm.xor %23, %26 : i32 loc(#loc5)
    %28 = llvm.and %15, %4 : i32 loc(#loc5)
    %29 = llvm.icmp "eq" %28, %6 : i32 loc(#loc5)
    %30 = llvm.select %29, %6, %2 : i1, i32 loc(#loc5)
    %31 = llvm.xor %27, %30 : i32 loc(#loc5)
    %32 = llvm.xor %31, %6 : i32 loc(#loc5)
    %33 = llvm.xor %31, %1 : i32 loc(#loc5)
    %34 = llvm.add %32, %7 : i32 loc(#loc5)
    %35 = llvm.add %33, %7 : i32 loc(#loc5)
    %36 = llvm.and %14, %5 : i32 loc(#loc5)
    %37 = llvm.icmp "eq" %36, %6 : i32 loc(#loc5)
    %38 = llvm.select %37, %6, %3 : i1, i32 loc(#loc5)
    %39 = llvm.xor %6, %38 : i32 loc(#loc5)
    %40 = llvm.and %14, %4 : i32 loc(#loc5)
    %41 = llvm.icmp "eq" %40, %6 : i32 loc(#loc5)
    %42 = llvm.select %41, %6, %2 : i1, i32 loc(#loc5)
    %43 = llvm.xor %39, %42 : i32 loc(#loc5)
    %44 = llvm.and %14, %3 : i32 loc(#loc5)
    %45 = llvm.icmp "eq" %44, %6 : i32 loc(#loc5)
    %46 = llvm.select %45, %6, %1 : i1, i32 loc(#loc5)
    %47 = llvm.xor %43, %46 : i32 loc(#loc5)
    %48 = llvm.xor %47, %6 : i32 loc(#loc5)
    %49 = llvm.add %48, %7 : i32 loc(#loc5)
    %50 = llvm.add %12, %34 : i32 loc(#loc6)
    %51 = llvm.add %12, %35 : i32 loc(#loc6)
    %52 = llvm.srem %50, %arg3 : i32 loc(#loc7)
    %53 = llvm.srem %51, %arg3 : i32 loc(#loc7)
    %54 = llvm.mul %11, %8 : i32 loc(#loc8)
    %55 = llvm.add %54, %49 : i32 loc(#loc9)
    %56 = llvm.srem %55, %arg4 : i32 loc(#loc10)
    %57 = llvm.mul %52, %arg5 : i32 loc(#loc11)
    %58 = llvm.mul %53, %arg5 : i32 loc(#loc11)
    %59 = llvm.add %57, %56 : i32 loc(#loc12)
    %60 = llvm.add %58, %56 : i32 loc(#loc12)
    %61 = llvm.getelementptr %arg0[%59] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc13)
    %62 = llvm.getelementptr %arg0[%60] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc13)
    %63 = llvm.mul %52, %arg6 : i32 loc(#loc14)
    %64 = llvm.mul %53, %arg6 : i32 loc(#loc14)
    %65 = llvm.add %63, %56 : i32 loc(#loc15)
    %66 = llvm.add %64, %56 : i32 loc(#loc15)
    %67 = llvm.getelementptr %arg1[%65] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc16)
    %68 = llvm.getelementptr %arg1[%66] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc16)
    %69 = llvm.mul %52, %arg7 : i32 loc(#loc17)
    %70 = llvm.mul %53, %arg7 : i32 loc(#loc17)
    %71 = llvm.add %69, %56 : i32 loc(#loc18)
    %72 = llvm.add %70, %56 : i32 loc(#loc18)
    %73 = llvm.getelementptr %arg2[%71] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc19)
    %74 = llvm.getelementptr %arg2[%72] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc19)
    %75 = llvm.icmp "slt" %52, %arg3 : i32 loc(#loc20)
    %76 = llvm.icmp "slt" %53, %arg3 : i32 loc(#loc20)
    %77 = llvm.icmp "slt" %56, %arg4 : i32 loc(#loc21)
    %78 = llvm.and %75, %77 : i1 loc(#loc22)
    %79 = llvm.and %76, %77 : i1 loc(#loc22)
    %80 = llvm.insertelement %9, %0[%7 : i32] : vector<1xf32> loc(#loc23)
    %81 = llvm.bitcast %80 : vector<1xf32> to i32 loc(#loc23)
    %82 = llvm.inline_asm has_side_effects asm_dialect = att operand_attrs = [] "mov.u32 $0, $4;\0A\09mov.u32 $1, $5;\0A\09mov.u32 $2, $6;\0A\09mov.u32 $3, $7;\0A\09@$9 ld.global.v4.b32 { $0, $1, $2, $3 }, [ $8 + 0 ];", "=r,=r,=r,=r,r,r,r,r,l,b" %81, %81, %81, %81, %61, %78 : (i32, i32, i32, i32, !llvm.ptr<1>, i1) -> !llvm.struct<(i32, i32, i32, i32)> loc(#loc23)
    %83 = llvm.extractvalue %82[0] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc23)
    %84 = llvm.bitcast %83 : i32 to vector<1xf32> loc(#loc23)
    %85 = llvm.extractvalue %82[1] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc23)
    %86 = llvm.bitcast %85 : i32 to vector<1xf32> loc(#loc23)
    %87 = llvm.extractvalue %82[2] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc23)
    %88 = llvm.bitcast %87 : i32 to vector<1xf32> loc(#loc23)
    %89 = llvm.extractvalue %82[3] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc23)
    %90 = llvm.bitcast %89 : i32 to vector<1xf32> loc(#loc23)
    %91 = llvm.extractelement %84[%7 : i32] : vector<1xf32> loc(#loc23)
    %92 = llvm.extractelement %86[%7 : i32] : vector<1xf32> loc(#loc23)
    %93 = llvm.extractelement %88[%7 : i32] : vector<1xf32> loc(#loc23)
    %94 = llvm.extractelement %90[%7 : i32] : vector<1xf32> loc(#loc23)
    %95 = llvm.inline_asm has_side_effects asm_dialect = att operand_attrs = [] "mov.u32 $0, $4;\0A\09mov.u32 $1, $5;\0A\09mov.u32 $2, $6;\0A\09mov.u32 $3, $7;\0A\09@$9 ld.global.v4.b32 { $0, $1, $2, $3 }, [ $8 + 0 ];", "=r,=r,=r,=r,r,r,r,r,l,b" %81, %81, %81, %81, %62, %79 : (i32, i32, i32, i32, !llvm.ptr<1>, i1) -> !llvm.struct<(i32, i32, i32, i32)> loc(#loc23)
    %96 = llvm.extractvalue %95[0] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc23)
    %97 = llvm.bitcast %96 : i32 to vector<1xf32> loc(#loc23)
    %98 = llvm.extractvalue %95[1] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc23)
    %99 = llvm.bitcast %98 : i32 to vector<1xf32> loc(#loc23)
    %100 = llvm.extractvalue %95[2] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc23)
    %101 = llvm.bitcast %100 : i32 to vector<1xf32> loc(#loc23)
    %102 = llvm.extractvalue %95[3] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc23)
    %103 = llvm.bitcast %102 : i32 to vector<1xf32> loc(#loc23)
    %104 = llvm.extractelement %97[%7 : i32] : vector<1xf32> loc(#loc23)
    %105 = llvm.extractelement %99[%7 : i32] : vector<1xf32> loc(#loc23)
    %106 = llvm.extractelement %101[%7 : i32] : vector<1xf32> loc(#loc23)
    %107 = llvm.extractelement %103[%7 : i32] : vector<1xf32> loc(#loc23)
    %108 = llvm.inline_asm has_side_effects asm_dialect = att operand_attrs = [] "mov.u32 $0, $4;\0A\09mov.u32 $1, $5;\0A\09mov.u32 $2, $6;\0A\09mov.u32 $3, $7;\0A\09@$9 ld.global.v4.b32 { $0, $1, $2, $3 }, [ $8 + 0 ];", "=r,=r,=r,=r,r,r,r,r,l,b" %81, %81, %81, %81, %67, %78 : (i32, i32, i32, i32, !llvm.ptr<1>, i1) -> !llvm.struct<(i32, i32, i32, i32)> loc(#loc24)
    %109 = llvm.extractvalue %108[0] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc24)
    %110 = llvm.bitcast %109 : i32 to vector<1xf32> loc(#loc24)
    %111 = llvm.extractvalue %108[1] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc24)
    %112 = llvm.bitcast %111 : i32 to vector<1xf32> loc(#loc24)
    %113 = llvm.extractvalue %108[2] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc24)
    %114 = llvm.bitcast %113 : i32 to vector<1xf32> loc(#loc24)
    %115 = llvm.extractvalue %108[3] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc24)
    %116 = llvm.bitcast %115 : i32 to vector<1xf32> loc(#loc24)
    %117 = llvm.extractelement %110[%7 : i32] : vector<1xf32> loc(#loc24)
    %118 = llvm.extractelement %112[%7 : i32] : vector<1xf32> loc(#loc24)
    %119 = llvm.extractelement %114[%7 : i32] : vector<1xf32> loc(#loc24)
    %120 = llvm.extractelement %116[%7 : i32] : vector<1xf32> loc(#loc24)
    %121 = llvm.inline_asm has_side_effects asm_dialect = att operand_attrs = [] "mov.u32 $0, $4;\0A\09mov.u32 $1, $5;\0A\09mov.u32 $2, $6;\0A\09mov.u32 $3, $7;\0A\09@$9 ld.global.v4.b32 { $0, $1, $2, $3 }, [ $8 + 0 ];", "=r,=r,=r,=r,r,r,r,r,l,b" %81, %81, %81, %81, %68, %79 : (i32, i32, i32, i32, !llvm.ptr<1>, i1) -> !llvm.struct<(i32, i32, i32, i32)> loc(#loc24)
    %122 = llvm.extractvalue %121[0] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc24)
    %123 = llvm.bitcast %122 : i32 to vector<1xf32> loc(#loc24)
    %124 = llvm.extractvalue %121[1] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc24)
    %125 = llvm.bitcast %124 : i32 to vector<1xf32> loc(#loc24)
    %126 = llvm.extractvalue %121[2] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc24)
    %127 = llvm.bitcast %126 : i32 to vector<1xf32> loc(#loc24)
    %128 = llvm.extractvalue %121[3] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc24)
    %129 = llvm.bitcast %128 : i32 to vector<1xf32> loc(#loc24)
    %130 = llvm.extractelement %123[%7 : i32] : vector<1xf32> loc(#loc24)
    %131 = llvm.extractelement %125[%7 : i32] : vector<1xf32> loc(#loc24)
    %132 = llvm.extractelement %127[%7 : i32] : vector<1xf32> loc(#loc24)
    %133 = llvm.extractelement %129[%7 : i32] : vector<1xf32> loc(#loc24)
    %134 = llvm.fadd %91, %117 : f32 loc(#loc25)
    %135 = llvm.fadd %92, %118 : f32 loc(#loc25)
    %136 = llvm.fadd %93, %119 : f32 loc(#loc25)
    %137 = llvm.fadd %94, %120 : f32 loc(#loc25)
    %138 = llvm.fadd %104, %130 : f32 loc(#loc25)
    %139 = llvm.fadd %105, %131 : f32 loc(#loc25)
    %140 = llvm.fadd %106, %132 : f32 loc(#loc25)
    %141 = llvm.fadd %107, %133 : f32 loc(#loc25)
    %142 = llvm.insertelement %134, %0[%6 : i32] : vector<1xf32> loc(#loc26)
    %143 = llvm.bitcast %142 : vector<1xf32> to i32 loc(#loc26)
    %144 = llvm.insertelement %135, %0[%6 : i32] : vector<1xf32> loc(#loc26)
    %145 = llvm.bitcast %144 : vector<1xf32> to i32 loc(#loc26)
    %146 = llvm.insertelement %136, %0[%6 : i32] : vector<1xf32> loc(#loc26)
    %147 = llvm.bitcast %146 : vector<1xf32> to i32 loc(#loc26)
    %148 = llvm.insertelement %137, %0[%6 : i32] : vector<1xf32> loc(#loc26)
    %149 = llvm.bitcast %148 : vector<1xf32> to i32 loc(#loc26)
    %150 = llvm.inline_asm has_side_effects asm_dialect = att operand_attrs = [] "@$5 st.global.v4.b32 [ $4 + 0 ], { $0, $1, $2, $3 };", "r,r,r,r,l,b" %143, %145, %147, %149, %73, %78 : (i32, i32, i32, i32, !llvm.ptr<1>, i1) -> !llvm.void loc(#loc26)
    %151 = llvm.insertelement %138, %0[%6 : i32] : vector<1xf32> loc(#loc26)
    %152 = llvm.bitcast %151 : vector<1xf32> to i32 loc(#loc26)
    %153 = llvm.insertelement %139, %0[%6 : i32] : vector<1xf32> loc(#loc26)
    %154 = llvm.bitcast %153 : vector<1xf32> to i32 loc(#loc26)
    %155 = llvm.insertelement %140, %0[%6 : i32] : vector<1xf32> loc(#loc26)
    %156 = llvm.bitcast %155 : vector<1xf32> to i32 loc(#loc26)
    %157 = llvm.insertelement %141, %0[%6 : i32] : vector<1xf32> loc(#loc26)
    %158 = llvm.bitcast %157 : vector<1xf32> to i32 loc(#loc26)
    %159 = llvm.inline_asm has_side_effects asm_dialect = att operand_attrs = [] "@$5 st.global.v4.b32 [ $4 + 0 ], { $0, $1, $2, $3 };", "r,r,r,r,l,b" %152, %154, %156, %158, %74, %79 : (i32, i32, i32, i32, !llvm.ptr<1>, i1) -> !llvm.void loc(#loc26)
    llvm.return loc(#loc27)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("examples/kernels/binary_ops.py":106:26)
#loc3 = loc("examples/kernels/binary_ops.py":107:26)
#loc4 = loc("examples/kernels/binary_ops.py":108:22)
#loc5 = loc("examples/kernels/binary_ops.py":108:50)
#loc6 = loc("examples/kernels/binary_ops.py":108:37)
#loc7 = loc("examples/kernels/binary_ops.py":108:67)
#loc8 = loc("examples/kernels/binary_ops.py":109:22)
#loc9 = loc("examples/kernels/binary_ops.py":109:37)
#loc10 = loc("examples/kernels/binary_ops.py":109:67)
#loc11 = loc("examples/kernels/binary_ops.py":110:40)
#loc12 = loc("examples/kernels/binary_ops.py":110:52)
#loc13 = loc("examples/kernels/binary_ops.py":110:22)
#loc14 = loc("examples/kernels/binary_ops.py":111:40)
#loc15 = loc("examples/kernels/binary_ops.py":111:52)
#loc16 = loc("examples/kernels/binary_ops.py":111:22)
#loc17 = loc("examples/kernels/binary_ops.py":112:40)
#loc18 = loc("examples/kernels/binary_ops.py":112:52)
#loc19 = loc("examples/kernels/binary_ops.py":112:22)
#loc20 = loc("examples/kernels/binary_ops.py":114:31)
#loc21 = loc("examples/kernels/binary_ops.py":114:55)
#loc22 = loc("examples/kernels/binary_ops.py":114:37)
#loc23 = loc("examples/kernels/binary_ops.py":116:16)
#loc24 = loc("examples/kernels/binary_ops.py":117:16)
#loc25 = loc("examples/kernels/binary_ops.py":118:12)
#loc26 = loc("examples/kernels/binary_ops.py":119:21)
#loc27 = loc("examples/kernels/binary_ops.py":119:4)


// -----// IR Dump Before SymbolDCE (symbol-dce) ('builtin.module' operation) //----- //
#loc = loc("examples/kernels/binary_ops.py":97:0)
module attributes {ttg.global_scratch_memory_alignment = 1 : i32, ttg.global_scratch_memory_size = 0 : i32, "ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.shared = 0 : i32, ttg.target = "cuda:89", ttg.tensor_memory_size = 0 : i32, "ttg.threads-per-warp" = 32 : i32, "ttg.total-num-warps" = 4 : i32} {
  llvm.mlir.global external @global_smem() {addr_space = 3 : i32, alignment = 16 : i64} : !llvm.array<0 x i8> loc(#loc)
  llvm.func @add_2d_kernel(%arg0: !llvm.ptr<1> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg1: !llvm.ptr<1> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg2: !llvm.ptr<1> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg3: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg4: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg5: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg6: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg7: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg8: !llvm.ptr<1> loc("examples/kernels/binary_ops.py":97:0)) attributes {noinline = false, nvvm.kernel = 1 : ui1, nvvm.reqntid = array<i32: 128>, ttg.global_scratch_memory_alignment = 1 : i32, ttg.global_scratch_memory_size = 0 : i32} {
    %0 = llvm.mlir.undef : vector<1xf32> loc(#loc1)
    %1 = llvm.mlir.constant(16 : i32) : i32 loc(#loc1)
    %2 = llvm.mlir.constant(8 : i32) : i32 loc(#loc1)
    %3 = llvm.mlir.constant(4 : i32) : i32 loc(#loc1)
    %4 = llvm.mlir.constant(2 : i32) : i32 loc(#loc1)
    %5 = llvm.mlir.constant(1 : i32) : i32 loc(#loc1)
    %6 = llvm.mlir.constant(0 : i32) : i32 loc(#loc1)
    %7 = llvm.mlir.constant(0 : index) : i32 loc(#loc1)
    %8 = llvm.mlir.constant(32 : i32) : i32 loc(#loc1)
    %9 = llvm.mlir.constant(0.000000e+00 : f32) : f32 loc(#loc1)
    %10 = llvm.call_intrinsic "llvm.nvvm.read.ptx.sreg.ctaid.x"() : () -> i32 loc(#loc2)
    %11 = llvm.call_intrinsic "llvm.nvvm.read.ptx.sreg.ctaid.y"() : () -> i32 loc(#loc3)
    %12 = llvm.mul %10, %8 : i32 loc(#loc4)
    %13 = nvvm.read.ptx.sreg.tid.x : i32 loc(#loc5)
    %14 = llvm.urem %13, %8 : i32 loc(#loc5)
    %15 = llvm.udiv %13, %8 : i32 loc(#loc5)
    %16 = llvm.and %14, %2 : i32 loc(#loc5)
    %17 = llvm.icmp "eq" %16, %6 : i32 loc(#loc5)
    %18 = llvm.select %17, %6, %5 : i1, i32 loc(#loc5)
    %19 = llvm.xor %6, %18 : i32 loc(#loc5)
    %20 = llvm.and %14, %1 : i32 loc(#loc5)
    %21 = llvm.icmp "eq" %20, %6 : i32 loc(#loc5)
    %22 = llvm.select %21, %6, %4 : i1, i32 loc(#loc5)
    %23 = llvm.xor %19, %22 : i32 loc(#loc5)
    %24 = llvm.and %15, %5 : i32 loc(#loc5)
    %25 = llvm.icmp "eq" %24, %6 : i32 loc(#loc5)
    %26 = llvm.select %25, %6, %3 : i1, i32 loc(#loc5)
    %27 = llvm.xor %23, %26 : i32 loc(#loc5)
    %28 = llvm.and %15, %4 : i32 loc(#loc5)
    %29 = llvm.icmp "eq" %28, %6 : i32 loc(#loc5)
    %30 = llvm.select %29, %6, %2 : i1, i32 loc(#loc5)
    %31 = llvm.xor %27, %30 : i32 loc(#loc5)
    %32 = llvm.xor %31, %6 : i32 loc(#loc5)
    %33 = llvm.xor %31, %1 : i32 loc(#loc5)
    %34 = llvm.add %32, %7 : i32 loc(#loc5)
    %35 = llvm.add %33, %7 : i32 loc(#loc5)
    %36 = llvm.and %14, %5 : i32 loc(#loc5)
    %37 = llvm.icmp "eq" %36, %6 : i32 loc(#loc5)
    %38 = llvm.select %37, %6, %3 : i1, i32 loc(#loc5)
    %39 = llvm.xor %6, %38 : i32 loc(#loc5)
    %40 = llvm.and %14, %4 : i32 loc(#loc5)
    %41 = llvm.icmp "eq" %40, %6 : i32 loc(#loc5)
    %42 = llvm.select %41, %6, %2 : i1, i32 loc(#loc5)
    %43 = llvm.xor %39, %42 : i32 loc(#loc5)
    %44 = llvm.and %14, %3 : i32 loc(#loc5)
    %45 = llvm.icmp "eq" %44, %6 : i32 loc(#loc5)
    %46 = llvm.select %45, %6, %1 : i1, i32 loc(#loc5)
    %47 = llvm.xor %43, %46 : i32 loc(#loc5)
    %48 = llvm.xor %47, %6 : i32 loc(#loc5)
    %49 = llvm.add %48, %7 : i32 loc(#loc5)
    %50 = llvm.add %12, %34 : i32 loc(#loc6)
    %51 = llvm.add %12, %35 : i32 loc(#loc6)
    %52 = llvm.srem %50, %arg3 : i32 loc(#loc7)
    %53 = llvm.srem %51, %arg3 : i32 loc(#loc7)
    %54 = llvm.mul %11, %8 : i32 loc(#loc8)
    %55 = llvm.add %54, %49 : i32 loc(#loc9)
    %56 = llvm.srem %55, %arg4 : i32 loc(#loc10)
    %57 = llvm.mul %52, %arg5 : i32 loc(#loc11)
    %58 = llvm.mul %53, %arg5 : i32 loc(#loc11)
    %59 = llvm.add %57, %56 : i32 loc(#loc12)
    %60 = llvm.add %58, %56 : i32 loc(#loc12)
    %61 = llvm.getelementptr %arg0[%59] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc13)
    %62 = llvm.getelementptr %arg0[%60] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc13)
    %63 = llvm.mul %52, %arg6 : i32 loc(#loc14)
    %64 = llvm.mul %53, %arg6 : i32 loc(#loc14)
    %65 = llvm.add %63, %56 : i32 loc(#loc15)
    %66 = llvm.add %64, %56 : i32 loc(#loc15)
    %67 = llvm.getelementptr %arg1[%65] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc16)
    %68 = llvm.getelementptr %arg1[%66] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc16)
    %69 = llvm.mul %52, %arg7 : i32 loc(#loc17)
    %70 = llvm.mul %53, %arg7 : i32 loc(#loc17)
    %71 = llvm.add %69, %56 : i32 loc(#loc18)
    %72 = llvm.add %70, %56 : i32 loc(#loc18)
    %73 = llvm.getelementptr %arg2[%71] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc19)
    %74 = llvm.getelementptr %arg2[%72] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc19)
    %75 = llvm.icmp "slt" %52, %arg3 : i32 loc(#loc20)
    %76 = llvm.icmp "slt" %53, %arg3 : i32 loc(#loc20)
    %77 = llvm.icmp "slt" %56, %arg4 : i32 loc(#loc21)
    %78 = llvm.and %75, %77 : i1 loc(#loc22)
    %79 = llvm.and %76, %77 : i1 loc(#loc22)
    %80 = llvm.insertelement %9, %0[%7 : i32] : vector<1xf32> loc(#loc23)
    %81 = llvm.bitcast %80 : vector<1xf32> to i32 loc(#loc23)
    %82 = llvm.inline_asm has_side_effects asm_dialect = att operand_attrs = [] "mov.u32 $0, $4;\0A\09mov.u32 $1, $5;\0A\09mov.u32 $2, $6;\0A\09mov.u32 $3, $7;\0A\09@$9 ld.global.v4.b32 { $0, $1, $2, $3 }, [ $8 + 0 ];", "=r,=r,=r,=r,r,r,r,r,l,b" %81, %81, %81, %81, %61, %78 : (i32, i32, i32, i32, !llvm.ptr<1>, i1) -> !llvm.struct<(i32, i32, i32, i32)> loc(#loc23)
    %83 = llvm.extractvalue %82[0] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc23)
    %84 = llvm.bitcast %83 : i32 to vector<1xf32> loc(#loc23)
    %85 = llvm.extractvalue %82[1] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc23)
    %86 = llvm.bitcast %85 : i32 to vector<1xf32> loc(#loc23)
    %87 = llvm.extractvalue %82[2] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc23)
    %88 = llvm.bitcast %87 : i32 to vector<1xf32> loc(#loc23)
    %89 = llvm.extractvalue %82[3] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc23)
    %90 = llvm.bitcast %89 : i32 to vector<1xf32> loc(#loc23)
    %91 = llvm.extractelement %84[%7 : i32] : vector<1xf32> loc(#loc23)
    %92 = llvm.extractelement %86[%7 : i32] : vector<1xf32> loc(#loc23)
    %93 = llvm.extractelement %88[%7 : i32] : vector<1xf32> loc(#loc23)
    %94 = llvm.extractelement %90[%7 : i32] : vector<1xf32> loc(#loc23)
    %95 = llvm.inline_asm has_side_effects asm_dialect = att operand_attrs = [] "mov.u32 $0, $4;\0A\09mov.u32 $1, $5;\0A\09mov.u32 $2, $6;\0A\09mov.u32 $3, $7;\0A\09@$9 ld.global.v4.b32 { $0, $1, $2, $3 }, [ $8 + 0 ];", "=r,=r,=r,=r,r,r,r,r,l,b" %81, %81, %81, %81, %62, %79 : (i32, i32, i32, i32, !llvm.ptr<1>, i1) -> !llvm.struct<(i32, i32, i32, i32)> loc(#loc23)
    %96 = llvm.extractvalue %95[0] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc23)
    %97 = llvm.bitcast %96 : i32 to vector<1xf32> loc(#loc23)
    %98 = llvm.extractvalue %95[1] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc23)
    %99 = llvm.bitcast %98 : i32 to vector<1xf32> loc(#loc23)
    %100 = llvm.extractvalue %95[2] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc23)
    %101 = llvm.bitcast %100 : i32 to vector<1xf32> loc(#loc23)
    %102 = llvm.extractvalue %95[3] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc23)
    %103 = llvm.bitcast %102 : i32 to vector<1xf32> loc(#loc23)
    %104 = llvm.extractelement %97[%7 : i32] : vector<1xf32> loc(#loc23)
    %105 = llvm.extractelement %99[%7 : i32] : vector<1xf32> loc(#loc23)
    %106 = llvm.extractelement %101[%7 : i32] : vector<1xf32> loc(#loc23)
    %107 = llvm.extractelement %103[%7 : i32] : vector<1xf32> loc(#loc23)
    %108 = llvm.inline_asm has_side_effects asm_dialect = att operand_attrs = [] "mov.u32 $0, $4;\0A\09mov.u32 $1, $5;\0A\09mov.u32 $2, $6;\0A\09mov.u32 $3, $7;\0A\09@$9 ld.global.v4.b32 { $0, $1, $2, $3 }, [ $8 + 0 ];", "=r,=r,=r,=r,r,r,r,r,l,b" %81, %81, %81, %81, %67, %78 : (i32, i32, i32, i32, !llvm.ptr<1>, i1) -> !llvm.struct<(i32, i32, i32, i32)> loc(#loc24)
    %109 = llvm.extractvalue %108[0] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc24)
    %110 = llvm.bitcast %109 : i32 to vector<1xf32> loc(#loc24)
    %111 = llvm.extractvalue %108[1] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc24)
    %112 = llvm.bitcast %111 : i32 to vector<1xf32> loc(#loc24)
    %113 = llvm.extractvalue %108[2] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc24)
    %114 = llvm.bitcast %113 : i32 to vector<1xf32> loc(#loc24)
    %115 = llvm.extractvalue %108[3] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc24)
    %116 = llvm.bitcast %115 : i32 to vector<1xf32> loc(#loc24)
    %117 = llvm.extractelement %110[%7 : i32] : vector<1xf32> loc(#loc24)
    %118 = llvm.extractelement %112[%7 : i32] : vector<1xf32> loc(#loc24)
    %119 = llvm.extractelement %114[%7 : i32] : vector<1xf32> loc(#loc24)
    %120 = llvm.extractelement %116[%7 : i32] : vector<1xf32> loc(#loc24)
    %121 = llvm.inline_asm has_side_effects asm_dialect = att operand_attrs = [] "mov.u32 $0, $4;\0A\09mov.u32 $1, $5;\0A\09mov.u32 $2, $6;\0A\09mov.u32 $3, $7;\0A\09@$9 ld.global.v4.b32 { $0, $1, $2, $3 }, [ $8 + 0 ];", "=r,=r,=r,=r,r,r,r,r,l,b" %81, %81, %81, %81, %68, %79 : (i32, i32, i32, i32, !llvm.ptr<1>, i1) -> !llvm.struct<(i32, i32, i32, i32)> loc(#loc24)
    %122 = llvm.extractvalue %121[0] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc24)
    %123 = llvm.bitcast %122 : i32 to vector<1xf32> loc(#loc24)
    %124 = llvm.extractvalue %121[1] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc24)
    %125 = llvm.bitcast %124 : i32 to vector<1xf32> loc(#loc24)
    %126 = llvm.extractvalue %121[2] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc24)
    %127 = llvm.bitcast %126 : i32 to vector<1xf32> loc(#loc24)
    %128 = llvm.extractvalue %121[3] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc24)
    %129 = llvm.bitcast %128 : i32 to vector<1xf32> loc(#loc24)
    %130 = llvm.extractelement %123[%7 : i32] : vector<1xf32> loc(#loc24)
    %131 = llvm.extractelement %125[%7 : i32] : vector<1xf32> loc(#loc24)
    %132 = llvm.extractelement %127[%7 : i32] : vector<1xf32> loc(#loc24)
    %133 = llvm.extractelement %129[%7 : i32] : vector<1xf32> loc(#loc24)
    %134 = llvm.fadd %91, %117 : f32 loc(#loc25)
    %135 = llvm.fadd %92, %118 : f32 loc(#loc25)
    %136 = llvm.fadd %93, %119 : f32 loc(#loc25)
    %137 = llvm.fadd %94, %120 : f32 loc(#loc25)
    %138 = llvm.fadd %104, %130 : f32 loc(#loc25)
    %139 = llvm.fadd %105, %131 : f32 loc(#loc25)
    %140 = llvm.fadd %106, %132 : f32 loc(#loc25)
    %141 = llvm.fadd %107, %133 : f32 loc(#loc25)
    %142 = llvm.insertelement %134, %0[%6 : i32] : vector<1xf32> loc(#loc26)
    %143 = llvm.bitcast %142 : vector<1xf32> to i32 loc(#loc26)
    %144 = llvm.insertelement %135, %0[%6 : i32] : vector<1xf32> loc(#loc26)
    %145 = llvm.bitcast %144 : vector<1xf32> to i32 loc(#loc26)
    %146 = llvm.insertelement %136, %0[%6 : i32] : vector<1xf32> loc(#loc26)
    %147 = llvm.bitcast %146 : vector<1xf32> to i32 loc(#loc26)
    %148 = llvm.insertelement %137, %0[%6 : i32] : vector<1xf32> loc(#loc26)
    %149 = llvm.bitcast %148 : vector<1xf32> to i32 loc(#loc26)
    %150 = llvm.inline_asm has_side_effects asm_dialect = att operand_attrs = [] "@$5 st.global.v4.b32 [ $4 + 0 ], { $0, $1, $2, $3 };", "r,r,r,r,l,b" %143, %145, %147, %149, %73, %78 : (i32, i32, i32, i32, !llvm.ptr<1>, i1) -> !llvm.void loc(#loc26)
    %151 = llvm.insertelement %138, %0[%6 : i32] : vector<1xf32> loc(#loc26)
    %152 = llvm.bitcast %151 : vector<1xf32> to i32 loc(#loc26)
    %153 = llvm.insertelement %139, %0[%6 : i32] : vector<1xf32> loc(#loc26)
    %154 = llvm.bitcast %153 : vector<1xf32> to i32 loc(#loc26)
    %155 = llvm.insertelement %140, %0[%6 : i32] : vector<1xf32> loc(#loc26)
    %156 = llvm.bitcast %155 : vector<1xf32> to i32 loc(#loc26)
    %157 = llvm.insertelement %141, %0[%6 : i32] : vector<1xf32> loc(#loc26)
    %158 = llvm.bitcast %157 : vector<1xf32> to i32 loc(#loc26)
    %159 = llvm.inline_asm has_side_effects asm_dialect = att operand_attrs = [] "@$5 st.global.v4.b32 [ $4 + 0 ], { $0, $1, $2, $3 };", "r,r,r,r,l,b" %152, %154, %156, %158, %74, %79 : (i32, i32, i32, i32, !llvm.ptr<1>, i1) -> !llvm.void loc(#loc26)
    llvm.return loc(#loc27)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("examples/kernels/binary_ops.py":106:26)
#loc3 = loc("examples/kernels/binary_ops.py":107:26)
#loc4 = loc("examples/kernels/binary_ops.py":108:22)
#loc5 = loc("examples/kernels/binary_ops.py":108:50)
#loc6 = loc("examples/kernels/binary_ops.py":108:37)
#loc7 = loc("examples/kernels/binary_ops.py":108:67)
#loc8 = loc("examples/kernels/binary_ops.py":109:22)
#loc9 = loc("examples/kernels/binary_ops.py":109:37)
#loc10 = loc("examples/kernels/binary_ops.py":109:67)
#loc11 = loc("examples/kernels/binary_ops.py":110:40)
#loc12 = loc("examples/kernels/binary_ops.py":110:52)
#loc13 = loc("examples/kernels/binary_ops.py":110:22)
#loc14 = loc("examples/kernels/binary_ops.py":111:40)
#loc15 = loc("examples/kernels/binary_ops.py":111:52)
#loc16 = loc("examples/kernels/binary_ops.py":111:22)
#loc17 = loc("examples/kernels/binary_ops.py":112:40)
#loc18 = loc("examples/kernels/binary_ops.py":112:52)
#loc19 = loc("examples/kernels/binary_ops.py":112:22)
#loc20 = loc("examples/kernels/binary_ops.py":114:31)
#loc21 = loc("examples/kernels/binary_ops.py":114:55)
#loc22 = loc("examples/kernels/binary_ops.py":114:37)
#loc23 = loc("examples/kernels/binary_ops.py":116:16)
#loc24 = loc("examples/kernels/binary_ops.py":117:16)
#loc25 = loc("examples/kernels/binary_ops.py":118:12)
#loc26 = loc("examples/kernels/binary_ops.py":119:21)
#loc27 = loc("examples/kernels/binary_ops.py":119:4)


// -----// IR Dump Before LLVMDIScope (enable-line-info) ('builtin.module' operation) //----- //
#loc = loc("examples/kernels/binary_ops.py":97:0)
module attributes {ttg.global_scratch_memory_alignment = 1 : i32, ttg.global_scratch_memory_size = 0 : i32, "ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.shared = 0 : i32, ttg.target = "cuda:89", ttg.tensor_memory_size = 0 : i32, "ttg.threads-per-warp" = 32 : i32, "ttg.total-num-warps" = 4 : i32} {
  llvm.mlir.global external @global_smem() {addr_space = 3 : i32, alignment = 16 : i64} : !llvm.array<0 x i8> loc(#loc)
  llvm.func @add_2d_kernel(%arg0: !llvm.ptr<1> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg1: !llvm.ptr<1> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg2: !llvm.ptr<1> {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg3: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg4: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg5: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg6: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg7: i32 {tt.divisibility = 16 : i32} loc("examples/kernels/binary_ops.py":97:0), %arg8: !llvm.ptr<1> loc("examples/kernels/binary_ops.py":97:0)) attributes {noinline = false, nvvm.kernel = 1 : ui1, nvvm.reqntid = array<i32: 128>, ttg.global_scratch_memory_alignment = 1 : i32, ttg.global_scratch_memory_size = 0 : i32} {
    %0 = llvm.mlir.undef : vector<1xf32> loc(#loc1)
    %1 = llvm.mlir.constant(16 : i32) : i32 loc(#loc1)
    %2 = llvm.mlir.constant(8 : i32) : i32 loc(#loc1)
    %3 = llvm.mlir.constant(4 : i32) : i32 loc(#loc1)
    %4 = llvm.mlir.constant(2 : i32) : i32 loc(#loc1)
    %5 = llvm.mlir.constant(1 : i32) : i32 loc(#loc1)
    %6 = llvm.mlir.constant(0 : i32) : i32 loc(#loc1)
    %7 = llvm.mlir.constant(0 : index) : i32 loc(#loc1)
    %8 = llvm.mlir.constant(32 : i32) : i32 loc(#loc1)
    %9 = llvm.mlir.constant(0.000000e+00 : f32) : f32 loc(#loc1)
    %10 = llvm.call_intrinsic "llvm.nvvm.read.ptx.sreg.ctaid.x"() : () -> i32 loc(#loc2)
    %11 = llvm.call_intrinsic "llvm.nvvm.read.ptx.sreg.ctaid.y"() : () -> i32 loc(#loc3)
    %12 = llvm.mul %10, %8 : i32 loc(#loc4)
    %13 = nvvm.read.ptx.sreg.tid.x : i32 loc(#loc5)
    %14 = llvm.urem %13, %8 : i32 loc(#loc5)
    %15 = llvm.udiv %13, %8 : i32 loc(#loc5)
    %16 = llvm.and %14, %2 : i32 loc(#loc5)
    %17 = llvm.icmp "eq" %16, %6 : i32 loc(#loc5)
    %18 = llvm.select %17, %6, %5 : i1, i32 loc(#loc5)
    %19 = llvm.xor %6, %18 : i32 loc(#loc5)
    %20 = llvm.and %14, %1 : i32 loc(#loc5)
    %21 = llvm.icmp "eq" %20, %6 : i32 loc(#loc5)
    %22 = llvm.select %21, %6, %4 : i1, i32 loc(#loc5)
    %23 = llvm.xor %19, %22 : i32 loc(#loc5)
    %24 = llvm.and %15, %5 : i32 loc(#loc5)
    %25 = llvm.icmp "eq" %24, %6 : i32 loc(#loc5)
    %26 = llvm.select %25, %6, %3 : i1, i32 loc(#loc5)
    %27 = llvm.xor %23, %26 : i32 loc(#loc5)
    %28 = llvm.and %15, %4 : i32 loc(#loc5)
    %29 = llvm.icmp "eq" %28, %6 : i32 loc(#loc5)
    %30 = llvm.select %29, %6, %2 : i1, i32 loc(#loc5)
    %31 = llvm.xor %27, %30 : i32 loc(#loc5)
    %32 = llvm.xor %31, %6 : i32 loc(#loc5)
    %33 = llvm.xor %31, %1 : i32 loc(#loc5)
    %34 = llvm.add %32, %7 : i32 loc(#loc5)
    %35 = llvm.add %33, %7 : i32 loc(#loc5)
    %36 = llvm.and %14, %5 : i32 loc(#loc5)
    %37 = llvm.icmp "eq" %36, %6 : i32 loc(#loc5)
    %38 = llvm.select %37, %6, %3 : i1, i32 loc(#loc5)
    %39 = llvm.xor %6, %38 : i32 loc(#loc5)
    %40 = llvm.and %14, %4 : i32 loc(#loc5)
    %41 = llvm.icmp "eq" %40, %6 : i32 loc(#loc5)
    %42 = llvm.select %41, %6, %2 : i1, i32 loc(#loc5)
    %43 = llvm.xor %39, %42 : i32 loc(#loc5)
    %44 = llvm.and %14, %3 : i32 loc(#loc5)
    %45 = llvm.icmp "eq" %44, %6 : i32 loc(#loc5)
    %46 = llvm.select %45, %6, %1 : i1, i32 loc(#loc5)
    %47 = llvm.xor %43, %46 : i32 loc(#loc5)
    %48 = llvm.xor %47, %6 : i32 loc(#loc5)
    %49 = llvm.add %48, %7 : i32 loc(#loc5)
    %50 = llvm.add %12, %34 : i32 loc(#loc6)
    %51 = llvm.add %12, %35 : i32 loc(#loc6)
    %52 = llvm.srem %50, %arg3 : i32 loc(#loc7)
    %53 = llvm.srem %51, %arg3 : i32 loc(#loc7)
    %54 = llvm.mul %11, %8 : i32 loc(#loc8)
    %55 = llvm.add %54, %49 : i32 loc(#loc9)
    %56 = llvm.srem %55, %arg4 : i32 loc(#loc10)
    %57 = llvm.mul %52, %arg5 : i32 loc(#loc11)
    %58 = llvm.mul %53, %arg5 : i32 loc(#loc11)
    %59 = llvm.add %57, %56 : i32 loc(#loc12)
    %60 = llvm.add %58, %56 : i32 loc(#loc12)
    %61 = llvm.getelementptr %arg0[%59] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc13)
    %62 = llvm.getelementptr %arg0[%60] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc13)
    %63 = llvm.mul %52, %arg6 : i32 loc(#loc14)
    %64 = llvm.mul %53, %arg6 : i32 loc(#loc14)
    %65 = llvm.add %63, %56 : i32 loc(#loc15)
    %66 = llvm.add %64, %56 : i32 loc(#loc15)
    %67 = llvm.getelementptr %arg1[%65] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc16)
    %68 = llvm.getelementptr %arg1[%66] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc16)
    %69 = llvm.mul %52, %arg7 : i32 loc(#loc17)
    %70 = llvm.mul %53, %arg7 : i32 loc(#loc17)
    %71 = llvm.add %69, %56 : i32 loc(#loc18)
    %72 = llvm.add %70, %56 : i32 loc(#loc18)
    %73 = llvm.getelementptr %arg2[%71] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc19)
    %74 = llvm.getelementptr %arg2[%72] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc19)
    %75 = llvm.icmp "slt" %52, %arg3 : i32 loc(#loc20)
    %76 = llvm.icmp "slt" %53, %arg3 : i32 loc(#loc20)
    %77 = llvm.icmp "slt" %56, %arg4 : i32 loc(#loc21)
    %78 = llvm.and %75, %77 : i1 loc(#loc22)
    %79 = llvm.and %76, %77 : i1 loc(#loc22)
    %80 = llvm.insertelement %9, %0[%7 : i32] : vector<1xf32> loc(#loc23)
    %81 = llvm.bitcast %80 : vector<1xf32> to i32 loc(#loc23)
    %82 = llvm.inline_asm has_side_effects asm_dialect = att operand_attrs = [] "mov.u32 $0, $4;\0A\09mov.u32 $1, $5;\0A\09mov.u32 $2, $6;\0A\09mov.u32 $3, $7;\0A\09@$9 ld.global.v4.b32 { $0, $1, $2, $3 }, [ $8 + 0 ];", "=r,=r,=r,=r,r,r,r,r,l,b" %81, %81, %81, %81, %61, %78 : (i32, i32, i32, i32, !llvm.ptr<1>, i1) -> !llvm.struct<(i32, i32, i32, i32)> loc(#loc23)
    %83 = llvm.extractvalue %82[0] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc23)
    %84 = llvm.bitcast %83 : i32 to vector<1xf32> loc(#loc23)
    %85 = llvm.extractvalue %82[1] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc23)
    %86 = llvm.bitcast %85 : i32 to vector<1xf32> loc(#loc23)
    %87 = llvm.extractvalue %82[2] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc23)
    %88 = llvm.bitcast %87 : i32 to vector<1xf32> loc(#loc23)
    %89 = llvm.extractvalue %82[3] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc23)
    %90 = llvm.bitcast %89 : i32 to vector<1xf32> loc(#loc23)
    %91 = llvm.extractelement %84[%7 : i32] : vector<1xf32> loc(#loc23)
    %92 = llvm.extractelement %86[%7 : i32] : vector<1xf32> loc(#loc23)
    %93 = llvm.extractelement %88[%7 : i32] : vector<1xf32> loc(#loc23)
    %94 = llvm.extractelement %90[%7 : i32] : vector<1xf32> loc(#loc23)
    %95 = llvm.inline_asm has_side_effects asm_dialect = att operand_attrs = [] "mov.u32 $0, $4;\0A\09mov.u32 $1, $5;\0A\09mov.u32 $2, $6;\0A\09mov.u32 $3, $7;\0A\09@$9 ld.global.v4.b32 { $0, $1, $2, $3 }, [ $8 + 0 ];", "=r,=r,=r,=r,r,r,r,r,l,b" %81, %81, %81, %81, %62, %79 : (i32, i32, i32, i32, !llvm.ptr<1>, i1) -> !llvm.struct<(i32, i32, i32, i32)> loc(#loc23)
    %96 = llvm.extractvalue %95[0] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc23)
    %97 = llvm.bitcast %96 : i32 to vector<1xf32> loc(#loc23)
    %98 = llvm.extractvalue %95[1] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc23)
    %99 = llvm.bitcast %98 : i32 to vector<1xf32> loc(#loc23)
    %100 = llvm.extractvalue %95[2] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc23)
    %101 = llvm.bitcast %100 : i32 to vector<1xf32> loc(#loc23)
    %102 = llvm.extractvalue %95[3] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc23)
    %103 = llvm.bitcast %102 : i32 to vector<1xf32> loc(#loc23)
    %104 = llvm.extractelement %97[%7 : i32] : vector<1xf32> loc(#loc23)
    %105 = llvm.extractelement %99[%7 : i32] : vector<1xf32> loc(#loc23)
    %106 = llvm.extractelement %101[%7 : i32] : vector<1xf32> loc(#loc23)
    %107 = llvm.extractelement %103[%7 : i32] : vector<1xf32> loc(#loc23)
    %108 = llvm.inline_asm has_side_effects asm_dialect = att operand_attrs = [] "mov.u32 $0, $4;\0A\09mov.u32 $1, $5;\0A\09mov.u32 $2, $6;\0A\09mov.u32 $3, $7;\0A\09@$9 ld.global.v4.b32 { $0, $1, $2, $3 }, [ $8 + 0 ];", "=r,=r,=r,=r,r,r,r,r,l,b" %81, %81, %81, %81, %67, %78 : (i32, i32, i32, i32, !llvm.ptr<1>, i1) -> !llvm.struct<(i32, i32, i32, i32)> loc(#loc24)
    %109 = llvm.extractvalue %108[0] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc24)
    %110 = llvm.bitcast %109 : i32 to vector<1xf32> loc(#loc24)
    %111 = llvm.extractvalue %108[1] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc24)
    %112 = llvm.bitcast %111 : i32 to vector<1xf32> loc(#loc24)
    %113 = llvm.extractvalue %108[2] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc24)
    %114 = llvm.bitcast %113 : i32 to vector<1xf32> loc(#loc24)
    %115 = llvm.extractvalue %108[3] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc24)
    %116 = llvm.bitcast %115 : i32 to vector<1xf32> loc(#loc24)
    %117 = llvm.extractelement %110[%7 : i32] : vector<1xf32> loc(#loc24)
    %118 = llvm.extractelement %112[%7 : i32] : vector<1xf32> loc(#loc24)
    %119 = llvm.extractelement %114[%7 : i32] : vector<1xf32> loc(#loc24)
    %120 = llvm.extractelement %116[%7 : i32] : vector<1xf32> loc(#loc24)
    %121 = llvm.inline_asm has_side_effects asm_dialect = att operand_attrs = [] "mov.u32 $0, $4;\0A\09mov.u32 $1, $5;\0A\09mov.u32 $2, $6;\0A\09mov.u32 $3, $7;\0A\09@$9 ld.global.v4.b32 { $0, $1, $2, $3 }, [ $8 + 0 ];", "=r,=r,=r,=r,r,r,r,r,l,b" %81, %81, %81, %81, %68, %79 : (i32, i32, i32, i32, !llvm.ptr<1>, i1) -> !llvm.struct<(i32, i32, i32, i32)> loc(#loc24)
    %122 = llvm.extractvalue %121[0] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc24)
    %123 = llvm.bitcast %122 : i32 to vector<1xf32> loc(#loc24)
    %124 = llvm.extractvalue %121[1] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc24)
    %125 = llvm.bitcast %124 : i32 to vector<1xf32> loc(#loc24)
    %126 = llvm.extractvalue %121[2] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc24)
    %127 = llvm.bitcast %126 : i32 to vector<1xf32> loc(#loc24)
    %128 = llvm.extractvalue %121[3] : !llvm.struct<(i32, i32, i32, i32)>  loc(#loc24)
    %129 = llvm.bitcast %128 : i32 to vector<1xf32> loc(#loc24)
    %130 = llvm.extractelement %123[%7 : i32] : vector<1xf32> loc(#loc24)
    %131 = llvm.extractelement %125[%7 : i32] : vector<1xf32> loc(#loc24)
    %132 = llvm.extractelement %127[%7 : i32] : vector<1xf32> loc(#loc24)
    %133 = llvm.extractelement %129[%7 : i32] : vector<1xf32> loc(#loc24)
    %134 = llvm.fadd %91, %117 : f32 loc(#loc25)
    %135 = llvm.fadd %92, %118 : f32 loc(#loc25)
    %136 = llvm.fadd %93, %119 : f32 loc(#loc25)
    %137 = llvm.fadd %94, %120 : f32 loc(#loc25)
    %138 = llvm.fadd %104, %130 : f32 loc(#loc25)
    %139 = llvm.fadd %105, %131 : f32 loc(#loc25)
    %140 = llvm.fadd %106, %132 : f32 loc(#loc25)
    %141 = llvm.fadd %107, %133 : f32 loc(#loc25)
    %142 = llvm.insertelement %134, %0[%6 : i32] : vector<1xf32> loc(#loc26)
    %143 = llvm.bitcast %142 : vector<1xf32> to i32 loc(#loc26)
    %144 = llvm.insertelement %135, %0[%6 : i32] : vector<1xf32> loc(#loc26)
    %145 = llvm.bitcast %144 : vector<1xf32> to i32 loc(#loc26)
    %146 = llvm.insertelement %136, %0[%6 : i32] : vector<1xf32> loc(#loc26)
    %147 = llvm.bitcast %146 : vector<1xf32> to i32 loc(#loc26)
    %148 = llvm.insertelement %137, %0[%6 : i32] : vector<1xf32> loc(#loc26)
    %149 = llvm.bitcast %148 : vector<1xf32> to i32 loc(#loc26)
    %150 = llvm.inline_asm has_side_effects asm_dialect = att operand_attrs = [] "@$5 st.global.v4.b32 [ $4 + 0 ], { $0, $1, $2, $3 };", "r,r,r,r,l,b" %143, %145, %147, %149, %73, %78 : (i32, i32, i32, i32, !llvm.ptr<1>, i1) -> !llvm.void loc(#loc26)
    %151 = llvm.insertelement %138, %0[%6 : i32] : vector<1xf32> loc(#loc26)
    %152 = llvm.bitcast %151 : vector<1xf32> to i32 loc(#loc26)
    %153 = llvm.insertelement %139, %0[%6 : i32] : vector<1xf32> loc(#loc26)
    %154 = llvm.bitcast %153 : vector<1xf32> to i32 loc(#loc26)
    %155 = llvm.insertelement %140, %0[%6 : i32] : vector<1xf32> loc(#loc26)
    %156 = llvm.bitcast %155 : vector<1xf32> to i32 loc(#loc26)
    %157 = llvm.insertelement %141, %0[%6 : i32] : vector<1xf32> loc(#loc26)
    %158 = llvm.bitcast %157 : vector<1xf32> to i32 loc(#loc26)
    %159 = llvm.inline_asm has_side_effects asm_dialect = att operand_attrs = [] "@$5 st.global.v4.b32 [ $4 + 0 ], { $0, $1, $2, $3 };", "r,r,r,r,l,b" %152, %154, %156, %158, %74, %79 : (i32, i32, i32, i32, !llvm.ptr<1>, i1) -> !llvm.void loc(#loc26)
    llvm.return loc(#loc27)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("examples/kernels/binary_ops.py":106:26)
#loc3 = loc("examples/kernels/binary_ops.py":107:26)
#loc4 = loc("examples/kernels/binary_ops.py":108:22)
#loc5 = loc("examples/kernels/binary_ops.py":108:50)
#loc6 = loc("examples/kernels/binary_ops.py":108:37)
#loc7 = loc("examples/kernels/binary_ops.py":108:67)
#loc8 = loc("examples/kernels/binary_ops.py":109:22)
#loc9 = loc("examples/kernels/binary_ops.py":109:37)
#loc10 = loc("examples/kernels/binary_ops.py":109:67)
#loc11 = loc("examples/kernels/binary_ops.py":110:40)
#loc12 = loc("examples/kernels/binary_ops.py":110:52)
#loc13 = loc("examples/kernels/binary_ops.py":110:22)
#loc14 = loc("examples/kernels/binary_ops.py":111:40)
#loc15 = loc("examples/kernels/binary_ops.py":111:52)
#loc16 = loc("examples/kernels/binary_ops.py":111:22)
#loc17 = loc("examples/kernels/binary_ops.py":112:40)
#loc18 = loc("examples/kernels/binary_ops.py":112:52)
#loc19 = loc("examples/kernels/binary_ops.py":112:22)
#loc20 = loc("examples/kernels/binary_ops.py":114:31)
#loc21 = loc("examples/kernels/binary_ops.py":114:55)
#loc22 = loc("examples/kernels/binary_ops.py":114:37)
#loc23 = loc("examples/kernels/binary_ops.py":116:16)
#loc24 = loc("examples/kernels/binary_ops.py":117:16)
#loc25 = loc("examples/kernels/binary_ops.py":118:12)
#loc26 = loc("examples/kernels/binary_ops.py":119:21)
#loc27 = loc("examples/kernels/binary_ops.py":119:4)


